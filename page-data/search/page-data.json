{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n2020년을 맞아 이미 많이 알고 있는 ES2015(ES6) 다음부터인 ES2016부터 ES2020까지 새로 나온 자바스크립트 기능들을 살펴보려고 합니다. \r\n\r\n모두 소개하는 건 아니고 비교적 도움이 되는, 대표적인 것들을 추려 소개합니다.  \r\n또한 기초적인 사전 지식의 설명은 생략될 수 있습니다.\r\n\r\n<br/>\r\n\r\n## ES2016\r\n\r\n### Array.prototype.includes\r\n\r\n배열 내장 함수 includes가 추가되었습니다.\r\n\r\n```javascript\r\n['a', 'b', 'c'].includes('a') // true\r\n```\r\n\r\n코드를 보면 쉽게 역할을 알 수 있습니다.\r\n배열에 아이템이 존재하는지 Boolean 값을 반환합니다.\r\n\r\n이 함수로 이제 `['a','b','c'].indexOf('a') > -1` 대신 좀 더 간결한 코드가 가능합니다.\r\n\r\n### Exponentiation operator\r\n\r\n제곱 연산자.\r\n기존에 제곱은 Math의 pow 함수를 이용했을 것입니다. \r\n이제는 간단하게 `**` 연산자로 가능하게 되었습니다.\r\n\r\n```javascript\r\nlet num = 2;\r\n\r\nMath.pow(num, 10); // 1024\r\n2 ** 10; // 1024\r\n\r\nnum **= 10;\r\nnum; // 1024\r\n```\r\n\r\n<br/>\r\n\r\n## ES2017\r\n\r\n### String padding\r\n\r\n문자열에 여백을 주기 위해 등장한 기능입니다. \r\n여백 뿐만 아니라 그 여백에 보충 문자를 추가할 수 있습니다.\r\n\r\n여백을 앞에 뒤에 추가할 수 있게 됩니다.\r\n\r\n```javascript\r\npadStart(targetLength [, padString])\r\npadEnd(targetLength [, padString])\r\n```\r\n\r\n간단한 예를 통해 살펴보겠습니다. start와 end의 차이는 앞뒤의 차이밖에 없으니 start만 살펴봅니다.\r\n\r\n`1월` 을 `01월` 과 같이 길이를 맞춰야 할 경우가 있다 이럴때 사용 할 수 있습니다.\r\n\r\n```javascript\r\n`1월`.padStart(1);        // \"1월\"\r\n`1월`.padStart(3);        // \" 1월\"\r\n`1월`.padStart(3, \"0\");   // \"01월\"\r\n`1월`.padStart(7, \"0AB\"); // \"0AB0A1월\"\r\n```\r\n\r\n1번째 라인처럼 문자열보다 작은 수를 지정하더라도 문자열이 잘리거나 하진 않습니다\r\n\r\n2번째 라인은 문자열의 길이보다 하나 긴 3을 넣어 하나의 여백이 추가된 모습입니다.\r\n\r\n3번째 라인이 원하는 의도인 코드입니다.\r\n\r\n4번째 라인처럼 보충 문자를 배열로 작성하면 배열을 순회 반복하며 여백을 채우며 0, A, B를 채우고 다음으로 0, A까지 채워진 모습을 볼 수 있습니다.\r\n\r\n### Object.values()\r\n\r\nObject에 추가된 values 메소드는 객체의 key:value 에서 value 값들을 배열으로 반환합니다.\r\n\r\n```javascript\r\nconst obj1 = {name: \"Jhon\", age: 24};\r\nObject.values(obj1); // [\"Jhon\", 24]\r\n```\r\n\r\n### Object.entries()\r\n\r\n객체 안의 모든 속성을 각각 key, value가 담긴 배열로 하나의 배열에 담습니다.\r\n[[key, value], [key, value], [key, value] ...]\r\n\r\n```javascript\r\nconst obj1 = {name: \"Jhon\", age: 24};\r\n\r\nObject.keys(obj1);    // [\"name\", \"age\"]\r\nObject.values(obj1);  // [\"Jhon\", 24]\r\n\r\nObject.entries(obj1); // [[\"name\", \"Jhone\"], [\"age\", 24]]\r\n```\r\n\r\n### Object.getOwnPropertyDescriptors()\r\n\r\nObject에 기존에 있던 getOwnPropertyDescriptor에 이어 복수형 s가 붙은 getOwnPropertyDescriptors 메소드가 추가되었습니다.\r\n\r\n해당 메소드를 이해하기 위해서는 선행 지식으로 getOwnPropertyDescriptor가 무엇인지 알아야하며 속성 설명자의 네가지 속성을 알아야합니다. ([링크](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor) 참조)\r\n\r\n또한 Object.defineProperties() 같은 메소드를 알고 있어야 유용하게 활용할 방법이 생깁니다. 여기서는 자세한 설명없이 해당 메소드에 대해서만 설명합니다.\r\n\r\n```javascript\r\nObject.getOwnPropertyDescriptor(obj, prop)\r\n```\r\n\r\n기존의 getOwnPropertyDescriptor는 인자로 객체와 속성명을 전달해 해당 속성의 속성 설명자를 반환하는 메소드입니다.\r\n\r\n이제 여기서 설명하는 getOwnPropertyDescriptors는 속성명을 전달하지 않고 객체만 전달함으로 객체내의 모든 속성에 대한 속성 설명자를 반환합니다. \r\n\r\n```javascript\r\nObject.getOwnPropertyDescriptor(obj)\r\n```\r\n\r\n두개의 예제입니다.\r\n\r\n```javascript\r\nconsole.log(Object.getOwnPropertyDescriptor(obj1, \"name\"));\r\n// Object {value: \"Jhon\", writable: true, enumerable: true, configurable: true}\r\n\r\nconsole.log(Object.getOwnPropertyDescriptors(obj1));\r\n// Object {\r\n//   name: {value: \"Jhon\", writable: true, enumerable: true, configurable: true}, \r\n//   age: {value: 24, writable: true, enumerable: true, configurable: true}\r\n// }\r\n```\r\n\r\n### Trailing commas\r\n\r\n함수의 마지막 매개변수와 인자에도 콤마를 넣을 수 있습니다.\r\n\r\n아래와 같이 말이죠. 해당 기능이 왜 추가되었는지는 다양한 의견이 있습니다. 흥미가 있는 분들은 한번 검색해보세요.\r\n\r\n```javascript\r\nconst foo = (a, b, c,) => {}\r\n```\r\n\r\n### async/await\r\n\r\n사실상 ES2017의 핵심이라고 볼 수 있습니다. \r\n\r\n새로운 비동기 처리 함수로 기존의 Promise 보다 가독성이 좋은 코드를 작성할 수 있게 되었습니다. 선행적으로 비동기 처리에 대한 지식과 Promise의 이해가 필요합니다.\r\n\r\n해당 내용은 여기서 간단히 다루기에는 중요하고 내용이 길어 따로 포스팅을 할 예정입니다.\r\n\r\n아래 링크는 async/await를 설명한 캡틴판교님의 포스트입니다.\r\n\r\n[CAPTAIN PANGYO - 자바스크립트 async와 await](https://joshua1988.github.io/web-development/javascript/js-async-await/)\r\n\r\n<br/>\r\n\r\n## ES2018\r\n\r\n### Rest/Spread Properties\r\n\r\n기존의 배열에서 사용하던 rest/spread를 객체에서도 사용가능하게 되었습니다.\r\n\r\n```javascript\r\n// Rest\r\nconst { one, two, ...others } = { one: 1, two: 2, three: 3, four: 4, five: 5 }\r\nconsole.log(one, two, others); // 1 2 {three: 3, four: 4, five: 5}\r\n\r\n// Spread\r\nconst obj1 = {one, two, ... others};\r\nconsole.log(obj); // {one: 1, two: 2, three: 3, four: 4, five: 5}\r\n\r\nconst obj2 = { one: 100, five: 500 };\r\nconst obj3 = { five: 5000 };\r\nconst obj = { ...obj1, ...obj2, ...obj3};\r\nconsole.log(obj); // {one: 100, two: 2, three: 3, four: 4, five: 5000}\r\n```\r\n\r\n마지막 라인의 obj의 출력을 보면 같은 속성 이름에 대해서는 앞의 것을 뒤의 것이 덮어쓴다는 것을 알 수 있다.\r\n\r\n### Promise.prototype.finally()\r\n\r\nthen, catch, finally에서 Promise는 기존에 then과 catch만 가능했으나 이제 finally도 추가되었습니다.\r\n\r\n```javascript\r\nPromise.resolve('reslove')\r\n.then((res) => console.log('success'))\r\n.catch((err) => console.log('fail'))\r\n.finally(() => console.log('finally'))\r\n```\r\n\r\n### Asynchronous iteration\r\n\r\n비동기 이터러블 객체를 순회하는 것이 가능해졌습니다.\r\n\r\n이해를 위해서는 Promise, async/await의 이해가 선행됩니다.\r\n\r\n```javascript\r\nfor await (const req of requests) {\r\nconsole.log(req)\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n## ES2019\r\n\r\n### String.trimStart() & trimEnd()\r\n\r\n문자열의 앞이나 뒤의 공백을 제거한다.\r\n\r\n앞을 제거하는 trimStart와 뒤를 제거하는 trimEnd가 있다.\r\n\r\n아래 예제를 보면 쉽게 이해할 수 있다.\r\n\r\n```javascript\r\nconst s = \"     hello world\";\r\nconst e = \"!     \";\r\n\r\nconsole.log(s + e + ';');\r\n// \"     hello world!     ;\"\r\n\r\nconsole.log(s.trimStart() + e.trimEnd() + ';');\r\n// \"hello world!;\"\r\n```\r\n\r\n### Optional Catch Binding\r\n\r\ncatch 매개변수 없이도 catch 블록을 사용할 수 있습니다.\r\n\r\n```javascript\r\ntry {\r\n// some code\r\n}\r\ncatch (err) {\r\n// error handling code\r\n}\r\n```\r\n\r\n위와 같이 `catch(err){}` 또는 `catch(){}` 와 같이 사용하던 것을 아래와 같이 사용할 수 있습니다.\r\n\r\n```javascript\r\ntry {\r\n// some code\r\n}\r\ncatch {\r\n// error handling code\r\n}\r\n```\r\n\r\n### Object.fromEntries()\r\n\r\n위에서 설명한 `Object.entries()` 의 정반대입니다.\r\n\r\n객체를 entries로 배열로 만들었다면 fromEntries로 다시 객체로 만들 수 있다는 이야기입니다. entires를 이해했다면 간단하게 아래 예제를 통해 알 수 있습니다.\r\n\r\n```javascript\r\nconst obj1 = {name: \"Jhon\", age: 24};\r\n\r\nconst entries = Object.entries(obj1); \r\nconsole.log(entries); // [[\"name\", \"Jhone\"], [\"age\", 24]]\r\n\r\nconst fromEntries = Object.fromEntries(entries);\r\nconsole.log(fromEntries); // {name: \"Jhon\", age: 24}\r\n```\r\n\r\n### Array.flat() & flatMap()\r\n\r\nflat 메소드는 배열안의 배열을 쉽게 합칠 수 있게 됩니다.\r\n예제를 통해 쉽게 이해할 수 있습니다.\r\n\r\n```javascript\r\nconst arr = [1, , 2, [3, 4, [5, 6]]];\r\n\r\nconsole.log(arr.flat());  // [1, 2, 3, 4, [5, 6]]\r\nconsole.log(arr.flat(1)); // [1, 2, 3, 4, [5, 6]]\r\n\r\nconsole.log(arr.flat(2)); // [1, 2, 3, 4, 5, 6]\r\n```\r\n\r\nflat의 인자로는 배열의 깊이를 넘겨줄 수 있으며, 전달된 인자가 없을 경우 default는 1이다. 또한 빈 배열은 무시된다.\r\n\r\nflatMap 메소드는 `map()`과 `flat()`이 합쳐진 것으로 볼 수 있다. 우선 map을 통해 새로운 배열을 만들고 flat을 통해 배열이 합쳐진다. (flatMap의 깊이는 1입니다)\r\n\r\n```javascript\r\nconst arr = [1,2,3];\r\n\r\nconst map = arr.map(v => [v]);\r\nconst flatMap = arr.flatMap(v=> [v]);\r\n\r\nconsole.log(map);         // [[1], [2], [3]]\r\nconsole.log(map.flat());  // [1, 2, 3]\r\n\r\nconsole.log(flatMap);     // [1, 2, 3]\r\n```\r\n\r\n<br/>\r\n\r\n## ES2020\r\n\r\n### Dynamic Import\r\n\r\n파일 import를 동적으로 할 수 있게 되었습니다.\r\n\r\n아래 예제는 if문에 따라 import한 파일의 사용 유무가 달라지는데 조건에 맞지 않더라도 일단은 최상단의 import를 통해 파일을 불러옵니다.\r\n그러나 이제는 두번째 코드 예제와 같이 Dynamic Import로 인해 불필요한 동작을 줄일 수 있게 되었습니다.\r\n\r\n```javascript\r\nimport config from './config.js';\r\n\r\nif(response) {\r\nage = config.age;\r\n}\r\n\r\nif(response) {\r\nimport('./config.js')\r\n.then(config => {\r\n  age = config.age;\r\n  console.log(config);\r\n}\r\n}\r\n```\r\n\r\n참고로 Dynamic import 예제인 두번째 코드에서 console.log의 출력 결과는 `{age: 24, skills: [\"react\", \"webpack\"], default: \"Jhon\"}` 입니다.\r\n그렇다면 config 파일의 내용은 아래와 같습니다.\r\n\r\n```javascript\r\nexport const age = 24;\r\n\r\nexport const skills = [\"react\", \"webpack\"];\r\n\r\nexport default \"Jhon\";\r\n```\r\n\r\ndefault로 export를 한 것은 default라는 속성 이름을 가지는 것을 알아두세요.\r\n\r\n### BigInt\r\n\r\nBigInt는 `2^53` 보다 큰 정수를 취급하기 위해 등장했습니다.\r\n\r\n숫자 뒤에 n이 붙는 특징을 가지고 있습니다.\r\n예로 `10n` 은 숫자 `10`을 뜻한다는 의미입니다.\r\n\r\n자세한 예와 설명은 아래 예제로 설명하겠습니다.\r\n\r\n```javascript\r\nconst int1 = Number.MAX_SAFE_INTEGER + 1; \r\n// 9007199254740992\r\n\r\nconst int2 = Number.MAX_SAFE_INTEGER + 2; \r\n// 9007199254740992  <= ~993이 아니다.\r\n\r\nconst bigInt2 = BigInt(Number.MAX_SAFE_INTEGER) + 2n; \r\n// 9007199254740993n <= ~993이 되었다.\r\n\r\nconsole.log(typeof int1, typeof int2, typeof bigInt2); \r\n// number number bigint\r\n\r\nconsole.log(typeof 9007199254740993n); // bigint\r\nconsole.log(9007199254740993n === bigInt2); // true\r\n// 일반적인 숫자 뒤에 n을 붙이는 것으로 bitint 타입을 가진다는 것을 알 수 있습니다.\r\n\r\nconsole.log(BigInt(10), BigInt(10n));\r\n// 10n 10n <= BitInt의 인자로는 n의 여부가 중요하지 않다.\r\n\r\nconsole.log(10 === BigInt(10)); // false\r\nconsole.log(10 == BigInt(10)); // true\r\n\r\n// console.log(9007199254740993n + 1);\r\n// 위 코드는 에러가 발생한다. bigint를 연산할때는 number 타입과 섞어쓰는 것이 안된다.\r\n```\r\n\r\n### Promise.allSettled\r\n\r\n`Promise.all()`은 모든 작업이 성공(reslove)해야 실행되는 특징과 달리 `Promise.allSettled()`은 도중에 실패(reject)되더라도 모든 실행을 할 수 있습니다.\r\n\r\n아래 예제를 통해 코드와 실행 결과를 살펴봅시다.\r\n\r\n```javascript\r\nconst p1 = new Promise((resolve, reject) => resolve(\"p1, resolved\"));\r\nconst p2 = new Promise((resolve, reject) => resolve(\"p2, resolved\"));\r\nconst p3 = new Promise((resolve, reject) => reject(\"p3, rejected\"));\r\n\r\nPromise.all([p1, p2, p3])\r\n.then(response => console.log(response))\r\n.catch(err => {\r\nconsole.log(err);\r\n});\r\n/*\r\nconsole.log(response)\r\n{status: \"fulfilled\", value: \"p1, resolved\"}\r\n{status: \"fulfilled\", value: \"p2, resolved\"}\r\n{status: \"rejected\", reason: \"p3, rejected\"}\r\n*/\r\n\r\nPromise.allSettled([p1, p2, p3])\r\n.then(response => console.log(response))\r\n.catch(err => {\r\nconsole.log(err);\r\n});\r\n/*\r\nconsole.log(err);\r\np3, rejected\r\n*/\r\n```\r\n\r\n### Nullish Coalescing Operator\r\n\r\n`a ?? b` 로 나타내는 연산자입니다. `null`이나 `undefined`일 때만 `b`를 반환합니다.\r\n\r\n0은 false를 의미하기도 합니다.\r\n따라서 `0 || 'A'` 는 `A` 가 될겁니다. \r\n하지만 0이 의미있는 값이면 0 또한 사용해야 할 것입니다.\r\n또한 삼항 연산자를 단축시켜 사용할 수 있는 장점도 있습니다.\r\n\r\n예제를 통해 살펴봅시다.\r\n\r\n```javascript\r\n0 || 'A'    // A\r\n0 ?? 'A'    // 0\r\n\r\n0 ? 0 : 'A' // A\r\n0 ?? 'A'    // 0\r\n```\r\n\r\n### Optional Chaining\r\n\r\n`foo.a.b` 에 접근한다고 했을 때, `a`가 없다면 오류가 발생하게 됩니다.\r\n\r\n따라서 오류를 방지하기 위해 `if(foo.a && foo.a.b)` 와 같이 사용하곤 합니다.\r\n\r\n하지만 Optional Chaining을 이용하면 오류가 발생하지 않고 undefined를 반환받습니다.\r\n\r\nOptional Chaining은 `foo.a?.b` 와 같이 표현합니다.\r\n\r\n```javascript\r\nconst foo = {\r\na: {\r\nb: true\r\n}\r\n};\r\n\r\nconsole.log(foo.a.b); // true\r\nconsole.log(foo.b?.b); // undefined\r\n\r\nconsole.log(foo.b.aa); // TypeError: Cannot read property 'aa' of undefined\r\n```","excerpt":"2020년을 맞아 이미 많이 알고 있는 ES2015(ES6) 다음부터인 ES2016부터 ES202…","fields":{"slug":"/es2016-es2020/"},"frontmatter":{"date":"Jan 22, 2020","title":"ECMAScript ES2016~ES2020 정리","tags":["javascript"],"update":"Feb 06, 2020"}}},{"node":{"rawMarkdownBody":"\r\n뒤늦은 Hooks 포스팅입니다. Hooks 기본을 정리해보고, 사용해오면서 알게 된 점도 정리해봅니다.  \r\n간단히 useState에 대해 설명하고, useEffect에 대해서는 조금 더 자세하게 알아봅니다.\r\n\r\n---\r\n\r\nHooks는 React 16.8부터 등장한 새로운 기능입니다.  \r\nClass Component가 아니더라도 Functional Component에서 state 및 기타 기능을 사용할 수 있게 합니다.\r\n\r\n아래는 리액트 공식 문서의 Hooks 설명 일부입니다.\r\n\r\n> Hook는 알고 있는 React 컨셉을 대체하지 않습니다. 대신에, Hook는 props, state, context, refs, 그리고 lifecycle와 같은 React 개념에 좀 더 직관적인 API를 제공합니다. 또한 Hook는 이 개념들을 엮기 위해 새로운 강력한 방법을 제공합니다.\r\n\r\n일반적으로 Functional Component를 사용하게 되면 state를 사용할 수 없고 React LifeCycle을 사용할 수 없다는 한계에 부딪치게 되는데 Hooks의 등장으로 새로운 방법이 제공됩니다. (Effect Hooks 부분에서 자세히 알아봅니다)\r\n\r\n## useState()\r\n\r\n기존의 Class Component에서 사용하던 것을 보면 아래와 같습니다.\r\n\r\n```js\r\nclass Example extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      count: 0\r\n    };\r\n  }\r\n```\r\n\r\n위와 같이 state를 선언하고 `this.setState({ count: 1 })`와 같이 setState 함수를 통해 state 값을 변경할 것입니다.\r\n\r\n기존의 state를 다루는 방법은 useState Hooks를 이용하게 됩니다.  \r\n아래의 코드는 useState를 사용한 예제입니다.\r\n\r\n```js\r\nimport React, { useState } from 'react';\r\n\r\nconst Example = () => {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <p>You clicked {count} times</p>\r\n      <button onClick={() => setCount(count + 1)}>Click me</button>\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\nuseState는 아래와 같이 사용합니다.\r\n\r\n```js\r\nconst [count, setCount] = useState(0);\r\n```\r\n\r\n`useState()`가 `count`, `setCount`로 [구조 분해 할당](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment '구조 분해 할당')되어있습니다.  \r\nuseState는 state 변수와 해당 변수를 변경할 수 있는 함수(즉, setState 함수)를 반환합니다.  \r\n따라서 아래와 같은 방법으로도 사용할 수 있습니다. 이렇게 사용할 일은 없겠지만 말입니다.\r\n\r\n```js\r\nconst countVariables = useState(0);\r\n\r\ncountVariables[1](20); // == setCount\r\nconsole.log(countVariables[0]); // 20, == count\r\n```\r\n\r\nClass Component 방식에서 사용하던 setState를 통해서는 기존의 state와 새로운 state를 합치는 방법으로 state 값이 변경되었으나, useState를 사용한 setState인 예제에서 setCount를 통해서는 state를 합치는 방식이 아닌 count state만을 변경하게 됩니다.\r\n\r\n### 요약\r\n\r\n#### 선언\r\n\r\n```js\r\nimport React, { useState } from 'react';\r\n\r\nconst Example = () => {\r\n  const [count, setCount] = useState(0);\r\n  //...\r\n```\r\n\r\n#### 갱신\r\n\r\n```js\r\n<button onClick={() => setCount(count + 1)}>\r\n// or\r\n<button onClick={() => setCount(prevCount => prevCount + 1)}>\r\n  // 기존의 setState 함수와 유사하게 prevState를 사용할 수 있습니다.\r\n```\r\n\r\n#### state 사용, 가져오기\r\n\r\n```js\r\n<p>You clicked {count} times</p>\r\n```\r\n\r\n## useEffect()\r\n\r\nuseState는 간단하고 사용하기 쉽습니다.  \r\nuseEffect는 간단한 사용은 쉬울지 모르나, 제대로 동작을 이해하려면 깊게 공부가 필요해보입니다. 따라서 여기서는 사용함에 있어 햇갈리지 않고 오류를 범하지 않으면서 기본적인 동작을 이해하는 수준에서 기술하겠습니다. 기존 Class Component의 Life Cycle을 이해하고 있다는 전제하에 진행합니다.\r\n\r\n아래 코드를 보겠습니다.\r\n\r\n```js\r\nimport React, { useEffect, useState } from 'react';\r\n\r\nexport const FuncComp = () => {\r\n  const [count1, setCount1] = useState(0);\r\n  const [count2, setCount2] = useState(0);\r\n\r\n  useEffect(() => {\r\n    console.log('useEffect');\r\n  });\r\n\r\n  return (\r\n    <div>\r\n      <button\r\n        onClick={() => {\r\n          setCount1(count1 + 1);\r\n        }}\r\n      >\r\n        FuncComp>count1 + (current: {count1})\r\n      </button>\r\n\r\n      <button\r\n        onClick={() => {\r\n          setCount2(count2 + 1);\r\n        }}\r\n      >\r\n        FuncComp>count2 + (current: {count2})\r\n      </button>\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\n해당 코드는 count1, count2의 state를 가지고 있습니다.  \r\n그리고 각각의 state를 변경(증가)하는 버튼이 위치합니다.\r\n\r\nuseEffect가 위치한 곳을 봐주세요.  \r\n여기서 useEffect의 안에 함수가 실행되는 시점.  \r\n즉, console.log가 작동하는 시점을 기존 Class Component의 LifeCycle의 관점에서 보면 아래와 같습니다.\r\n\r\n- componentDidMount\r\n- componentDidUpdate\r\n\r\n마운트와 업데이트 시점에서 “useEffect” 문구가 출력되게 됩니다.  \r\n위의 예에서는 첫 로드시, `count1` `count2`가 업데이트 될 때 출력됩니다.\r\n\r\n간단히 보자면 위 useEffect안의 함수는 “매 렌더링마다 실행된다”라고 생각하면 쉽습니다.\r\nprops, state가 변경될때마다 렌더링이 실행될테니말입니다.\r\n\r\n### 의존성 추가\r\n\r\n이제 아래 코드를 살펴보겠습니다.\r\n\r\n```js\r\nuseEffect(() => {\r\n  console.log('useEffect');\r\n}, [count1]);\r\n```\r\n\r\n`useEffect(fn)`형태에서 `useEffect(fn, [])`가 되어 인자로 배열이 추가되었습니다.\r\n\r\n여기서 배열은 **의존성**을 담은 배열로,  \r\n위와 같이 `count1`을 담는다면 이제 마운트시에 호출되고, 그 후로는 `count1`이 변경될때만 호출되어 “useEffect”문구가 출력될 것입니다.\r\n\r\n위의 예제에서 `count1`을 증가시키는 버튼을 누르면 “useEffect”문구가 출력될것이고, `count2`에서는 출력되지 않습니다.\r\n\r\n여기서 의존성 배열을 비운다면 어떻게 될까요\r\n\r\n```js\r\nuseEffect(() => {\r\n  console.log('useEffect');\r\n}, []);\r\n```\r\n\r\n위의 코드는 간단하게 말하면 componentDidMount의 역활을 대체할 수 있습니다.  \r\n의존성 배열 자체를 인자로 넘기지 않으면 모든 state(+props)가 변경될 때 호출되게 되지만 넘긴다면 해당 의존성이 변경될때 호출되게 되고 비어있다면 마운트시에만 호출되게 되는 것입니다.  \r\n따라서 componentDidMount를 구현하고 싶다면 해당 코드와 같이 작성하면 됩니다.\r\n\r\n### CleanUp\r\n\r\n아래 코드를 살펴봅시다. 의존성으로 `count1`을 가진 이펙트입니다.\r\n\r\n```js\r\nuseEffect(() => {\r\n  console.log('count1', count);\r\n\r\n  return () => {\r\n    console.log('count1 CleanUp', count);\r\n  };\r\n}, [count]);\r\n```\r\n\r\n위의 코드를 보면 return 라인이 추가되어 함수를 반환합니다.\r\n\r\n마운트 시, 그리고 `count1`에 변동이 있을 때 “count1” 문구가 출력될 것을 예상할 수 있습니다.\r\n“count1 CleanUp”은 언제 출력될까요?\r\n\r\n일단 마운트가 되면 “count1”이 출력됩니다.\r\n그 후 count1을 증가시키게되면 아래와 같은 과정을 거치게됩니다.  \r\n증가시키기 전인 count 값은 0입니다.  \r\n(이해를 위한 과정 설명으로 실제 작동은 이와 다를 수 있습니다)\r\n\r\n1. count = 0인 해당 이펙트(위의 코드) 클린업 과정 실행\r\n2. count = 1에 해당하는 렌더링\r\n3. count = 1에 해당하는 이펙트 실행\r\n   이를 통해 업데이트 이전에 클린업이 실행된다는 사실을 알고있으면 됩니다.\r\n\r\n또한 클린업은 언마운트시에도 작동하게 됩니다.\r\n따라서 만약 해당 컴포넌트가 언마운트되면 위 코드의 클린업도 실행되게 됩니다.\r\n\r\n아래 코드를 살펴보겠습니다.\r\n\r\n```js\r\nuseEffect(() => {\r\n  console.log('mount');\r\n\r\n  return () => {\r\n    console.log('unmount');\r\n  };\r\n}, []);\r\n\r\nuseEffect(() => {\r\n  console.log('update count1');\r\n\r\n  return () => {\r\n    console.log('update count1 or unmount');\r\n  };\r\n}, [count]);\r\n```\r\n\r\n코드의 첫번째 이펙트는 componentDidMount의 기능을 한다고 설명했던 코드입니다.  \r\n두번째 이펙트는 바로 위에서 살펴본 코드와 같습니다.\r\n\r\n아래의 동작을 하면 어떤 순서로 출력문이 나올지 보겠습니다.\r\n\r\n1. 페이지 로드 (컴포넌트 마운트)\r\n2. count1 증가 버튼 클릭\r\n3. 해당 컴포넌트 사라지게함 (언마운트)\r\n\r\n```shell\r\n< \"mount\"\r\n< \"update count1\"\r\n< \"update count1 or unmount\"\r\n< \"update count1\"\r\n< \"update count1 or unmount\"\r\n< \"unmount\"\r\n```\r\n\r\n1~2라인은 마운트에 해당하는 출력입니다.  \r\n3~4라인은 `count1`값을 업데이트하면서 클린업-\\>이펙트의 과정을 거친 출력입니다.  \r\n5~6라인은 컴포넌트가 언마운트되면서 이펙트들의 클린업이 실행된 출력입니다.\r\n\r\n6라인을 보아 해당 이펙트(빈 의존성 배열)의 클린업은 componentWillUnmount의 기능을 하는 것을 알 수 있습니다.\r\n\r\n클린업은 DOM에 추가한 이벤트 리스너를 컴포넌트가 언마운트될때 제거할 경우 등의 경우에서 사용되게 될겁니다.\r\n\r\n### 요약\r\n\r\n**Mount (componentDidMount)**\r\n\r\n```js\r\nuseEffect(() => console.log('mount'), []);\r\n```\r\n<br/>\r\n\r\n**Unmount (componentWillUnmount)**\r\n\r\n```js\r\nuseEffect(() => () => console.log('unmount'), []);\r\n```\r\n<br/>\r\n\r\n**Update Any**\r\n\r\n```js\r\nuseEffect(() => console.log('will update any'));\r\n```\r\n<br/>\r\n\r\n**Update Any or Unmount**\r\n\r\n```js\r\nuseEffect(() => () => console.log('will update any or unmount'));\r\n```\r\n<br/>\r\n\r\n**Update `Count`**\r\n\r\n```js\r\nuseEffect(() => console.log('will update count'), [count]);\r\n```\r\n<br/>\r\n\r\n**Update `Count` or Unmount**\r\n\r\n```js\r\nuseEffect(() => () => console.log('will update count or unmount'), [count]);\r\n```\r\n<br/>\r\n<br/>\r\n\r\n---\r\n<br/>\r\n\r\n**References**\r\n\r\n- [React Document | Hooks](https://reactjs.org/docs/hooks-intro.html 'React Document | Hooks')\r\n- [stackoverflow | react hooks useEffect() cleanup for only componentWillUnmount?](https://stackoverflow.com/a/55041347)\r\n","excerpt":"뒤늦은 Hooks 포스팅입니다. Hooks 기본을 정리해보고, 사용해오면서 알게 된 점도 정리해봅니다. 간단히 useState에 대해 설명하고, useEffect에 대해서는 조금 더 자세하게 알아봅니다. Hooks는 React 16.…","fields":{"slug":"/react-hooks/"},"frontmatter":{"date":"Jan 08, 2020","title":"React Hooks: useState, useEffect 알아보기","tags":["react"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n**지금 이 글을 보고 있는 블로그는 Borderless 테마를 사용하고 있는 블로그입니다.**\r\n\r\n_Gatsby를 이용해 제작되었으며 Gatsby에 대한 간략한 설명은 이전 글([Gatsby로 블로그 만들기](/create-gatsby-blog))에서 확인 할 수 있습니다._\r\n\r\n**[Borderless 블로그 - 소개](/develop-blog-v3_2)**에서 borderless 테마의 기능과 특징을 확인하세요.\r\n\r\n이 블로그와 같은 블로그를 만들고 싶다면 이 글을 간략하게 참고하시고,  \r\n**[Documents](<https://github.com/junhobaik/junhobaik.github.io/wiki/Document-(Borderless)>)**에서 자세한 방법을 참고하세요.\r\n\r\n---\r\n\r\n_\\* 아래 설명과 문서는 Github Pages에 배포되는 것을 기준으로 설명합니다._  \r\n_\\* 이 글에서는 매우 간략하게 방법을 기술하고 있습니다. 자세한 것은 문서에서 확인하세요_\r\n\r\n## Install\r\n\r\n해당 블로그로 시작하기 위한 방법은 두가지가 있습니다.\r\n\r\n1. 테마 Repository Fork 후 사용\r\n1. 테마 Repository Clone 후 사용\r\n\r\n### 1. **Fork**로 시작하기\r\n\r\n- 해당 Repository를 Fork 한 후,\r\n\r\n1. Repository의 이름을 \"**username**.github.io\"로 변경합니다.\r\n1. `Setting > Branches - Default branch`에서 기본 Branch를 변경합니다. **develop**를 선택하고 Update 버튼을 눌러 진행하세요.\r\n1. 이제 본인의 Repository를 Clone 합니다.\r\n1. `$ npm i` 명령어로 패키지 설치\r\n1. `$ npm start` 명령어로 개발 서버 시작  \r\n   \"localhost:8000\"에서 확인할 수 있습니다.\r\n\r\n### 2. **Clone**으로 시작하기\r\n\r\n```shell\r\n$ git clone -b develop https://github.com/junhobaik/junhobaik.github.io.git [SITE_DIRECTORY]\r\n$ npm install\r\n```\r\n\r\n위의 과정을 통해 develop 브랜치를 기본으로 해당 저장소를 클론하고 필요한 패키지를 설치합니다.\r\n\r\n```shell\r\n$ npm start\r\n```\r\n\r\n개발 서버를 실행하며 localhost:8000에서 확인할 수 있습니다.\r\n\r\n## Basic Settings\r\n\r\n`./config.js` 파일을 개인에 맞춰 수정합니다.  \r\n문자열은 ''로 비워두어 해당 기능을 비활성화 할 수 있습니다. (Site MetaData는 필수로 작성)\r\n\r\n아래는 예제입니다.\r\n\r\n```javascript\r\nmodule.exports = {\r\n  /** Site MetaData (Required all)*/\r\n  title: `Dev.White`,\r\n  description: `Junho Baik's Development Blog`,\r\n  author: `Junho Baik`,\r\n  siteUrl: 'https://junhobaik.github.io',\r\n\r\n  /** Header */\r\n  profileImageFileName: 'profile.png',\r\n\r\n  /** Home > Bio information*/\r\n  comment: 'Jr. Web Front-end Developer. / javascript, react ...',\r\n  name: 'Junho Baik',\r\n  company: '',\r\n  location: 'Korea',\r\n  email: 'junhobaik@gmail.com',\r\n  website: 'https://junhobaik.github.io',\r\n  linkedin: '',\r\n  facebook: '',\r\n  instagram: 'https://www.instagram.com/junhobaik',\r\n  github: 'https://github.com/junhobaik',\r\n\r\n  /** Post */\r\n  enablePostOfContents: true,\r\n  disqusShortname: 'junhobaik',\r\n\r\n  /** Optional */\r\n  googleAnalytics: 'UA-123123123-0',\r\n  googleAdsenseClient: 'ca-pub-5001380215831339',\r\n  googleAdsenseSlot: '5214956675',\r\n};\r\n```\r\n\r\n## Writing Posts\r\n\r\n`./posts`에 마크다운 파일을 위치시켜 게시물을 만들 수 있습니다.\r\n\r\n`./drafts`에 마크다운 파일을 위치시켜 임시 게시물을 만들 수 있습니다.  \r\n(개발 환경에서만 표시, 배포시 표시되지 않는 게시물)\r\n\r\n### Markdown YAML Front matter\r\n\r\n마크다운 상단에 아래와 같은 형식으로 게시물 정보를 입력합니다. 여기는 제목과 날짜가 필수로 들어가며 추가적으로 태그와 키워드를 넣을 수 있습니다.  \r\n그 후 하단에는 게시물의 내용을 입력합니다.\r\n자세한 작성법은 문서의 Markdown YAML Front matter란을 확인하세요.\r\n\r\n```\r\n---\r\ntitle: title here...\r\ndate: 2018-01-01\r\ntags:\r\n  - javascript\r\n  - ES6\r\nkeywords:\r\n  - keyword1\r\n  - keyword2\r\n---\r\n\r\n... Content here ...\r\n\r\n```\r\n\r\n## Deploy\r\n\r\n```\r\n$ npm run deploy\r\n```\r\n\r\n위의 명령어로 배포가 시작됩니다. master 브랜치로 commit이 자동으로 이루어지며,\r\n반영되기까지는 수십초 정도, 때로는 최대 수분의 시간이 소요됩니다.\r\n\r\n이제 본인의 주소로 들어가 확인할 수 있습니다.\r\n\r\n---\r\n\r\n더 자세한 Borderless 테마 사용법은 [Documents](<https://github.com/junhobaik/junhobaik.github.io/wiki/Document-(Borderless)>)를 참고하세요.\r\n","excerpt":"지금 이 글을 보고 있는 블로그는 Borderless 테마를 사용하고 있는 블로그입니다. Gatsby를 이용해 제작되었으며 Gatsby에 대한 간략한 설명은 이전 글(Gatsby로 블로그 만들기)에서 확인 할 수 있습니다. Borderless…","fields":{"slug":"/develop-blog-v3_3/"},"frontmatter":{"date":"Dec 30, 2019","title":"Borderless 테마로 Gatsby 블로그 만들기","tags":["undefined"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n정적 사이트 제작 프레임워크 Gatsby를 이용해 만든 블로그,  \r\n“Borderless” 테마입니다.\r\n\r\n- 심플한 디자인\r\n- 마크다운 지원\r\n- 게시물 태그 기능\r\n- 게시물 검색 기능\r\n- 시리즈 게시물 기능\r\n- Google Analytics\r\n- Google Adsense\r\n- Disqus 댓글 기능\r\n- 검색 엔진 최적화(SEO)\r\n\r\n## 화면 설명\r\n\r\n### Home 화면\r\n\r\n게시물 목록을 볼 수 있는 홈 화면으로,  \r\n타이틀 이미지가 크게 표시되며 프로필 정보가 함께 표시됩니다.  \r\n게시물 목록에는 게시물의 제목, 날짜, 태그, 요약이 표시됩니다.  \r\n프로필 정보에는 소개 문구, 이름, 회사, 위치, 메일, 웹사이트, RSS, 소셜(페이스북, 링크드인, 인스타그램, 깃허브)를 표시할 수 있습니다.\r\n\r\n![](DraggedImage.png)\r\n\r\n스크롤 다운시 헤더와 프로필 정보가 숨겨져 게시물 목록에 집중할 수 있습니다.\r\n\r\n![](DraggedImage-1.png)\r\n\r\n### Post 화면\r\n\r\n게시물 화면입니다.  \r\n헤더는 스크롤 다운시 감춰지며 게시물의 내용에 집중할 수 있습니다.  \r\n화면의 크기가 충분히 넓을 경우 목차가 우측에 표시되며, 그렇지 않을 경우 게시물의 상단에 목차 버튼으로 목차를 볼 수 있습니다.  \r\n목차는 클릭하여 해당 위치로 이동할 수 있고, 스크롤 위치에 따라 보고있는 목차 부분이 강조되어 보고있는 위치를 알 수 있습니다.\r\n\r\n![](DraggedImage-2.png)\r\n\r\n![](screenshot.png)\r\n\r\n게시물에 하단에는 게시물을 소셜 공유 할 수 있는 버튼들이 위치합니다.  \r\n그 아래로는 광고와 댓글이 위치합니다.\r\n\r\n#### 시리즈 게시물\r\n\r\n만약 시리즈 게시물이라면 위와 같이 게시물 상단에 시리즈 목록이 표시됩니다.\r\n\r\n![](DraggedImage-4.png)\r\n\r\n### 태그 화면\r\n\r\n태그 화면에서는 모든 태그가 표시되며,  \r\n게시물 수가 많은 태그는 텍스트 크기가 크게 표시됩니다.  \r\n현재 보고있는 태그는 텍스트가 진하게 표시됩니다.  \r\n아래는 태그에 해당하는 게시물 목록이 표시됩니다.\r\n\r\n![](DraggedImage-5.png)\r\n\r\n### 검색 화면\r\n\r\n제목, 제목+내용으로 검색이 가능합니다.  \r\n검색 결과에 따른 게시물 목록이 아래 표시됩니다.\r\n\r\n![](DraggedImage-6.png)\r\n\r\n## 그 외 기능\r\n\r\n- 간단히 설정 파일의 내용 몇가지만 수정하면 자신의 블로그로 활용할 수 있습니다.\r\n- Google Analytics의 TrackingID를 설정에서 입력하여 쉽게 등록 및 관리할 수 있습니다.\r\n- 자신의 Google Adsense 정보를 설정에서 입력해서 쉽게 구글 애드센스를 활용할 수 있습니다.\r\n- 자신의 Disqus 사이트 생성 후 shortname을 설정에서 입력하면 쉽게 댓글 기능을 활성화 할 수 있습니다.\r\n- 검색 엔진 최적화로 기본 설정만 입력하면 따로 부가적인 작업 없이 구글 검색 결과에 문제 없이 노출될 수 있습니다.\r\n- 웹 표준 준수로 Safari 브라우저 등 읽기 모드(Reader Mode)를 지원합니다.\r\n- 마크다운내에서 이모지, 수학 표기법(ktex)를 지원합니다.\r\n- 임시 게시물(draft)을 작성할 수 있습니다. 개발 환경에서는 표시되며 배포시 표시되지 않습니다.\r\n\r\n## Borderless 블로그로 자신의 블로그 시작하기\r\n\r\n지금 보고있는 이 블로그를 자신의 블로그로 커스터마이징하여 사용할 수 있습니다.\r\n\r\n아래 링크를 통해 Get Started, Document를 확인 할 수 있습니다.\r\n\r\n[Documents](<https://github.com/junhobaik/junhobaik.github.io/wiki/Document-(Borderless)>)\r\n","excerpt":"정적 사이트 제작 프레임워크 Gatsby를 이용해 만든 블로그, “Borderless” 테마입니다. 심플한 디자인 마크다운 지원 게시물 태그 기능 게시물 검색 기능 시리즈 게시물 기능 Google Analytics Google Adsense…","fields":{"slug":"/develop-blog-v3_2/"},"frontmatter":{"date":"Dec 30, 2019","title":"Borderless 블로그 - 소개","tags":["blog"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n![](DraggedImage.png)\r\n\r\n[기존 블로그](https://priceless-darwin-0a5ad6.netlify.com/)에서 새로 블로그를 구현했다.\r\n\r\n테마 이름은 “Borderless”이다.  \r\n말그대로 블로그 디자인 요소에 선이 없어서 이렇게 지었다.\r\n\r\n이번에도 동일하게 Gatsby를 이용하여 제작했고 태그와 검색 기능이 있는 것은 이전 블로그와 비슷한 구조이다.\r\n\r\n그런데 이전 블로그는 GraphQL도 완전 백지 상태에서 껴맞추기식으로 구현해서 지저분한 곳이 있었고,  \r\n디자인쪽으로도 깔끔하고자했지만 뭔가 조잡한듯한 느낌을 지울 수 없었다.\r\n\r\n블로그를 운영하면서 느끼게 된 점을 바탕으로 다시 디자인하고 생각하여 만들게 되었다.\r\n\r\n홈화면을 화려하고 예쁘게 만들고 검색이나 태그 기능을 예쁘고 다양한 기능으로 무장하고... 하는 것도 좋겠지만,\r\n\r\n블로그 유입은 9할 이상이 검색을 통해서 이루어진다. 따라서 방문자는 게시물을 보는 것이 제일 중요하고 그 이후에 블로그를 둘러보는 행동을 하는 사람은 거의 없다고 보면 된다.\r\n\r\n그에 맞춰서 최대한 게시물에 집중 할 수 있는 디자인을 하고, 블로그를 시작한 의도에 맞춰 내가 필요하고 사용하기 편하게만 만들면 되는 것이다.\r\n\r\n그래서 딱 몇가지만 고려했다.\r\n\r\n- 내 정보를 보여줄 수 있었으면,\r\n- 뭔가를 살펴볼땐 그것에만 집중 할 수 있어야한다.\r\n- 불필요한 스타일, 애니메이션, 기능은 제거하자.\r\n\r\n그래서 구현한 결과는 이렇게 된다.\r\n\r\n**내 정보를 보여줄 수 있었으면,**  \r\n좌측에 개인 프로필과 메뉴가 위치한 블로그를 자주 볼 수 있다. 그러한 UI를 어느정도 원했다 프로필이 있었으면 했다. 하지만 좌측에 항상 뭐가 있다면 내용에 집중하는데 방해가 된다고 생각했고 반응형 디자인에도 좋지 않다고 생각해서 이러한 UI 보다는 다른 UI를 생각하게 되었다.  \r\n상단에 헤더가 위치하고, 블로그 로고 이미지와 블로그 제목이 좌측으로, 우측에는 메뉴(태그, 검색)가 위치한다.  \r\n게시물이나, 태그, 검색등의 작업을 할때는 로고와 텍스트가 작은 크기로 위치하다가 홈화면(게시물 목록 화면)으로 위치하면 로고 이미지의 크기가 커진다. 그리고 로고 이미지와 제목 아래 프로필 정보들이 나열된다. 이렇게 구현하면 마치 좌측에 프로필이 위치한 UI와 비슷하게 보인다. 하지만 홈화면에서 게시물 목록을 훑어보기 위해 스크롤하면 헤더와 프로필 정보가 감춰지면서 게시물 목록에만 집중 할 수 있게 된다.\r\n\r\n![](DraggedImage-1.png)\r\n\r\n**뭔가를 살펴볼땐 그것에만 집중 할 수 있어야한다.**  \r\n기본적으로 헤더를 항상 표시가 아닌 스크롤에 따라 숨기고 나타나도록 구현했다.  \r\n그래서 게시물을 읽을땐 온전히 게시물에만 집중 할 수 있고, 그 외로 표시되는 것은 TableOfContents 즉, 목차 뿐이다. 이것도 투명도를 낮춰 게시물을 읽는데 집중할 수 있도록 했다.\r\n\r\n![](DraggedImage-2.png)\r\n\r\n홈화면에서는 앞서 프로필을 설명하는 부분에서 설명한 것과 같이 스크롤 시에는 헤더와 프로필 정보가 모두 숨겨지며 보이는 것은 게시물 목록 뿐이다.\r\n\r\n**불필요한 스타일, 애니메이션, 기능은 제거하자.**  \r\n기존에는 선, 배경색으로 개체들을 꾸미고 그림자를 입히고, 거기에 마우스 오버시 살짝 앞으로 나오는 듯한 애니메이션을 넣는 등 예뻐보이기 위해 이것저것 했는데 이번에는 정말 심플 그 자체가 되고자 했다.  \r\n그래서 생각한게 선과 색을 넣지 말자는 것이었다.  \r\n스타일에 선, 색, 그림자가 없다. (마크다운 게시물 안에는 당연하게 있을 수 있다..)  \r\n따라서 입체감도 없다. 머터리얼 디자인이 유행하면서 입체감에 많은 신경을 썼었는데 이번에는 아예 반대로 입체감이 없이 해보기로 했다. 어짜피 내용에만 집중하도록 디자인하다보니 입체감이 중요하지 않았다. 불필요한 요소는 보이지 않을테니까.  \r\n그리고 애니메이션은 최소화했다. 헤더와 프로필 부분 말고는 큰 애니메이션이 없다.  \r\n이 블로그 테마 이름을 Borderless라고 했는데, 바로 선이 없다는 이유에서다.\r\n\r\n---\r\n\r\n이러한 것 이외에도 세세한 구석에 신경을 많이 썼다.  \r\nUX를 고려해서 어느 곳에서도 부드럽게 전환이 가능하도록 신경썼고,  \r\n블로그가 기본적으로 해야하는 기능, 그리고 추가적으로 있으면 좋은 기능들도 당연히 구현했다.  \r\n대표적으로 Google Analytics, Disqus 가 있다. 애널리틱스는 웹 운영에 필수고, 댓글 또한 블로그에 없어서는 안될 기능이다.  \r\n구현 중에 본인의 Disqus를 새로 설정하면서 기존 댓글이 지워진 아쉬움이 있긴하다.\r\n\r\n글을 쓰는 현재 아직 몇가지 해야할 것이 남았다.  \r\n몇가지 수정할 게 남았고, 그 다음으로 해야할 것이 다른 사람들이 이용할 수 있게 만들어두는 것이다. 기본적인 정보만 수정하면 자신의 블로그로 만들어 사용할 수 있게 처음부터 고려해서 만들어졌다. 이전 블로그도 이와 비슷하게 배포했는데 메일이나 댓글로 질문이 몇번와서 이번에는 문서를 조금 더 정성들여 적어봐야겠다.\r\n\r\n다음으로는 간단하게 블로그를 소개하고, 그 다음에는 이 블로그를 자신의 블로그로 만드는 방법을 자세하게 적어볼 수 있도록 하려 한다.\r\n","excerpt":"기존 블로그에서 새로 블로그를 구현했다. 테마 이름은 “Borderless”이다. 말그대로 블로그 디자인 요소에 선이 없어서 이렇게 지었다. 이번에도 동일하게 Gatsby…","fields":{"slug":"/develop-blog-v3_1/"},"frontmatter":{"date":"Dec 30, 2019","title":"Borderless 블로그 - 개발기","tags":["blog","gatsby"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n이 글은 개발해서 운영하고 있는 서비스에 대한 잡담과 같은 후기이다.\r\n\r\n현재까지 개발해서 지속적으로 운영하고 있는 결과물은 5개 정도이다.\r\n\r\n- Blog\r\n- Netflix AutoSkip\r\n- Tablo\r\n- Tablo (version 2)\r\n- WhatSubs\r\n\r\n## [Blog](https://junhobaik.github.io/)\r\n\r\n최근 새로 새단장을 했다. 지금 보고 있는 이 블로그이다. 새로 만들게 된 이유는 심플함을 항상 추구했지만 뭔가 항상 맘에 들지 않았고 그래서 새로 처음부터 구현하면서 몇몇 코드만 가져다가 만들게 되었다. 그러는 김에 있었으면 하는 기능도 몇가지 추가할 겸 말이다.  \r\n이번에 블로그는 완전 깔끔하게 게시물에 집중할 수 있는 디자인으로 만들었다. 블로그 테마(?)의 이름은 \"Borderless\"로 지었다. 디자인은 말 그대로 선이 없다. 스타일에 border가 존재하지 않는다. 선(border)뿐만 아니라 배경색, 그림자를 넣지 않았다. 그러면서도 세련되게 만들려고 노력을 많이 했다. 지금은 개인적으로 상당히 만족스럽게 만들어진것 같다. 아직은 구현이 끝나지 않았다. 디테일한 몇군데 수정만 거치고 나면 완성될 것 같다. 전에 쓰던 블로그와 비슷하게 다른 분들도 사용이 가능하게 배포할 예정이다.\r\n\r\n게시물 부분에서는 업데이트를 자주 못했지만 개인적으로 저장하기 위해 시작했고 블로그를 개발하는 것도 스터디에 한부분이었던 블로그인데 조회수를 보면 조금 더 신경써야되나 싶다.\r\n\r\nGoogle Analytics를 통해 살펴보면 올해 총 페이지뷰가 대략 11만이 넘었다.  \r\n애널리틱스를 자세히 살펴보다보면 재밌는 부분이 많다. 다른 사이트에서 내 블로그를 링크를 통해 들어오면 그 링크된 사이트가 어디인지 알 수 있는데 거길 들어가서 살펴보면 내 글도 누군가에게 도움이 되고 있구나라는 생각이 든다.\r\n생활코딩의 강의 댓글에 내 블로그 글을 보면 도움이 될거라는 댓글을 보고 굉장히 뿌듯했던 기억이 난다.\r\n\r\n그리고 몇달전인가 도입한 에드센스를 살펴보면 조회된 애드센스 광고 단위수가 2만이 넘었다.  \r\n이것도 수익보다는 에드센스 도입을 한번 해보자라고 스터디 차원에서 한 것이었다.\r\n지금까지 총 수익은 7달러이다. 광고 차단 프로그램 탓도 있을 수 있겠다. 광고 차단 프로그램을 막을 수 있겠지만 수익을 생각하고 구현했던 것도 아니고 또한 광고 노출이 아닌 직접 클릭을 해야 수익이 나오는 것 같다.\r\n\r\n그리고 블로그를 남들도 쓸 수 있도록 구현했는데 (이것도 스터디 차원에서 해본..) fork해서 블로그로 잘 운영하고 있는 분도 계시는 걸 보니 또 뿌듯했다. 업데이트를 제대로 한번 해야겠다는 생각도 든다. 지금은 게시물만 종종 올리고 블로그 자체는 만족하고 그냥 쓰고 있으니 말이다.\r\n\r\n## [Netflix AutoSkip](https://chrome.google.com/webstore/detail/netflix-autoskip-intro-ne/pfcombngcgnehkbdoafkhdcfdmklboai)\r\n\r\n간단하고 간략한 코드로 구현된 크롬 확장프로그램이다.\r\n\r\n넷플릭스를 크롬 브라우저로 보는데 키보드와 마우스에서 멀리 떨어져서 볼 경우 인트로 스킵이나 다음 동영상을 넘기는 버튼을 누르러 다시 컴퓨터나 TV 앞으로 가는 것이 귀찮아 만들었는데 생각보다 많은 사람들이 쓰고 있다. 현재 3000명 정도가 전세계에서 쓰고 있고 이것도 애널리틱스에서 실시간 접속자로 전세계에서 접속하고 있는 위치 모습을 보면 재미있다.\r\n\r\n만드는 것들이 모두 내가 필요해서 만들기 시작한 것들이 대부분인데 이 앱은 쓰는 사람들이 좀 있고 버그가 있었을 적엔 메일로 피드백이 몇번 오기도 했다. 그런데 이 웹앱을 사겠다는 메일이 몇군데서, 그것도 다른 나라에서 왔었는데 이게 뭔가 싶다. 엄청 많은 사람이 쓰고 있는 것도 아니고 간단한 코드로 구현되었고 코드도 다 공개되어있는데...\r\n\r\nDOM 트리가 변경되는 것을 기준으로 기능이 동작하는데 이번에 넷플릭스 UI가 조금 변경되면서 최근에 새로 업데이트를 했다.\r\n\r\n얼마 전 수정하면서 기능이 유사한 다른 앱들을 살펴보니 아직 대응들을 안한 것인지 인트로 스킵과 다음 에피소드 재생 대기를 스킵하는 것이 모두 잘되는 것은 내 앱 뿐이었다.\r\n\r\n## [Tablo](https://chrome.google.com/webstore/detail/tablo-bookmark-and-manage/aoccnljcdmmbihgabpoljghfcmbflkhc)\r\n\r\ntrello와 비슷한 UI로 task가 아닌 link를 저장해 즐겨찾기와 같이 이용하는 크롬 확장프로그램으로 크롬의 새탭을 열면 열리는 웹앱이다. 크롬 시작화면 웹앱이라고도 할 수 있다.\r\n\r\n현재 열려있는 탭 목록을 표시하고 거기서 드래그해서 자신만의 즐겨찾기 목록을 만드는게 주요 컨셉이었고 확장 프로그램 아이콘을 통해 웹 서핑 중 즐겨찾기 목록에 추가하는 것도 가능하다.\r\n\r\n개발을 하고 따로 계속해서 발전시키지는 않았다. UI가 가로 스크롤이 필요한 UI이다보니 가로 스크롤에 대한 고민을 계속하긴 했었고 그에 대해 몇가지 변경이 이뤄지긴 했다.\r\n\r\n개인적으로 필요해서 만들었고 잘 쓰고 있긴 했지만 계속해서 발전시키지 않은 이유는 새로운 기능을 포함해 새롭게 다시 만들 생각을 하고 있었기 때문이었고 그로 인해 Tablo version2를 만들게 되었다.\r\n\r\n## [Tablo (version 2)](https://chrome.google.com/webstore/detail/tablo/aflhcldanmopecmjjinnenkcddghjnkn)\r\n\r\n이번에는 세로 형식의 trello 형식이 아닌 가로 형식으로 바꾸었고, 기존의 현재 열린 탭들 목록에서 자신의 즐겨찾기 목록으로 드래그하는 것, 확장 프로그램 아이콘을 통해 웹 서핑중 해당 사이트를 자신의 즐겨찾기 목록에 추가하는 것은 그대로 유지되었다.\r\n\r\n추가된 주요 기능은 간단하게 말하면 rss 구독 기능이다. rss 구독 주소를 등록할 수 있고 구독한 사이트들의 게시물이 화면에 보이게 된다.\r\n\r\n내가 브라우저를 켰을때 어디로 이동할 지 즐겨찾기와 같은 목록이 보였으면 좋겠고,  \r\n내가 관심있는 기술 블로그들의 최신 게시물을 쉽게 한곳에서 확인하고 싶었고,  \r\n웹 서핑이나 서치중에 나중에 보기위해 저장할 곳이 필요했다.\r\n\r\n위와 같은 이유를 모두 만족하는 내게 필요한 웹앱을 만들었다.\r\n원하는 기능은 거의 구현했으며 크롬 웹스토어에 출시했다 이제 디테일한 수정과 개선을 계속해나가면 된다.\r\n\r\n## [WhatSubs](https://junhobaik.github.io/whatsubs-dev-story/)\r\n\r\n최근에 만들었고 구글 플레이스토어, 앱스토어 심사를 통과했다.  \r\n[개발기](https://junhobaik.github.io/whatsubs-dev-story/)도 간단히 써놓은 것이 있다.\r\n\r\nWhat(무엇) + Subscription(구독)을 합친 이름으로 큰 고민 없이 만들었는데 생각보다 맘에 든다.\r\n\r\nWhatSubs는 구독 관리에 도움을 주는 앱으로, 자신이 구독하는 항목을 쉽게 목록에 추가하고 그 목록을 한눈에 쉽게 확인해 구독을 관리하는데 도움을 줄 수 있는 앱이다.\r\n\r\n구독하는 서비스가 많아지다보니 어디서 어떤 결제수단으로 구독을 해 두었는지 까먹기도하고 확인하기에도 불편해서 한눈에 확인하고자 만든 앱이다. 또, 어디서든 쉽게 확인하려면 핸드폰이 낫겠다 싶어 이참에 React Native앱을 만들어보고자 제작하기 시작했다.\r\n\r\nUI/UX에 많은 시간을 들였고 개인적으로는 만족스럽게 결과를 만들어냈지만 내 기준으로 만들다보니 최신 갤럭시 노트와 최신 아이폰과 같이 화면비가 긴 화면에 적합하게 만들어져 UI/UX로 아쉬운 점이 남았다. 해상도와 화면비를 고려해서 컨텐츠의 크기를 수정하기도 했지만 여전히 아쉬운 점이 많다.\r\n\r\n---\r\n\r\n## P.S.\r\n\r\n지속적으로 운영을 할거라면 개발 외에도 내 앱을 소개하는 페이지에도 신경을 좀 더 써야하나 싶다. 홍보까진 아니더라도 말이다.  \r\n이번에 출시한 WhatSubs는 소개 페이지를 그나마 포토샵을 오랜만에 사용해 만들었다. 아무래도 앱스토어와 플레이스토어에 올라가다보니 조금은 신경을 썼다. 그에 비해 다른 웹앱인 크롬 확장 프로그램들은 구글 프레젠트에서 대강 만들어 올리다보니 조금은 부실해보이는데 나중에라도 더 신경을 써서 만들어야겠다는 생각이 든다.\r\n","excerpt":"이 글은 개발해서 운영하고 있는 서비스에 대한 잡담과 같은 후기이다. 현재까지 개발해서 지속적으로 운영하고 있는 결과물은 5개 정도이다. Blog Netflix AutoSkip Tablo Tablo (version 2) WhatSubs Blog…","fields":{"slug":"/dev-log-2019/"},"frontmatter":{"date":"Dec 29, 2019","title":"현재까지 개발한 결과물에 대한 이야기 2019","tags":["undefined"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nApp Store Connect에서 앱 정보를 입력하고 실제로 출시한다면  \r\nApp Store에서 입력한 항목들은 어디에 어떻게 위치하게 될 지 정리해보았습니다.\r\n\r\n아래는 App Store Connect에서 입력하고  \r\nApp Store에 직접적으로 표시될 내용들입니다.\r\n선택항목 및 표시되지 않는 항목은 제외한 목록입니다.\r\n\r\n- 이름\r\n- 부제\r\n- 등급\r\n- 앱 미리보기 및 스크린샷\r\n- 프로모션 텍스트\r\n- 설명\r\n- 아이콘\r\n- 카테고리\r\n- 지원 URL\r\n- 저작권\r\n- 개인정보 처리방침 URL\r\n\r\n## 검색 결과 화면\r\n\r\n앱 스토어 검색을 통해 해당 앱을 찾는다면 검색 결과 목록에서 표시되는 내용은 아래와 같습니다.  \r\n**아이콘**, **이름**, **부제** 그리고 **앱 미리보기 및 스크린샷**이 아래와 같이 나타납니다.\r\n\r\n![](DraggedImage.png)\r\n\r\n또한 부제의 경우 길이에 따라 줄임표로 내용이 생략될 수 있습니다.\r\n앱 미리보기 및 스크린샷의 경우 앱 미리보기가 우선이며 그 뒤로 스크린샷이 위치합니다.\r\n\r\n## 앱 상세 화면\r\n\r\n![](DraggedImage-1.png)\r\n상단에는 위와 같이 **아이콘**, **이름**, **부제**, **등급**, **앱 미리보기 및 스크린샷**이 위치합니다.\r\n\r\n![](DraggedImage-2.png)\r\n스크린샷 아래로는 우선 **프로모션 텍스트**가 위치하며 *더보기*를 누를 경우에 이어서 **설명**이 추가적으로 노출되게 됩니다.\r\n\r\n![](DraggedImage-3.png)\r\n하단에서는 리뷰 부분에 앱 지원을 누르게 되면 입력해둔 **지원 URL**의 주소로 이동합니다.  \r\n**카테고리**는 두개의 카테고리를 입력해두더라도 첫번째 카테고리만 표시되게 됩니다.  \r\n**등급**은 상단 화면의 연령에 이어서 다시 연령 등급이라는 항목으로 표시됩니다.  \r\n**저작권**은 입력해둔 저작권에 앞에 ©가 추가되어 표기됩니다.  \r\n개인정보 처리방침을 누르게 되면 입력한 **개인정보 처리방침 URL**로 이동합니다.\r\n\r\n(참고로 정보의 언어는 앱 스토어 커넥트에서 지정한 기본 언어가 나타나는 것이 아닙니다)\r\n\r\n## 추가 정보\r\n\r\n### 검색에 반영되는 항목\r\n\r\n- 이름\r\n- 부제\r\n- 태그\r\n  태그의 경우에는 심사에 영향을 미칠 수 있으니 주의해서 작성해야합니다.\r\n\r\n### 개인정보 처리방침 만들기\r\n\r\n개인정보 처리방침이 없으면 심사에 올릴 수 없습니다.\r\n[개인정보보호 종합포털](https://www.privacy.go.kr/ '개인정보보호 종합포털')의 개인정보처리방침 만들기 메뉴를 들어가서 절차에 따라 만들 수 있습니다. 절차에 따라 완성된 내용이더라도 추가적인 검토와 수정은 필수입니다.\r\n","excerpt":"App Store Connect에서 앱 정보를 입력하고 실제로 출시한다면 App Store에서 입력한 항목들은 어디에 어떻게 위치하게 될 지 정리해보았습니다. 아래는 App Store Connect에서 입력하고 App Store…","fields":{"slug":"/app-store-connect-form/"},"frontmatter":{"date":"Dec 06, 2019","title":"App Store Connect에 입력한 내용이 App Store에 어떻게 보일까?","tags":["undefined"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n![](a1.png)\r\n\r\n**[Google Play Store](https://play.google.com/store/apps/details?id=com.junhobaik.whatsubs)**  \r\n**[Apple App Store](https://apps.apple.com/kr/app/whatsubs/id1489637056)**\r\n\r\n---\r\n\r\nWhatSubs라는 iOS, Android 플랫폼의 React Native 앱을 최근에 만들게 되었습니다.\r\n지금은 두 플랫폼에서 모두 심사가 끝나고 출시가 되었습니다.\r\n아무래도 개인적인 필요에 의해 만들기 시작하였고 수요가 많은 앱이 될거라고 생각하진 않지만 이번에는 배포까지 전반적인 과정을 체험해보고자 이렇게 출시하게 되었습니다.\r\n\r\n앱을 간단히 소개하면 자신이 구독한 구독 서비스를 등록하고 리스트를 통해 확인할 수 있는 구독 관리에 도움을 주는 앱이라고 할 수 있습니다.\r\n\r\n다양한 구독 서비스를 사용하면서 구독 후 사용하지 않는데 깜박하고 해지를 안하거나, 결제 수단이 다양하다보니 각 결제 수단별로 구독한 항목을 확인하는데 어려움을 느껴 만들게 된 앱입니다.\r\n\r\n기존에는 웹과 크롬 확장 프로그램을 주로 개발해왔는데 이번에는 제대로 React Native앱을 만들어보고자 리액트 네이티브 문서를 보면서 기초부터 공부하며 만들게 되었습니다. 또 백엔드는 없는 독립형 앱을 만들고자 했습니다.\r\n\r\n### 리액트 네이티브\r\n\r\n리액트 네이티브를 사용하면서 어려웠던 점이나 느낀 점\r\n\r\n- 생각보다 React와 달리 제약이 많다  \r\n   Angular와 Vue보다 React를 선호하는 이유가 좀 더 자유롭다는 것이었습니다. 그런데 React Native는 다양한 플랫폼에서 동작하게 하려는 이유 등으로 이해는 가지만 생각보다 구현 할 방법에 제약이 있었습니다.\r\n- 노치, 펀치홀 대응  \r\n   노치와 펀치홀을 대응하는데 있어 쉽지가 않았습니다. 매끄러운 UI를 대응하기 위해서는 라이브러리 사용이 필요했고, 사용하더라도 완전히 android와 ios를 동시에 편하게 대응하기는 어려웠습니다.\r\n- 해상도 대응?  \r\n   다양한 기기, 다양한 화면비, 다양한 해상도가 있다보니 앱에서 표시되는 컨텐츠 내용의 양이 차이가 생겨 여기에 대응하는 것이 힘들었습니다. 처음에는 화면비로 대응을 했더니 화면비가 높으나 해상도가 낮은 기기로 좀 연식이 있는 기기와 같은 예외가 생겨 다시 해상도를 기준으로 컨텐츠의 크기를 조절해야했습니다. 이 부분에 대해서는 차후에도 디테일한 수정이 필요하다고 생각하고 있습니다.\r\n- Expo  \r\n   이번에는 Expo를 통해 개발하고, 번들링을 하게 되었는데 만약 Expo가 없으면 많이 불편하겠다는 생각을 했습니다. create-react-app 없이 개발할 수 있듯 React-Native도 그럴 수 있게 공부가 더 필요하겠다는 생각했습니다.\r\n- UI / UX  \r\n   RN에만 해당하는 것은 아니지만 모바일 앱으로 개발하면서 더욱 UI에 고민이 많았습니다. 게다가 한 화면에서 모든 정보를 보여주기를 원했기때문에 어떻게 할까 고민을 많이 했습니다. 지금의 화면에 만족하고는 있지만 본인이 화면비가 긴타입의 핸드폰을 사용하고 있고 본인을 기준으로 개발하다보니 저해상도의 예전 폰들에서는 내용이 덜 표시되는 문제는 뒤늦게 알게 되어 컨텐츠의 크기 등을 조절했지만 완전 만족스럽지는 못합니다.\r\n\r\n### 앱 출시\r\n\r\n앱 출시를 하면서 느낀 점\r\n\r\n- 저작권, 라이선스  \r\n   항상 개발을 하면서 저작권을 중요하게 생각했습니다. 다양한 회사와 서비스의 로고가 들어가다보니 저작권에는 문제가 없는지 알아보게 되었고, 알아보면서 다시 한번 저작권은 어렵다는 생각을 또 한번 했습니다. 그리고 이번에는 앱 출시에 있어서 앱 내부에 ‘오픈소스 라이선스’라는 것을 넣어서 앱 내에서 사용한 패키지, 라이브러리에 대한 라이선스 내용을 첨부했습니다.\r\n- 영어 공부를 해야겠다?  \r\n   개발하는데 있어 라이브러리 등등 도큐먼트에 가서 사용법을 익히는 정도는 괜찮았지만 출시에 있어 가이드 문서를 보는건 역시 힘들었습니다. 어서 영어 공부를 더 해야겠다는 생각이 들었습니다... 또한 다국어 처리를 하는데 있어서도 번역기로는 한계가 있었고 전에 만든 Tablo 웹앱은 다국어 처리를 했으나 일단은 이 WhatSubs앱은 한국을 대상으로 출시했고 차후에 다국어 처리가 가능하도록 개발을 진행했으니 나중에 몇가지만 더 구현하고 내용을 채우면 될 것 같습니다.\r\n- 개인정보  \r\n   앱스토어에서는 개인정보처리방침을 마련하지 않으면 앱을 올리지 못합니다. 일상 그냥 넘기던 그 긴 문서를 직접 만들어야한다니 막막했는데 개인정보처리방침을 쉽게 만들 수 있게 된 공공사이트가 있어 만들 수 있었습니다. 허나 지금 앱은 독립형앱이고 서버가 없어 따로 수집하는 개인정보가 없기 때문에 이렇게 쉬웠던 것이지 만약에 개인정보를 수집하는 앱이라면 더 알아봐야 할 것이 많고 작성하는데도 어려울뿐더러 개인정보처리방침을 따라 개인정보 처리를 하고 폐기를 하고 관리를 해야한다면 앱을 운영하는 것이 그리 쉽지만은 않겠다는 생각이 들었습니다.\r\n\r\n---\r\n\r\n- 아이폰의 왼쪽 사이드를 슬라이드하여 뒤로가기, 안드로이드폰의 뒤로가기 버튼(하드웨어, 소프트웨어)의 기능과 그에 따른 화면의 스택, 그리고 노치 영역을 고려한 View인 SafeAreaView를 사용하기 위해 사용한 모듈은 `react-native-gesture-handler`\r\n\r\n- 개인정보처리방침을 만들때 이용한 사이트는 [개인정보보호 종합포털](https://www.privacy.go.kr/ '개인정보보호 종합포털')이며 ‘개인정보처리방침 만들기’ 메뉴를 이용하면 된다.\r\n","excerpt":"Google Play Store Apple App Store WhatSubs라는 iOS, Android 플랫폼의 React Native…","fields":{"slug":"/whatsubs-dev-story/"},"frontmatter":{"date":"Dec 05, 2019","title":"WhatSubs 앱 개발기 (React-Native, Expo)","tags":["react-native"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nCSS 방법론은 스타일을 정의하는데 있어 엘리먼트의 class와 id를 어떻게 다루는지, 네이밍을 어떻게 하는지의 방법을 정의해 더 직관적인 스타일 코드를 작성하고 팀 단위의 개발을 원할하게 하는데 사용된다.  \r\n대표적으로는 BEM, OOCSS, SMASS가 있으며 여기서는 BEM에 대해 간단히 알아보겠다.\r\n\r\nBEM의 공식 가이드 홈페이지는 [https://en.bem.info](https://en.bem.info/ 'bem')로 영어와 러시아어가 지원된다.\r\n\r\n## BEM?\r\n\r\nBEM은 **Block**, **Element**, **Modifier** 세개 단어의 약자이다.  \r\n크게 세가지를 통해서 네이밍을 하게 된다.\r\n\r\nBEM은 기본적으로 id가 아닌 class만 사용하는 것을 지향하며, CSS tag도 쓰지 않는다.  \r\n세개(B,E,M)의 요소를 기준으로 클래스명을 작명하게 된다.\r\n\r\n```css\r\n.error #test { ... } ❌ id 사용\r\n.info h1 { ... } ❌ tag 사용\r\n\r\n.info__text { ... } 👍\r\n```\r\n\r\n## Block\r\n\r\nBlock을 기준으로 네이밍을 시작하게 되며 블록의 이름 뒤에 `__`로 연결하여 Element 이름을 작성하게 된다.\r\n\r\n블록은 **독립적으로 기능**하는 단위이다.\r\n\r\n```html\r\n<div class=\"big-text\" /> ❌\r\n\r\n<div class=\"error\" /> 👍\r\n```\r\n\r\n큰 텍스트(big-text)를 정의한 것은 텍스트라는 **목적** 또는 크다는 **모양**을 기술하였으므로 하나의 독립적 기능을 하는 단위라 볼 수 없다.  \r\n오류(error)라 정의한 것은 무엇을 하는가, **기능**. 즉 오류라는 기능을 수행한다는 독립적인 단위가 될 수 있다.\r\n\r\n블록에는 position, margin과 같이 외부적인 위치를 조정하는 스타일을 지정할 수 없다.\r\n\r\n**=\\> 독립성과 재사용성의 보장**  \r\n무엇을 하는지 정의하고 외부적인 위치를 조정하는 position, margin과 같은 스타일을 넣지 않으므로 블록이 움직이거나 다른 곳에서 이 블록을 또 사용하더라도 독립성을 유지할 수 있게 되는 것이다.\r\n\r\n블록은 중첩될 수 있으며, 여러 중첩을 거칠 수 있다.\r\n\r\n```html\r\n<!-- header 블록 -->\r\n<header class=\"header\">\r\n  <!-- 중첩된 logo 블록 -->\r\n  <div class=\"logo\" />\r\n  <!-- 중첩된 serch-from 블록 -->\r\n  <div class=\"search-form\" />\r\n</header>\r\n```\r\n\r\n## Element\r\n\r\nElement는 블록을 구성하는 단위로 블록과 분리될 수 없는 블록의 하위 요소이다.  \r\n따라서 블록 이름 없이 사용할 수 없으며,  \r\n블록 이름 뒤에 언더바 2개`__`로 연결하여 작성한다.\r\n\r\n엘리먼트는 위에서 예를 든 `big-text`를 통해서 살펴보면,  \r\nbig과 같은 모양을 나타내는 것은 옳지 않다.  \r\ntext와 같은 목적을 나타내는 것은 사용할 수 있다.\r\n\r\n```html\r\n<div class=\"search-form\">\r\n  <h1 class=\"search-from__big\"></h1> ❌ \r\n  <span class=\"search-from__text\"></span> 👍 \r\n  <input class=\"search-from__input\" /> 👍\r\n</div>\r\n```\r\n\r\n엘리먼트 또한 블록과 같이 중첩될 수 있으며, 여러 중첩을 거칠 수 있다.\r\n\r\n```html\r\n<form class=\"search-form\">\r\n  <div class=\"search-form__content\">\r\n    <input class=\"?\" /> 👈\r\n    <!--\r\n\t\t\t\"search-form__content__input\" ?\r\n\t\t\t\"search-form__input\" ?\r\n    -->\r\n  </div>\r\n</form>\r\n```\r\n\r\n위에서 input 태그를 보면 계층이 블록\\>엘리먼트\\>엘리먼트이다.\r\n그렇다고해서 Block `search_form`안의 Element `content`안의 `input`이라고 해서 `search-form__content__input`라고 네이밍을 하는 것은 옳지 않다.\r\n\r\n엘리먼트의 이름은 이어서 계층구조를 가지게 작성되어서는 안된다.  \r\n따라서 `search-form__input`으로 작성되어야 맞다.\r\n\r\n```css\r\n.block {\r\n}\r\n.block__elem1 {\r\n}\r\n.block__elem2 {\r\n}\r\n.block__elem3 {\r\n}\r\n```\r\n\r\n```html\r\n<div class=\"block\">\r\n  <div class=\"block__elem1\">\r\n    <div class=\"block__elem2\"></div>\r\n    <div class=\"block__elem3\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Change -->\r\n<div class=\"block\">\r\n  <div class=\"block__elem1\">\r\n    <div class=\"block__elem2\"></div>\r\n  </div>\r\n\r\n  <div class=\"block__elem3\"></div>\r\n</div>\r\n```\r\n\r\n이러한 구조를 따르면 위의 코드를 통해 알 수 있듯 블록의 구조가 변경되더라도 해당 엘리먼트들의 규칙을 유지할 수 있게 된다.\r\n\r\n여기까지 살펴보면 아래 코드를 보면 옳지 않다는 생각이 든다.\r\n\r\n```html\r\n<div class=\"search-form\">\r\n  <input class=\"input\" />\r\n  <button class=\"button\">Search</button>\r\n</div>\r\n```\r\n\r\n하지만 input, button을 엘리먼트가 아닌 하나하나의 블록으로 살펴 볼 수 있기 때문에 틀린 코드라고 할 수 없다. 따라서 꼭 블록 안에 엘리먼트가 있어야 하는 것은 아니라고 할 수 있다.\r\n\r\n## Modifier\r\n\r\nModifier는 블록이나 엘리먼트의 모양이나 상태, 또는 행동을 정의합니다.  \r\n블록, 엘리먼트 뒤에 하나의 언더바`_`로 이어 기술합니다.\r\n\r\n예를 들어 어떤 사이즈인지 `size_m`, 어떤 상태인지 `disabled` `focused`, 어떤 동작인지 `directions_left-top`를 적으면 된다.\r\n\r\n### Types of modifiers\r\n\r\n**Boolean**\r\n\r\n- `block-name_modifier-name`\r\n- `block-name__element-name_modifier-name`\r\n  위와 같은 패턴으로 작성하는 것으로,\r\n\r\n`focused`와 `disabled`와 같이 상태를 나타내는 것은 보통 boolean 값을 가질 것을 생각하는데 이럴때는 **true**라고 가정하고 작성하는 것을 원칙으로 한다.\r\n\r\n```html\r\n<form class=\"search-form search-form_focused\"></form>\r\n```\r\n\r\n`search-form_focused`의 `_focused` 부분이 true라고 가정, 포커스가 된 상태의 검색폼이라고 할 수 있다\r\n\r\n**Key-value**\r\n\r\n- `block-name_modifier-name_modifier-value`\r\n- `block-name__element-name_modifier-name_modifier-value`\r\n\r\n`테마: 아일랜드` 와 같이 키-벨류를 나타내는 듯한 이름을 말한다.\r\n\r\n```html\r\n<form class=\"search-form search-form_theme_islands\"></form>\r\n```\r\n\r\n`theme_islands`와 같이 키와 벨류를 하나의 언더바로 분리한 모양으로 작성하면 된다.\r\n\r\n## Mix\r\n\r\n```html\r\n<div class=\"header\">\r\n  <div class=\"search-form header__search-form\" />\r\n</div>\r\n```\r\n\r\n클래스를 나눠보면 아래와 같다.\r\n\r\n- `header` Block\r\n- `header__search-from` Element\r\n- `search-form` Block\r\n\r\n정리하면,\r\n\r\n`header` Block에 `search-from` Block의 스타일과 동작을 Mix해 header 블록의 search-from이라는 `header__search-from`을 만들었다.\r\n\r\n이는`header__search-from`를 이용해 `header`, `search-from` 각각의 Block의 독립성을 유지하면서 `search-form` 블록에 margin이나 position을 조정할 수 있게 된다.\r\n\r\n## File structure\r\n\r\nBEM 방법론은 파일 구조에도 쓰일 수 있다. 프로젝트 구조를 작성할 때 폴더, 파일명에 규칙을 적용해 아래와 같이 작성할 수도 있다.\r\n\r\n```\r\nsearch-form/ #Block\r\n\r\n    __input/ #Element\r\n        search-form__input.css\r\n        search-form__input.js\r\n\r\n    __button/ #Element\r\n        search-form__button.css\r\n        search-form__button.js\r\n\r\n    _theme/ #Modifier\r\n        search-form_theme_islands.css\r\n        search-form_theme_lite.css\r\n\r\n    search-form.css\r\n    search-form.js\r\n```\r\n\r\n파일 구조를 작성하기위한 규칙은 아래와 같다.\r\n\r\n- 하나의 Block은 하나의 디랙토리에 해당한다.\r\n- Block과 디렉토리의 이름은 동일해야한다.\r\n- Block의 구현은 별도의 파일로 나눈다. (`header.js`, `header.css`)\r\n- Block 디렉토리가 루트 디렉토리가 되며 아래에 해당 블록의 Element, Modifier 디렉토리가 있는다.\r\n- Element 디렉토리의 이름은 두개의 언더바 (`__`)로 시작한다 (`header/__logo/`, `menu/__item/`)\r\n- Modifier 디렉토리의 이름은 하나의 언더바 (`_`)로 시작한다.(`header/_fixed/`, `menu/_theme_islands/`)\r\n- Element와 Modifier의 구현은 별도의 파일로 나눈다. (`header__input.js`, `header_theme_islands.css`)\r\n\r\n---\r\n\r\n- References - [BEM Quick-start](https://en.bem.info/methodology/quick-start 'bem quick start')\r\n","excerpt":"CSS 방법론은 스타일을 정의하는데 있어 엘리먼트의 class와 id를 어떻게 다루는지, 네이밍을 어떻게 하는지의 방법을 정의해 더 직관적인 스타일 코드를 작성하고 팀 단위의 개발을 원할하게 하는데 사용된다. 대표적으로는 BEM, OOCSS…","fields":{"slug":"/css-bem/"},"frontmatter":{"date":"Nov 12, 2019","title":"CSS 방법론 - BEM","tags":["css"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n_해당 포스트는 macOS 환경을 기준으로 작성되었습니다_\r\n\r\n[**NVM**(Node Version Manager)](https://github.com/nvm-sh/nvm)\r\n\r\nNode 버전을 쉽게 관리 할 수 있다.\r\n예로 사용하던 패키지가 Node 버전이 업데이트를 함에 따라 호환이 되지 않을 경우가 생길 때 NVM없이 Node 버전을 되돌리기는 간단한 작업은 아니다. 이런 경우 NVM이 요긴하게 사용될 것이고 이 외에도 팀규모의 개발 등 많은 곳에서 Node 버전 관리가 필요할 수 있다.\r\n\r\n## 설치\r\n\r\n```bash\r\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash\r\n```\r\n> [NVM | Installation](https://github.com/nvm-sh/nvm#installation-and-update)\r\n\r\n## 사용\r\n\r\n현재 사용 가능한 Node Version List를 보여준다.\r\n```bash\r\n> nvm ls-remote\r\n```\r\n\r\n특정 버전의 Node를 설치합니다.\r\n```bash\r\n> nvm install <version>\r\n```\r\n\r\n또는 LTS Version으로 설치\r\n```bash\r\n> nvm install --lts\r\n```\r\n\r\n사용할 Node 버전 설정\r\n```bash\r\n> nvm use <version>\r\n```\r\n> 처음 설치한 Node 버전은 자동으로 사용하게 설정이 되어있습니다.\r\n\r\n이렇게 간단하게 버전을 설치하고 사용을 설정하면 됩니다.\r\n설치된 리스트를 확인해보면 아래와 유사한 출력을 볼 수 있습니다.\r\n\r\n```bash\r\n> nvm list\r\n       \r\n       v10.16.0\r\n->     v10.16.2\r\ndefault -> lts/* (-> v10.16.2)\r\nnode -> stable (-> v10.16.2) (default)\r\nstable -> 10.16 (-> v10.16.2) (default)\r\niojs -> N/A (default)\r\nunstable -> N/A (default)\r\nlts/* -> lts/dubnium (-> v10.16.2)\r\nlts/argon -> v4.9.1 (-> N/A)\r\nlts/boron -> v6.17.1 (-> N/A)\r\nlts/carbon -> v8.16.0 (-> N/A)\r\nlts/dubnium -> v10.16.2\r\n```\r\n\r\n설치되어있는 버전은 `10.16.0`과 `10.16.2`가 있고,\r\n현재 사용중인 버전이 `10.16.2`인 것을 확인 할 수 있습니다.\r\n\r\n만약 여기서 새로운 최신 LTS 버전의 Node가 나왔고 사용하자고 한다면 두가지 경우가 있을 것입니다.\r\n1. 새 LTS 버전을 설치하고 새로운 환경(설치된 패키지가 없는 깨끗한 상태)에서 사용을 시작하겠다.\r\n2. 새 LTS 버전을 설치하지만 기존에 사용하던 패키지는 그대로 가져가서 새로운 버전에 기존의 환경을 유지하고 싶다.\r\n\r\n\r\n1번의 경우에는 간단하게 버전을 설치하고 설치한 버전을 사용하기로 설정하면 됩니다.\r\n2번의 경우는 새 버전을 설치하고 기존의 패키지를 가져오는 과정이 필요합니다.\r\n아래서 설명하겠습니다.\r\n\r\n## 사용하던 Node Version을 업데이트하기\r\n\r\n이 경우는 새로운 버전으로 업데이트하지만 기존의 패키지는 가져옵니다.\r\n사용하던 환경(패키지) 그대로 사용하면서 버전만 업데이트하고 싶은 경우입니다.\r\n\r\n그때 사용하는 명령은 아래와 같습니다.\r\n```bash\r\n> nvm install <version> --reinstall-packages-from=<version>\r\n```\r\n\r\n예를 들면 아래와 같습니다.\r\n```bash\r\n> nvm install 11.11.1 --reinstall-packages-from=10.16.2\r\n```\r\n\r\n위 명령어를 통해 새로운 `11.11.1` 버전을 설치하고 기존에 사용하던 버전 `10.16.2`의 패키지를 설치할 Node 버전(`11.11.1`)에 reinstall하는 과정을 거치게 됩니다.\r\n\r\n---- \r\n\r\nReferences\r\n- [github | nvm-sh/nvm](https://github.com/nvm-sh/nvm)\r\n","excerpt":"해당 포스트는 macOS 환경을 기준으로 작성되었습니다 NVM(Node Version Manager) Node 버전을 쉽게 관리 할 수 있다.\n예로 사용하던 패키지가 Node 버전이 업데이트를 함에 따라 호환이 되지 않을 경우가 생길 때 NVM…","fields":{"slug":"/nvm-install/"},"frontmatter":{"date":"Aug 08, 2019","title":"NVM, Node 설치 및 관리하기","tags":["node","javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nMongoDB 문서를 참고해,\r\nCheatSheet 개념으로 정리해본 기초 Mongo Shell CRUD 명령어.\r\n\r\n이 포스트에서는 기초적인 것만 다루며 `writeConcern` Option, Evaluation Query 등은 다루지 않습니다.\r\n\r\n\r\n## Database\r\n\r\n### Database 목록\r\n```bash\r\n> show databases\r\n```\r\n\r\n### Database 선택\r\n```bash\r\n> use db_name\r\n```\r\n> 존재하지 않는 DB 선택 시, 이후 DB 삽입등이 이루어지면 자동으로 생성된다.\r\n\r\n### Database 제거\r\n```bash\r\n> db.dropDatabase()\r\n```\r\n> 현재 선택되어있는 Database를 제거한다.\r\n\r\n\r\n\r\n## Collection\r\n\r\n### Collection 생성\r\n[`db.createCollection(name, [options])`](https://docs.mongodb.com/manual/reference/method/db.createCollection/index.html)\r\n```bash\r\n> db.createCollection(collection_name)\r\n```\r\n> 일반적으로 insert시 지정한 collection이 없는 콜렉션이면 자동으로 생성되므로 따로 Collection을 생성할 필요는 없지만 options를 활용하기 위해서는 createCollection을 사용한다.\r\n\r\n### Collection 제거\r\n```bash\r\n> db.collection_name.drop()\r\n```\r\n\r\n### Collection 이름 변경\r\n[`db.collection.renameCollection(target, [dropTarget])`](https://docs.mongodb.com/manual/reference/method/db.collection.renameCollection/)\r\n```bash\r\ndb.rrecord.renameCollection(\"record\")\r\n```\r\n\r\n\r\n\r\n## Insert\r\n\r\n### 하나의 Document 삽입\r\n[`db.collection.insertOne(document, [options])`](https://docs.mongodb.com/manual/reference/method/db.collection.insertOne/#db.collection.insertOne)\r\n```bash\r\n> db.collection_name.insertOne(\r\n  { name: \"Jhon\", age: 24 }\r\n)\r\n```\r\n\r\n### 여러 Document 삽입\r\n[`db.collection.insertMany(Array of documents, [options])`](https://docs.mongodb.com/manual/reference/method/db.collection.insertMany/#db.collection.insertMany)\r\n```bash\r\n> db.collection_name.insertMany(\r\n  [\r\n    { name: \"Jhon\", age: 24 },\r\n    { name: \"Darcy\", age: 26 },\r\n    { name: \"Ted\", age: 22 }\r\n  ]\r\n)\r\n```\r\n\r\n**ordered**: (boolean/default:true) Document를 기술한 순서대로 삽입\r\n```bash\r\n> db.collection_name.insertMany(\r\n  [\r\n    { name: \"Jhon\", age: 24 },\r\n    { name: \"Darcy\", age: 26 },\r\n    { name: \"Ted\", age: 22 }\r\n  ],\r\n  { ordered: true }\r\n)\r\n```\r\n\r\n\r\n\r\n\r\n## Query (find)\r\n\r\nuser Collection의 모든 Document 선택\r\n```bash\r\n> db.user.find()\r\n```\r\n\r\n**pretty()**: 결과를 읽기 좋은 형식으로 보여줌\r\n```bash\r\n> db.user.find().pretty()\r\n```\r\n\r\nCollection에서 name 필드의 값이 ‘Jhon’인 Dcoument 선택\r\n```bash\r\n> db.user.find({ name: \"Jhon\" })\r\n```\r\n\r\n### [비교 연산자](https://docs.mongodb.com/manual/reference/operator/query-comparison/#query-selectors-comparison) \r\n- $eq: 지정한 값과 같은\r\n- $gt: 지정한 값보다 큰\r\n- $gte: 지정한 값보다 크거나 같은\r\n- $in: 지정한 배열 안에 속하는\r\n- $lt: 지정한 값보다 작은\r\n- $lte: 지정한 값보다 작거나 같은\r\n- $ne: 지정한 값과 같지 않은\r\n- $nin: 지정한 배열 안에 속하지 않는\r\n\r\nCollection에서 level 필드의 값이 3이상인 Document 선택\r\n```bash\r\ndb.user.find(\r\n  {\r\n    level: { $gte: 3 }\r\n  }\r\n)\r\n```\r\n\r\nCollection에서 level 필드의 값이 2 또는 5 인 Document 선택\r\n```bash\r\n> db.user.find(\r\n  {\r\n    level: { $in: [2, 5] }\r\n  }\r\n)\r\n```\r\n\r\n\r\n### 논리 연산자\r\n- $or\r\n- $and\r\n- $not : 지정 조건이 false면 true, true이면 false\r\n- $nor : 모든 지정 조건이 false면 true\r\n\r\nCollection에서 status가 ‘A’이고 qty가 30 이상인 Document 선택\r\n```bash\r\n> db.inventory.find( \r\n  {\r\n    $and: [\r\n      { status: \"A\" },\r\n      { qty: { $lt: 30 } }\r\n    ]\r\n  }\r\n)\r\n\r\n> db.inventory.find( \r\n  { \r\n    status: \"A\", \r\n    qty: { $lt: 30 } \r\n  } \r\n)\r\n```\r\n> 위의 두 명령은 동일한 명령이라 할 수 있다.\r\n\r\nCollection에서 status가 ‘A’이거나 qty가 30 이상인 Document 선택\r\n```bash\r\ndb.inventory.find( { $or: [ { status: \"A\" }, { qty: { $lt: 30 } } ] } )\r\n```\r\n\r\n$and와 $or의 혼합 사용\r\n```bash\r\ndb.inventory.find( {\r\n     status: \"A\",\r\n     $or: [ { qty: { $lt: 30 } }, { item: /^p/ } ]\r\n} )\r\n```\r\n\r\n### Match an Embedded/Nested Document\r\n\r\n`comments: { author: \"Jhon\", comment: \"Good!\" }`를 완전히 일치 시킨 선택 명령\r\n```bash\r\ndb.users.find(\r\n  { comments: { author: \"Jhon\", comment: \"Good!\" } }\r\n)\r\n```\r\n> comments: { comment: \"Good!\" , author: \"Jhon\", } 를 선택할 시 순서가 달라 정확히 일치하지 않기 때문에 결과가 나오지 않습니다.\r\n\r\n### Query on Nested Field\r\n\r\n`{ size: { w: 20, h: 40 } }`와 같은 형식의 Document들이 있을 때 size 필드 안의 h 가 15 이상인 도큐먼트 선택\r\n```bash\r\ndb.inventory.find( { \"size.h\": { $lt: 15 } } )\r\n```\r\n\r\n### Query an Array\r\n\r\n#### Match an Array\r\ntags가 `[\"red\", \"blank\"]`로 요소와 순서 모두가 정확히 일치하는 Document 선택\r\n```bash\r\ndb.inventory.find( { tags: [\"red\", \"blank\"] } )\r\n```\r\n\r\ntag안에 red가 있는 document 선택\r\n```bash\r\ndb.inventory.find( { tags: \"red\" } )\r\n```\r\n\r\n#### $all\r\ntags가 ‘red’, ‘blank’ 두가지를 가지고 있는 Dcouments\r\n```bash\r\ndb.inventory.find( { tags: { $all: [\"red\", \"blank\"] } } )\r\n```\r\n> 순서와 상관없고, 정확히 일치하는게 아닌 포함하고 있으면 된다.\r\n\r\n#### $elemMatch\r\n`dim_cm: [12, 16]`와 같은 형식이 있다.\r\n`dim_cm` 배열 안에 22초과, 30미만의 값을 포함하고 있는 Document를 선택\r\n```bash\r\ndb.inventory.find( { dim_cm: { $elemMatch: { $gt: 22, $lt: 30 } } } )\r\n```\r\n\r\n#### Query for an Element by the Array Index Position\r\n`dim_cm` 배열의 1번째 index 요소가 25 초과인 Document 선택\r\n```bash\r\ndb.inventory.find( { \"dim_cm.1\": { $gt: 25 } } )\r\n```\r\n\r\n#### Query an Array by Array Length\r\ntags 배열의 길이가 3인 Document 선택\r\n```bash\r\ndb.inventory.find( { \"tags\": { $size: 3 } } )\r\n```\r\n\r\n### Query for Null or Missing Fields\r\n`{ _id: 1, item: null }, { _id: 2 }` 두개의 Document가 있다.\r\n아래는 item이 null인 document를 선택한다.\r\n```bash\r\ndb.inventory.find( { item: null } )\r\n```\r\n> { _id: 2 }도 item:null 이기 떄문에 두개의 Document가 모두 선택된다._\r\n아래와 같이 하면 첫번째 document만 정상적으로 선택할 수 있다.\r\n```bash\r\ndb.inventory.find( { item : { $type: 10 } } )\r\n```\r\n> [BSON types](https://docs.mongodb.com/manual/reference/bson-types/)\r\nitem이 존재하지 않는 Document를 선택한다.\r\n```bash\r\ndb.inventory.find( { item : { $exists: false } } )\r\n```\r\n\r\n\r\n\r\n## Update\r\n\r\n### [db.collection.updateOne(filter, update, options)](https://docs.mongodb.com/manual/reference/method/db.collection.updateOne/#db.collection.updateOne)\r\n`{ name: \"Jhon\", age: 29 }`에서 age를 25로 변경\r\n```bash\r\ndb.user.updateOne(\r\n  { name: \"Jhon\" },\r\n  { $set: { age: 25 } }\r\n)\r\n```\r\n\r\noptions의 upsert 속성을 사용하면 만약 Kay가 존재하지 않을 시 Document를 새로 만들며 업데이트 된다.\r\n```bash\r\n> db.user.updateOne(\r\n  {name:\"Kay\"},\r\n  { $set: { age: 25 } },\r\n  {upsert: true}\r\n)\r\n```\r\n\r\n배열 field에 값 추가하기 (`skills: []`)\r\n```bash\r\n> db.user.updateOne(\r\n  {name:\"Jhon\"},\r\n  {$push: {skills: 'react'}}\r\n)\r\n```\r\n\r\n배열 field에 값 추가하기 + 정렬\r\n```bash\r\n# 여러개 추가 시 $each 사용\r\n# 알파벳순으로 정렬시 $sort 사용\r\n\r\n> db.user.updateOne(\r\n  {name:\"Jhon\"},\r\n  {$push: \r\n    skills: {\r\n      $each: ['vue', 'angular'],\r\n      $sort: 1\r\n    }\r\n  }\r\n)\r\n```\r\n\r\n배열 field에 값 제거하기\r\n```bash\r\n> db.user.updateOne(\r\n  {name:\"Jhon\"},\r\n  {$pull: {skills: 'react'}}\r\n)\r\n```\r\n\r\n배열 field에서 여러값 제거하기\r\n```bash\r\n> db.user.updateOne(\r\n  {name:\"Jhon\"},\r\n  {$pull: {skills: $in: ['angular', 'vue']}}\r\n)\r\n```\r\n\r\n\r\n### [db.collection.updateMany(filter, update, options)](https://docs.mongodb.com/manual/reference/method/db.collection.updateMany/#db.collection.updateMany)\r\nlevel이 3이상인 document의 admin을 true로 변경\r\n```bash\r\ndb.user.updateMany(\r\n  { level: {$gte: 3} },\r\n  { $set: {admin: true} }\r\n)\r\n```\r\n\r\n### [db.collection.replaceOne(filter, replacement, options)](https://docs.mongodb.com/manual/reference/method/db.collection.replaceOne/#db.collection.replaceOne)\r\nname:”Kay”인 Document를 `{name:\"Kai\", age: 21}`로 교체한다.\r\n```bash\r\n> db.user.replaceOne(\r\n  {name:\"Kay\"},\r\n  {name:\"Kai\", age: 21}\r\n)\r\n```\r\n> 교체, 업데이트 후에도 도큐먼트의 ID는 유지된다.\r\n\r\n### [db.collection.update(query, update, options)](https://docs.mongodb.com/manual/reference/method/db.collection.update/#db.collection.update)\r\ndocumnet를 replace 하기\r\n```bash\r\n# 이름이 Jhon인 도큐먼트를 name Jun, age 21으로 교체\r\n\r\n> db.user.update(\r\n  {name:\"Jhon\"}, {name: \"Jun\", age: 21}\r\n)\r\n```\r\n\r\n여러 Document Update, options의 multi 속성이 필요하다, 또는 insertMany를 사용하는 방법도 있다.\r\n```bash\r\n> db.user.update(\r\n  {level: {$lte:3}},\r\n  {$set: {admin: false}},\r\n  {multi: true}\r\n)\r\n```\r\n\r\n\r\n\r\n## Delete\r\n\r\ninventory Collection안의 모든 Document가 삭제된다.\r\n```bash\r\ndb.inventory.deleteMany({})\r\n```\r\n\r\nCollection안의 status가 A인 Dcoument가 모두 삭제된다.\r\n```bash\r\ndb.inventory.deleteMany({ status : \"A\" })\r\n```\r\n\r\nCollection안의 status가 D인 Dcoument가 하나 삭제된다.\r\n```bash\r\ndb.inventory.deleteOne( { status: \"D\" } )\r\n```\r\n\r\n\r\n---- \r\n\r\nReferences\r\n- [MongoDB | Documentation](https://docs.mongodb.com/manual/)\r\n","excerpt":"MongoDB 문서를 참고해,\nCheatSheet 개념으로 정리해본 기초 Mongo Shell CRUD 명령어. 이 포스트에서는 기초적인 것만 다루며  Option, Evaluation Query 등은 다루지 않습니다. Database Database…","fields":{"slug":"/mongodb-basic-crud/"},"frontmatter":{"date":"Jul 30, 2019","title":"MongoDB 기초, CRUD 명령어","tags":["mongodb"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n![](screenshot.png)\r\n\r\n개발환경 구성에 앞서 제일 먼저 필요하다고 할 수 있는 터미널 환경 세팅.\r\n\r\n여기서는 **zsh** 쉘을 사용하며, **oh my zsh** 설치 후  \r\nzsh 플러그인 매니저인 **zplug**를 설치하여 플러그인을 관리합니다.  \r\n또한 터미널 앱으로는 **hyper**를 사용합니다.\r\n\r\nmacOS를 처음 설치해 깨끗한 상태에서 환경을 구성하는 과정으로 Brew 설치부터 시작하게 됩니다.\r\n\r\nHomeBrew가 설치되어있다면 Brew 설치 부분은 건너뛰면 됩니다.  \r\n또한 mac Catalina를 사용중이라면 zsh 설치 및 설정 부분은 건너뛰면 됩니다.\r\n\r\n> catalina 버전부터는 기본 쉘이 zsh로 설정되어 있어 설치 및 설정이 불필요\r\n\r\n## Brew 설치\r\n\r\nBrew 설치에 앞서 xcode command line tools의 설치가 필요합니다.\r\n\r\n_Xcode command line tools 설치_\r\n\r\n```bash\r\nxcode-select --install\r\n```\r\n\r\n_HomeBrew 설치_\r\n\r\n```bash\r\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\r\n```\r\n\r\n_zsh 설치_\r\n\r\n```bash\r\nbrew install zsh\r\n```\r\n\r\n_oh-my-zsh 설치_\r\n\r\n```bash\r\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\r\n```\r\n\r\n_기본 쉘 변경 (bash -\\> zsh)_\r\n\r\n```bash\r\nchsh -s `which zsh`\r\n```\r\n\r\n> non-standard shell 오류 발생 시\r\n> /etc/shells 파일에 `which zsh`를 통해서 확인한 경로를 최하단에 추가합니다.\r\n> 위 명령어를 다시 실행한 후 재부팅을 합니다.\r\n\r\n여기까지 했다면 터미널을 실행하면 zsh 쉘로 실행되는 것을 확인 할 수 있습니다.\r\n\r\n## zplug 설치 및 설정\r\n\r\n[https://github.com/zplug/zplug](https://github.com/zplug/zplug)\r\n\r\nzplug는 zsh 플러그인을 쉽게 설치 및 관리 할 수 있는 플러그인 매니저입니다.\r\n\r\n### zplug 설치\r\n\r\n```bash\r\n$ curl -sL --proto-redir -all,https https://raw.githubusercontent.com/zplug/installer/master/installer.zsh | zsh`\r\n```\r\n\r\n또는 `$ brew install zplug` 로 설치가 가능합니다.\r\n\r\n### zplug 설정\r\n\r\n`.zshrc` 파일을 수정합니다.\r\nvi, open, code 등 맘에 드는 방법으로 수정하시면 됩니다.\r\n\r\n```bash\r\nvi ~/.zshrc\r\n```\r\n\r\n`.zshrc` 파일의 내용을 전부 지우고, 아래 내용으로 대체합니다.\r\n\r\n```bash\r\n# .zshrc (use zplug)\r\n\r\nsource ~/.zplug/init.zsh\r\n\r\n# Plugins\r\nzplug \"plugins/git\",   from:oh-my-zsh\r\nzplug \"lib/completion\",   from:oh-my-zsh\r\nzplug 'lib/key-bindings', from:oh-my-zsh\r\nzplug \"lib/directories\",  from:oh-my-zsh\r\n\r\nzplug \"zsh-users/zsh-syntax-highlighting\"\r\nzplug \"zsh-users/zsh-autosuggestions\"\r\n\r\nzplug 'dracula/zsh', as:theme\r\n\r\n# Install plugins if there are plugins that have not been installed\r\nif ! zplug check --verbose; then\r\n    printf \"Install? [y/N]: \"\r\n    if read -q; then\r\n        echo; zplug install\r\n    fi\r\nfi\r\n\r\n# Then, source plugins and add commands to $PATH\r\nzplug load\r\n```\r\n\r\n기본적인 oh-my-zsh의 플러그인과,\r\n`zsh-syntax-highlighting`, `zsh-autosuggestions` 플러그인이 포함된 내용입니다.\r\n또한 테마는 `dracula` 를 사용하고 있습니다.\r\n\r\n기본적인 사용 방법은 아래서 설명할 것이고,\r\n자세한 설정 방법은 [공식 문서](https://github.com/zplug/zplug)를 참고하시기 바라며,\r\n아래는 본인이 사용하는 Plugin 작성 내용입니다.\r\n\r\n```bash\r\n...\r\n\r\n# Plugins\r\nzplug \"lib/completion\",   from:oh-my-zsh\r\nzplug \"lib/key-bindings\", from:oh-my-zsh\r\nzplug \"lib/directories\",  from:oh-my-zsh\r\n\r\nzplug \"plugins/git\",      from:oh-my-zsh\r\nzplug \"plugins/autojump\", from:oh-my-zsh, frozen:1\r\n\r\nzplug \"zsh-users/zsh-completions\",              defer:0\r\nzplug \"zsh-users/zsh-autosuggestions\",          defer:1, on:\"zsh-users/zsh-completions\"\r\nzplug \"zsh-users/zsh-syntax-highlighting\",      defer:1, on:\"zsh-users/zsh-autosuggestions\"\r\nzplug \"zsh-users/zsh-history-substring-search\", defer:2, on:\"zsh-users/zsh-syntax-highlighting\"\r\n\r\nzplug \"denysdovhan/spaceship-prompt\", use:spaceship.zsh, from:github, as:theme\r\n\r\nzplug \"djui/alias-tips\"\r\n\r\n...\r\n```\r\n\r\n위에서 autojump 플러그인 사용을 위해서는 아래와 같이 설치가 필요합니다.\r\n\r\n```bash\r\n$ brew install autojump\r\n```\r\n\r\n또한 위에서 spaceship-prompt 테마를 사용하기 위해서는 powerline font 설치가 필요합니다.\r\n\r\n다양한 zsh 플러그인은 [awesome-zsh-plugin](https://github.com/unixorn/awesome-zsh-plugins) 문서에서 확인 할 수 있습니다.\r\n\r\n### zplug 사용법\r\n\r\n#### 플러그인 추가\r\n\r\n기본적으로는 `.zshrc`를 수정하여 사용하는 것을 권장합니다.\r\n\r\n`zplug \"djui/alias-tips\"`와 같이\r\n`zplug \"[username]/[repository name]\"`의 형식으로 쉽게 플러그인을 추가할 수 있습니다.\r\n\r\n```\r\nzplug \"[username]/[repository name]\", [tag]:[value]\r\n```\r\n\r\n또한 위와 같이 태그를 추가할 수 있습니다.\r\n\r\n위에서 테마를 아래와 같이 표시한 것을 보면 알 수 있습니다.\r\n\r\n```\r\nzplug 'dracula/zsh', as:theme\r\n```\r\n\r\n[공식 문서](https://github.com/zplug/zplug)에 설명과 다양한 예가 있으니 참고하시기 바랍니다.\r\n\r\n`.zshrc`를 수정하는 방식이 아닌 zplug의 명령어로만 제어하는 방법이 있습니다.\r\n터미널에서 아래 명령어(위에서 설명한 방식의 문구와 동일합니다)를 실행하면\r\n\r\n```bash\r\n$ zplug \"djui/alias-tips\"\r\n```\r\n\r\n플러그인이 자동으로 추가가 됩니다.\r\n\r\n이렇게 추가된 플러그인은 `.zshrc`가 아닌 `~/.zplug/packages.zsh` 에 기록되어 있습니다.\r\n따로 확인하는 것이 어려우니 `.zshrc` 에서만 작업하는 것을 추천합니다.\r\n\r\n#### zplug 명령어\r\n\r\n[공식 문서 | Commands for zplug](https://github.com/zplug/zplug#2-commands-for-zplug)\r\n\r\n기본적으로 추가한 플러그인이 설치되어 있지 않다면 터미널 시작시 설치할 것을 묻습니다.\r\n그런데 명령어를 이용해 추가한 경우에는 아래 명령어를 통해 설치를 할 수 있습니다.\r\n\r\n```bash\r\n$ zplug install\r\n```\r\n\r\n방금 설치한 플러그인을 터미널 재실행 없이 반영하려면 아래 명령어를 사용합니다.\r\n`--verbose` 옵션을 추가하면 자세한 내역이 출력됩니다.\r\n\r\n```bash\r\n$ zplug load\r\nor\r\n$ zplug load --verbose\r\n```\r\n\r\n플러그인 업데이트: `zplug update`\r\n플러그인 리스트 출력: `zplug list`\r\n\r\n그 외 명령어는 공식 문서를 참고하시기 바랍니다.\r\n\r\n## Hyper\r\n\r\n[공식 사이트](https://hyper.is/)\r\n\r\nHyper는 iTerm 보다 성능면에서는 떨어질 수 있으나 디자인면에서는 뛰어나며, Electron으로 Javascript, css, html을 기반으로 개발된 오픈소스 터미널 앱입니다.\r\n\r\n### 설치\r\n\r\n공식 사이트에서 [다운로드](https://hyper.is/#installation)하거나 brew를 이용해 설치합니다\r\n\r\n```bash\r\n$ brew cask install hyper\r\n```\r\n\r\n### 설정 및 플러그인\r\n\r\n`~/.hyper.js` 파일을 수정하여 설정 및 플러그인 추가를 할 수 있습니다.\r\n폰트, 스타일 및 기타 설정 그리고 플러그인을 관리합니다.\r\n\r\n아래는 본인이 사용중인 플러그인 목록입니다.\r\n\r\n```\r\nmodule.exports = {\r\n  config: {\r\n  opacity: 0.95,\r\n\r\n  fontFamily: 'Hack, Menlo, \"DejaVu Sans Mono\", \"DejaVu Sans Mono for Powerline\", Consolas, \"Lucida Console\", monospace',\r\n\r\n  // ...\r\n\r\n  plugins: [\r\n    `hypercwd`,\r\n    `hyper-search`,\r\n    // `hyper-statusline`,\r\n    `hyper-quit`,\r\n    `hyper-opacity`,\r\n    `hyper-tab-icons`,\r\n    `hyper-materialshell`\r\n  ],\r\n\r\n// ...\r\n```\r\n\r\n위 설정을 그대로 사용할 경우 미리 'Hack', 'Powerline' 폰트 설치가 필요합니다.\r\n\r\n다양한 플러그인은 [awesome-hyper](https://github.com/bnb/awesome-hyper) 문서에서 확인할 수 있습니다.\r\n\r\n여기까지 본인과 같은 설정을 했다면 최상단의 이미지와 같은 터미널을 보실 수 있습니다.\r\n","excerpt":"개발환경 구성에 앞서 제일 먼저 필요하다고 할 수 있는 터미널 환경 세팅. 여기서는 zsh 쉘을 사용하며, oh my zsh 설치 후 zsh 플러그인 매니저인 zplug를 설치하여 플러그인을 관리합니다. 또한 터미널 앱으로는 hyper…","fields":{"slug":"/mac-terminal-setting/"},"frontmatter":{"date":"Jul 24, 2019","title":"mac 터미널 환경 구성하기 (zsh, oh my zsh, zplug, hyper)","tags":["mac"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nMongoDB를 본격적으로 사용하기 앞서,\r\n설치와 실행 그리고 추가적인 툴의 설치와 사용까지 기본적으로 알아보겠습니다.\r\n\r\nmacOS / HomeBrew의 설치 환경에서 진행됩니다.\r\n\r\n## Install MongoDB\r\n\r\nTap the MongoDB Homebrew Tap\r\n```bash\r\n$ brew tap mongodb/brew\r\n```\r\n\r\nInstall MongoDB\r\n```bash\r\n$ brew install mongodb-community@4.0\r\n```\r\n\r\nRun MongoDB\r\n```bash\r\n$ mongod --config /usr/local/etc/mongod.conf\r\n\r\n$ brew services start mongodb-community@4.0\r\n```\r\n\r\n> `brew services start mongodb-community@4.0`의 과정을 거치지 않는다면 mongo shell을 이용하기 전 `mongod`명령을 통해 mongo 서버를 키는 과정이 필요하다.\r\n\r\nConnect and Use MongoDB\r\n```bash\r\n$ mongo\r\n```\r\n\r\n## 설치 없이 실습하기\r\n\r\n[https://mws.mongodb.com/](https://mws.mongodb.com/)\r\n\r\n위 주소로 접속하여 스터디 용도로 MongoDB 가상환경 내에서 사용해 볼 수 있다.\r\nreset 버튼을 누르거나 오랜 시간 작업이 없거나, 웹페이지를 새로고침하면 데이터가 날아가니 주의할 것.\r\n","excerpt":"MongoDB를 본격적으로 사용하기 앞서,\n설치와 실행 그리고 추가적인 툴의 설치와 사용까지 기본적으로 알아보겠습니다. macOS / HomeBrew의 설치 환경에서 진행됩니다. Install MongoDB Tap the MongoDB Homebrew…","fields":{"slug":"/mongodb-install/"},"frontmatter":{"date":"Jul 20, 2019","title":"MongoDB 설치하기 (mac, homebrew)","tags":["mongodb"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n현재 mac Catalina developer beta의 환경으로 사용하고 있었는데,\r\n\r\n지금까지 설치한 앱들이 너무 많고 메뉴바 또한 넘처나기 직전이다.  \r\nbartender, dozer와 같은 메뉴바 정리 앱으로 정리를 했는데도 말이다.\r\n\r\n그래서 macOS를 Catalina public beta로 클린 설치하여 다시 한번 앱들을 설치하며 새로운 환경을 구성할 예정이다.\r\n\r\n그 전에 사용하던 앱들을 한번 정리해보고,  \r\n이를 바탕으로 클린 설치로 os를 설치하고 필요한 앱만 다시 설치하고 그렇지 않은 앱은 설치하지 않고 필요할 떄만 찾아 설치할 예정이다.  \r\n\r\n**필수 설치 Apps**는 고민 없이 바로 설치할 앱들이고,  \r\n**그 외 Apps**는 일단 설치하지 않고 사용하다 필요하면 설치할 앱들이다.\r\n\r\n:credit_card:는 유료앱을 나타내며  \r\n:small_blue_diamond:는 유료앱이며, SetApp에서 사용가능한 앱을 나타낸다.  \r\n(본인은 구독형 앱스토어라고 할 수 있는 SetApp이라는 서비스를 구독하고 있다. 구독하고 있으면 SetApp에 있는 앱들은 모두 무료로 받을 수 있다)\r\n\r\n## 필수 설치 Apps\r\n\r\n### CurserSense :credit_card:  \r\n\r\n  Apple Magic Mouse를 사용중이라면 필수 설치 앱  \r\n  워낙 느린 매직 마우스의 속도를 증가시킨다, 단순 증가가 아니라 가속도에 따른 조절 등\r\n  아주 디테일한 수정이 가능하다.\r\n\r\n### BetterTouchTool :small_blue_diamond:\r\n\r\n  터치바, 매직마우스, 트랙패드에 있어 다양한 제스처 및 동작을 특정 동작에 대입시킬 수 있는 앱이다. 워낙 많은 기능이 들어가있어 다 활용하기 어려울 정도이다.  \r\n  본인은 주로 매직마우스의 터치 제스처로 우클릭을 하거나, 키보드 + 제스처 조합으로 윈도우의 크기 및 배치를 조절하는 등의 기능을 사용하고 있다.\r\n\r\n### Alfred 4 \r\n\r\n  맥의 기본 Spotlight를 대체하는 앱  \r\n  웹, 파일, 폴더 검색 및 시스템 제어, 워크플로우 등 생산성에 많은 도움이 된다.  \r\n  워크플로우 등 풀버전 사용에는 라이센스 구입이 필요하다.\r\n\r\n### Amphetamine\r\n\r\n  맥이 잠들기 모드에 들어가지 않고 계속 꺠어있게 하는 앱이다.  \r\n  이러한 기능을 가진 다양한 앱들이 있지만 여러 앱을 사용해본 결과 디자인이나 기능 등 모든 면에서 사용성이 최고다.\r\n\r\n### Apple Apps\r\n  - Pages\r\n  - Keynotes\r\n  - Numbers\r\n  - Xcode\r\n\r\n### 한컴오피스 한글 뷰어\r\n\r\n### BusyCal :small_blue_diamond:\r\n\r\n  일정 관리 캘린더 앱, 기본 앱보다 사용하기 편리해서 사용하고 있다.\r\n\r\n### Bartender :small_blue_diamond:\r\n\r\n  메뉴바 정리 앱, 아이콘을 눌러 원하는 목록으로 펼치고 필 수 있으며 맥에 기본으로 있는 아이콘 또한 숨길 수 있다.\r\n\r\n### Canary Mail :small_blue_diamond:\r\n\r\n  메일 앱, 기본 앱보다 기능이 많고 편리하며 보기도 좋아 사용하고 있다.\r\n\r\n### Chrome\r\n\r\n### CleanMyMac :small_blue_diamond:\r\n\r\n  시스템 청소 앱이라 보면 되는데, 맥에서 굳이 필요할까 싶지만 숨겨진 용량이 큰 파일을 정리할때나 또는 런치패드 spotlight 캐시 정리 및 오류 해결 등에 사용할 일이 있어 사용하고 있다.\r\n\r\n### Dozer\r\n\r\n  메뉴바 정리 앱, 점 두개를 이용하여 왼쪽 점의 좌측에 위치한 앱들은 오른쪽 점 클릭을 통해 숨길 수 있다.  \r\n  본인은 Dozer와 Bartender 두 앱을 이용해 메뉴바 정리를 하고 있다.\r\n\r\n### Endurance :small_blue_diamond:\r\n\r\n  절전 모드 앱이라고 보면 된다. 절전 모드를 켜면 스크린 밝기나 백그라운드 앱 숨기기, 프로세스 속도 낮추기 등 기능이 작동하도록 설정해 배터리 절약에 도움이 된다. 배터리 30% 이하시 자동 절전 모드로 사용하고 있다.\r\n\r\n### firefox Developer Edition\r\n\r\n  개발자를 위한 파이어폭스 브라우저, 개발자 툴이 잘되어있다. 또 부가적으로 개발을 위한 다양한 기능을 제공한다.\r\n\r\n### keka\r\n\r\n  압축 앱\r\n\r\n### GPG Suite\r\n\r\n  gpg key 관리 프로그램\r\n\r\n### iStat Menus :small_blue_diamond:\r\n\r\n  메뉴바 관련 앱, 메뉴바에 배터리, 날씨, CPU, RAM 등 다양한 정보를 아이콘으로 띄울 수 있다.  \r\n  특히 본인의 경우 매직 마우스나, 매직 키보드, 에어팟을 연결하면 메뉴바에 각각의 배터리를 확인 할 수 있게 할 수 있어 유용하게 사용중이다.\r\n\r\n### MindNode\r\n\r\n  mindmap 작성 앱, xmind와 고민을 했는데 mindnode가 훨신 보기 좋아 선택하게 되었다.\r\n\r\n### NightOwl\r\n\r\n  mac의 darkmode, lightmode를 원하는 시간에 자동으로 변경시켜준다.  \r\n  mac Catalina에서는 auto가 생김에 따라 필요가 없어진 앱이라 할 수도 있지만 본인은 특정 앱은 항상 라이트모드를 유지시켜주는 기능때문에 사용하고 있다.\r\n\r\n### Paste\r\n  \r\n  클립보드 내역 저장 및 확인 앱, 복사한 내용이 모두 저장되어 있어 이전에 복사한 내용도 다시 사용할 수 있다.\r\n\r\n### Send Anywhere\r\n\r\n### Slack\r\n\r\n### Things :credit_card:\r\n\r\n  할일 관리 앱\r\n\r\n### TimeMachineEditor\r\n\r\n  원하는 시간에, 또는 원하는 간격으로 타임 머신 백업이 작동하게 한다.\r\n\r\n### Typora\r\n\r\n  마크다운 에디터, 라이브 프리뷰 기능때문에 자주 활용한다.\r\n\r\n### Ulysses :small_blue_diamond:\r\n\r\n  글쓰기 앱, 마크다운 포멧을 지원하며 다양한 포멧으로 내보내기가 가능하다.\r\n  글쓰기 앱 중에서 탑에 속하는 앱이다. (Bear와 고민했었는데 tag 방식의 정리방식 보다 폴더 방식을 선호해 이 앱을 선택하였다)\r\n\r\n### Visual Studio Code\r\n\r\n### Wake Up Time\r\n\r\n  알람 앱\r\n\r\n### Parallels Desktop :credit_card:\r\n\r\n\r\n## 그 외 Apps\r\n\r\n### Magnet :credit_card:\r\n\r\n  윈도우 정리 앱, 드래그 하여 창을 좌측의 반으로 위치하는 등 이러한 동작이 가능하게 해주는 앱이다.  \r\n  BetterTouchTool에서도 가능하게 할 수 있는 기능이라 BTT앱으로 통합해 이 앱은 사용하지 않을 예정\r\n\r\n### iTerm\r\n\r\n  터미널 앱, mac catalina에서는 기본적으로 쉘이 zsh를 사용한다. 따라서 처음에 터미널 설정이 간략화되었는데 그래서 이번에는 iTerm 대신 hyper를 사용하고, 출력이 많은 복잡한 작업에는 기본 터미널을 사용할 예정이다.\r\n\r\n### Boom 3D :small_blue_diamond:\r\n\r\n  음향 관련 앱이다. EQ 및 소리 증폭의 용도인데 본인은 소리 증폭의 용도로 사용하고 있었다.\r\n\r\n### Runcat\r\n\r\n  메뉴바에 뛰어다니는 고양이 아이콘이 생긴다. cpu사용양에 따라 달리는 속도가 달라진다.  \r\n  귀여워서 사용하고 있었지만 앱 최소화를 위해 기존 사용하던 iStat menus의 cpu 사용량을 사용할 예정\r\n\r\n### PopClip :credit_card:\r\n\r\n  텍스트 드래그시 다양한 기능을 사용할 수 있는 툴팁이 드래그 위치에 뜬다. 다양한 복사 방식, 번역, 다른 앱과 연동된 기능 등  \r\n  원치 않을 때 동작하는 경우가 가끔 있고 생각보다 불필요한 것 같아 일단 이번에는 설치 안해보는 것으로..\r\n\r\n### Sip :small_blue_diamond:\r\n\r\n  Color picker, 편하게 화면의 특정 부분 색상이 무엇인지 알아낼 수 있다.  \r\n  필수 앱으로 넣을까 고민이 되었는데, 아마도 필요에 의해 금방 설치하게 될 것 같다.\r\n\r\n### Timing :small_blue_diamond:\r\n\r\n  컴퓨터 사용량 기록 앱, 어떤 앱을 어떤 사이트를 얼마나 사용했는지 기록해준다.  \r\n  그를 바탕으로 생산성이 몇프로인지 계산해준다. 이번에 mac catalina에서 스크린 타임이 있어 불필요해진 앱이라는 소리를 듣고 있다. 그런데 스크린 타임은 우리가 기대하는 방식으로 동작하지 않아 timing 앱이 필요하긴 한 것 같은데 고민을 좀 해봐야겠다.\r\n","excerpt":"현재 mac Catalina developer beta의 환경으로 사용하고 있었는데, 지금까지 설치한 앱들이 너무 많고 메뉴바 또한 넘처나기 직전이다. bartender, dozer와 같은 메뉴바 정리 앱으로 정리를 했는데도 말이다. 그래서 macOS…","fields":{"slug":"/my-mac-apps/"},"frontmatter":{"date":"Jul 15, 2019","title":"사용중인 mac App 목록 및 앱 추천","tags":["mac"],"update":null}}},{"node":{"rawMarkdownBody":"\r\na, b, c.. 라는 함수가 있다고 가정하자.\r\n```js\r\na(b,c(d,e()));\r\n```\r\n위와 같이 함수가 중첩되고 연속된다면 가독성도 좋지않고 작성하는데도 어려움이 있다.\r\n함수들을 연속적으로 사용하는 함수, 함수들을 함축하는 함수인 go/pipe에 대해 알아보자\r\n\r\n## go\r\n\r\ngo 함수는 인자를 받아 결과를 바로 산출해내는 함수이다.\r\n첫번째 인자는 시작이 되는 **값**을 받고, 나머지는 **함수**를 받아 첫번째 인자가 두번째 함수로 가 결과를 만들고 그 결과가 또 세번째 함수로가 그 결과가 만들어지는 과정이 마지막까지 계속된다.\r\n\r\n```js\r\ngo(\r\n  0,\r\n  a + 1,\r\n  a * 10,\r\n  console.log\r\n)\r\n```\r\n\r\n위와 같이 함수를 실행했을 때 기대값은 10이며 마지막 함수(console.log)가 실행되면서 10이 출력되는 것을 기대할 수 있다.\r\n\r\n```js\r\nconst go = (...func) =>\r\n  func.reduce((previousFunc, curretFunc) => {\r\n    return curretFunc(previousFunc);\r\n  });\r\n```\r\n\r\n간단히 나타내면 위와 같다.\r\n\r\n## pipe\r\n\r\npipe 함수는 **함수를 리턴하는 함수**로 인자로 함수들을 받아 그 함수들을 합성해 하나의 함수를 리턴한다. go와는 반환하는 것이 다르다.\r\n\r\n```js\r\nlet pipe = () => () => {}; // 함수를 리턴하는 함수\r\n\r\nconst p = pipe(\r\n  a => a + 1,\r\n  a => a * 10\r\n);\r\n\r\nconsole.log(p(0));\r\n```\r\n\r\n위와 같은 코드 구성이 될 것이며 `p`에는 합성된 함수가, 그리고 그 `p`를 실행한 `p(0)`의 출력은 10이 나올 것으로 기대할 수 있다.\r\n```js\r\npipe = (...funcs) => argument => funcs.reduce((acc, func) => func(acc), argument);\r\n\r\nconst p = pipe(\r\n  a => a + 1,\r\n  a => a * 10\r\n);\r\n\r\nconsole.log(p(0));\r\n```\r\n\r\npipe 함수를 작성하는 과정을 쪼개보면 아래와 같다\r\n```js\r\npipe = (...funcs) => {};\r\n// pipe 함수는 인자로 함수들을 받는다.\r\n\r\npipe = (...funcs) => () => {};\r\n// 함수를 리턴하게 될 것이다.\r\n\r\npipe = (...funcs) => argument => {};\r\n// 여기서 argument는 pipe 함수가 실행되어 함축된 함수, 그 함수의 매개 변수이다.\r\n\r\npipe = (...funcs) => argument => funcs.reduce(() => {}, argument);\r\n// 함수들을 함축해야 하므로 pipe의 인자로 들어온 함수들에 reduce를 사용한다.\r\n// reduce의 시작으로 함축된 함수의 매개변수인 argument를 전달해준다. (argument: 값)\r\n\r\npipe = (...funcs) => argument => funcs.reduce((acc, func) => func(acc), argument);\r\n// 이제 위와 같이 reduce의 첫번째 인자를 채워준다.\r\n// 처음 reduce가 실행될 때는 acc가 pipe 함수의 실행 결과인 함수의 인자 **값**이 들어간다.\r\n// 다음부터는 그 함수의 실행 결과 값이 acc가 되어 누산되는 과정이 된다.\r\n```\r\n\r\n작성한 pipe 코드에서 마지막 reduce의 동작은 go와 거의 같기 때문에 아래와 같이 작성해도 같은 코드라 할 수 있다.\r\n```js\r\npipe = (...funcs) => (argument) => go(argument, ...funcs);\r\n```\r\n\r\ngo의 경우에도 pipe 코드를 활용하여 작성 할 수 있다.\r\n결국 pipe를 실행해 함축된 함수를 실행하면 go를 한 동작과 거의 동일하기 때문이다.\r\n물론 위의 pipe에 go를 활용한 코드와 함께 사용은 불가하다.\r\n```js\r\ngo = (...fns) => {\r\n  const [argument, ...funcs] = fns;\r\n  return pipe(...funcs)(argument);\r\n  // 또는 return pipe.apply(null, funcs)(argument);\r\n}\r\n```\r\n\r\n\r\n---\r\n\r\nReferences\r\n- [inflearn | 함수형 프로그래밍과 JavaScript ES6+](https://www.inflearn.com/course/functional-es6)\r\n","excerpt":"a, b, c.. 라는 함수가 있다고 가정하자. 위와 같이 함수가 중첩되고 연속된다면 가독성도 좋지않고 작성하는데도 어려움이 있다.\n함수들을 연속적으로 사용하는 함수, 함수들을 함축하는 함수인 go/pipe에 대해 알아보자 go go…","fields":{"slug":"/functional-go-pipe/"},"frontmatter":{"date":"Jul 12, 2019","title":"JavaScript 함수형 프로그래밍, go / pipe","tags":["javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n\r\n\r\n이터러블 프로토콜은 ES6에서 도입된 것으로 간단히 말하면 \r\n**이터러블 프로토콜은 순회(반복) 가능한 객체를 나타내는 프로토콜**이라 할 수 있다.\r\n\r\n`for...of` 반복문, `...` 전개 연산자(Spread Operator), 구조 분해 등과 함께 동작 할 수 있도록 한 프로토콜이다. 이 말은 이터러블이여야만 이러한 동작이 가능하다는 것을 뜻하기도 한다.\r\n\r\n## iterable/iterator\r\n\r\n- 이터러블: 이터레이터를 반환하는 `Symbol.iterator`라는 키값의 메소드를 가진 객체\r\n- 이터레이터: `{ value, done }` 객체를 반환하는 `next()` 메소드를 가진 객체\r\n\r\n이제 예제를 통해 살펴보자.\r\n\r\n```js\r\nconst arr = [1, 2, 3];\r\n\r\nfor(const n of arr) {\r\n  console.log(n);\r\n}\r\n// 1 2 3\r\n\r\nconsole.log(...arr);\r\n// 1 2 3\r\n\r\nconst [first, ...remain] = arr;\r\nconsole.log(first, remain); // 1, [2, 3]\r\n```\r\n\r\n위는 일반적인 배열의 값들을 for...of 반복문으로 출력한 것이다.\r\n(예를 든 Array 외에도 이터러블이 가능한 반복가능한 객체로는 Map, Set, String, TypedArray, arguments 객체 등이 있다)\r\n앞서 말했듯 for...of 순회가 가능한 이유는 이터러블이기 때문인데 그것을 아래에서 확인해보자\r\n\r\n```js\r\nconsole.dir(arr);\r\n\r\n/*\r\n> Array(3)\r\n  > __proto__ : Array(0)\r\n     ...\r\n     > Symbol(Symbol.iterator): ƒ values()\r\n     ...\r\n*/\r\n```\r\n\r\n우선 Array의 내부(프로토타입 체인 내)에서 `Symbol(Symbol.iterator): ƒ values()`를 확인 할 수 있다.\r\nArray에는 `Symbol(Symbol.iterator)`라는 key를 가진 함수가 존재한다는 것을 알 수 있고 앞서 설명한 **이터레이터를 반환하는 `Symbol.iterator`라는 키값의 메소드를 가진 객체**에 부합하는 것을 볼 수 있다.\r\n\r\n만약 위의 코드를 아래와 같이 하면 어떻게 될까\r\n\r\n```js\r\nconst arr = [1, 2, 3];\r\n\r\narr[Symbol.iterator] = null;\r\n\r\nfor(const n of arr) { // Uncaught TypeError: arr is not iterable\r\n  console.log(n);\r\n}\r\nconsole.log(...arr);\r\n```\r\n\r\n`arr[Symbol.iterator] = null;`을 통해 이제 더이상 배열 arr은 이터러블이 아니게 되었다.\r\n그래서 for...of에서 arr은 이터러블이 아니라는 오류를 만나게 된다. 전개 연산자도 마찬가지다.\r\n\r\n여기까지 이터러블의 모습까지 확인해보았고 다음으로는 이터레이터를 확인해보자.\r\n\r\n`arr[Symbol.iterator]`는 함수이다. 그렇다면 `arr[Symbol.iterator]()`를 한다면 반환되는 것은 이터레이터가 될 것이다.\r\n\r\n```js\r\nconst arrIter = arr[Symbol.iterator]();\r\n\r\nconsole.log(arrIter); // Array Iterator {}\r\n```\r\n\r\n위 코드를 통해 반환된 것이 이터레이터 객체인 것을 확인했다.\r\n\r\n이터레이터는 **`{ value, done }` 객체를 반환하는 `next()` 메소드를 가진 객체**라고 했었는데 `next()` 메소드를 확인해보자.\r\n\r\n```js\r\nconsole.log(arrIter.next()); // {value: 1, done: false}\r\nconsole.log(arrIter.next()); // {value: 2, done: false}\r\nconsole.log(arrIter.next()); // {value: 3, done: false}\r\nconsole.log(arrIter.next()); // {value: undefined, done: true}\r\nconsole.log(arrIter.next()); // {value: undefined, done: true}\r\n```\r\n\r\n보는 것과 같이 `{ value, done }` 객체가 반환 된 것을 볼 수 있다.\r\nvalue값이 있을 때는 done이 false를 가지고, 이제 순회할 것이 없는 상황에는 done이 true를 가진다.\r\n\r\n또 다른 예제를 살펴보자.\r\n\r\n```js\r\nconst arrIter2 = arr[iterator]();\r\n\r\narrIter2.next();\r\n\r\nfor(const v of arrIter2){\r\n\tconsole.log(v);\r\n}\r\n// 2 3\r\n```\r\n\r\n반복문 전에 `next()`를 한번 해서 첫번째 값은 출력이 안된 모습을 확인 할 수 있다.\r\n\r\n## 사용자 정의 iterable protocol\r\n\r\n이터러블 프로토콜을 따라서 또한 순회 동작을 사용자 정의할 수 있다는 점이 이터러블을 활용하는데 있어 중요한 의의를 가진다.\r\n\r\n```js\r\nconst reverseIterable = a => {\r\n  return {\r\n    [Symbol.iterator]() {\r\n      let i = a.length;\r\n\r\n      return {\r\n        next() {\r\n          return i === 0 ? { value: undefined, done: true } : { value: i--, done: false };\r\n        },\r\n        [Symbol.iterator]() {\r\n          return this;\r\n        }\r\n      };\r\n    }\r\n  };\r\n};\r\n\r\nconst reverseArr = reverseIterable(arr);\r\nfor (const v of reverseArr) console.log(v); // 3 2 1\r\n\r\nconst reverseArrIter = reverseArr[Symbol.iterator]();\r\nconsole.log(reverseArrIter.next()); // {value: 3, done: false}\r\nfor (const v of reverseArrIter) console.log(v); // 2 1\r\n```\r\n\r\n위 코드는 일반적인 이터러블 순회를 반대 순서로 순회가 되도록 바꿔 본 커스텀 이터러블이다.\r\n\r\n부분적으로 자세히 살펴보자.\r\n\r\n이터러블은 **이터레이터를 반환 `Symbol.iterator`의 키값의 메소드를 가진 객체**라 했었으니\r\n아래와 같이 `return { [Symbol.iterator](){...} }` 와 같이 시작할 것이다.\r\n\r\n```\r\nconst reverseIterable = (a) => {\r\n  return {\r\n    [Symbol.iterator]() {\r\n      // ... \r\n    }\r\n  };\r\n};\r\n```\r\n\r\n또한 이터레이터는 **`{ value, done }` 객체를 반환하는 `next()` 메소드를 가진 객체**라 했었으니 아래와 같은 구조여야한다.\r\n\r\n```js\r\nconst reverseIterable = (a) => {\r\n  return {\r\n    [Symbol.iterator]() {\r\n      next() {\r\n            return { value: ..., done: ... }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n```\r\n\r\n이렇게 여기까지 작성한 코드는 아래와 같다.\r\n\r\n```js\r\nconst reverseIterable = (a) => {\r\n  return {\r\n    [Symbol.iterator]() {\r\n      let i = a.length;\r\n\r\n      return {\r\n        next() {\r\n          return i === 0 ? { value: undefined, done: true } : { value: i--, done: false };\r\n        }\r\n      };\r\n    }\r\n  };\r\n};\r\n```\r\n\r\n이터러블/이터레이터 프로토콜의 조건을 모두 갖춘 것 같다.\r\n맨 위의 완성된 코드가 아닌 바로 위의 코드로 한번 아래 코드를 실행해보자\r\n\r\n```js\r\nconst reverseArr = reverseIterable(arr);\r\n\r\nfor(const v of reverseArr) console.log(v); // 3 2 1\r\n```\r\n\r\n정상적으로 원하는 동작이 된 것 같다.\r\n하지만 아래의 방법으로 실행해보면 에러가 발생한다\r\n\r\n```js\r\nconst reverseArrIter = reverseArr[Symbol.iterator]();\r\n\r\nconsole.log(reverseArrIter.next()); // {value: 3, done: false}\r\n\r\nfor(const v of reverseArrIter) console.log(v);\r\n// Uncaught TypeError: reverseArrIter is not iterable\r\n```\r\n\r\n그 이유는 `reverseArr`의 경우에는 사용자가 정의한  `[Symbol.iterator]()`를 가지고 있어 이터러블하지만 `reverseArr[Symbol.iterator]()`를 통해 만든 이터레이터`reverseArrIter`는 이터레이터의 조건인 **`{ value, done }` 객체를 반환하는 `next()` 메소드를 가진 객체**는 만족하지만 내부(프로토타입 체인)에 `[Symbol.iterator]()`를 가지고 있지 않아 이터러블 하지 않기 때문이다.\r\n\r\nconsole.dir을 이용해 위에서 사용한 `arrIter`를 살펴보면 내부에 `[Symbol.iterator]()`를 가지고 있고 `reverseArrIter`는 그렇지 않은 것을 확인 할 수 있다.\r\n\r\n따라서 코드에서 `next()`와 함께 `[Symbol.iterator]() { return this }`를 리턴해 이터러블하게 해준 것이라 할 수 있다.\r\n\r\n이러하게 이터러블 프로토콜을 사용자 정의해서 사용할 수 있다면 순회 동작에 사용자가 원하는 동작을 넣을 수도 있고 더 나아가 원래 이터러블하지 않는 것조차 순회가 가능하게 이터러블하게 만들어 순회할 수 있게 될 수 있다.\r\n\r\n### 제너레이터\r\n\r\n```js\r\nfunction* gen() {\r\n  yield 1;\r\n  if(false) yield 2;\r\n  yield 3;\r\n  return 4;\r\n}\r\n\r\nconst gIter = gen();\r\n\r\nconsole.log(gIter.next()); \r\n// {value: 1, done: false}\r\n\r\nconsole.log(gIter[Symbol.iterator]);\r\n// ƒ [Symbol.iterator]() { [native code] }\r\n\r\nfor(const v of gIter) console.log(v);\r\n```\r\n\r\n제너레이터의 실행 결과인 제너레이터 객체는 이터레이터 객체이다.\r\n위 코드에서 `gIter.next()`가 가능한 것을 보면 알 수 있다.\r\n또한 `[Symbol.iterator]()`를 가지는 이터러블이기도 하다.\r\n\r\n제너레이터 객체는 이터레이터이자 이터러블이기 때문에 역시 순회가 가능하다.\r\n또한 제너레이터에는 마지막에 리턴 값을 만들 수 있다. 하지만 `done` 또한 `ture`가 되기 때문에 **순회의 대상이 되진 않는다.**\r\n\r\n이러한 제너레이터를 이용하면 위에서 사용자 정의 이터러블을 해본 것을 더 간단하게 바꿀 수 있다.\r\n\r\n```js\r\nfunction* gen2(a) {\r\n  let i = a.length;\r\n\r\n  while (i--) {\r\n    yield a[i];\r\n  }\r\n}\r\n\r\nconst g2Iter = gen2([1, 2, 3]);\r\nconsole.log(g2Iter.next()); // {value: 3, done: false} \r\nconsole.log(g2Iter.next()); // {value: 2, done: false}\r\nconsole.log(g2Iter.next()); // {value: 1, done: false}\r\n```\r\n\r\n## 정리\r\n\r\n- 이터러블 프로토콜: 순회(반복) 가능한 객체를 나타내는 프로토콜, 이터러블이면 순회가 가능하다.\r\n- 이터러블: 이터레이터를 반환하는 `Symbol.iterator`라는 키값의 메소드를 가진 객체\r\n- 이터레이터: `{ value, done }` 객체를 반환하는 `next()` 메소드를 가진 객체\r\n\r\n- 이터러블 프로토콜을 사용자 정의 할 수 있음에 따라 원하는 객체를 지정한 동작에 따라 순회할 수 있게 되어 원하는 값을 추출해내고 다양한 객체에 이를 적용해 결과를 얻을 수 있게 되었다.\r\n\r\n- 기본적으로 반복이 가능한 것으로는 (iterable이 내장되어있다) String, Array, TypedArray, Map, Set가 있다.\r\n\r\n---\r\n\r\nReferences\r\n- [MDN | The iterable protocol](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Iteration_protocols#iterable \"MDN | The iterable protocol\")\r\n- [https://ahnheejong.gitbook.io/ts-for-jsdev/02-ecmascript/element-enumeration/iterable-protocol](https://ahnheejong.gitbook.io/ts-for-jsdev/02-ecmascript/element-enumeration/iterable-protocol)\r\n","excerpt":"이터러블 프로토콜은 ES6에서 도입된 것으로 간단히 말하면 \n이터러블 프로토콜은 순회(반복) 가능한 객체를 나타내는 프로토콜이라 할 수 있다.  반복문,  전개 연산자(Spread Operator…","fields":{"slug":"/iterable-protocol/"},"frontmatter":{"date":"Jul 10, 2019","title":"이터러블 프로토콜, 이터러블/이터레이터","tags":["ES6","javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nAJAX(**A**synchronous**J**avaScript**A**nd**X**ML)는 비동기 자바스크립트를 뜻하는 것으로, 이제는 비동기적 자바스크립트 동작을 하는 기술들을 통들어서도 AJAX라고 부릅니다.\r\n\r\n최초로 Microsoft의 Internet Explorer가 탑재하기 시작했고, AJAX가 주족받고 웹 기술에서 빠지지 않는 주요 기술로 부상한 것은 Google의 Gmail과 Map으로 부터라고 할 수 있습니다.\r\n\r\n**이 포스트는 AJAX의 대표적인 API인  XMLHttpRequest와 Fetch의 기본적인 사용법과 속성들을 살펴봅니다.**\r\n\r\nAJAX하면 예전에는 XMLHttpRequest API를 이용하는 것이 일반적이었으며,\r\n그리고 불편함을 느낀 사람들이 jQuery를 통해 AJAX를 구현하기 시작했고 그 이후로 Fetch API가 ES2015 표준으로 등장하면서 이제는 일반적으로 Fetch API를 통해 구현하는 것이 일반적이 되었습니다. 이 포스트에서는 jQuery는 살펴보지 않겠습니다.\r\n\r\n## XMLHttpRequest\r\n [MDN - XMLHttpRequest](https://developer.mozilla.org/ko/docs/Web/API/XMLHttpRequest)\r\n\r\n우선 XMLHttpRequest로 AJAX를 구현하는 예를 보겠습니다.\r\n`/src/data.json`를 불러와보는 코드입니다.\r\n`/src/data.json`의 내용은 `{ \"name\": \"Jhon\", \"age\": 29 }` 입니다.\r\n\r\n\r\n```js\r\n(function() {\r\n  // XHR 인스턴스 생성\r\n  const httpRequest = new XMLHttpRequest();\r\n\r\n  // httpRequest의 내장 함수 onreadystatechange를 이용해\r\n  // 서버 상태의 변화에 따라 코드를 작성 할 수 있습니다.\r\n  httpRequest.onreadystatechange = event => {\r\n    console.log(\r\n      `state : ${httpRequest.readyState} / status : ${httpRequest.status} / ${responseReady()}`\r\n    );\r\n  };\r\n\r\n  // 서버로부터 응답을 받았는지와 정상적으로 처리된 응답인지를 검사하는 함수\r\n  const responseReady = () => {\r\n    try {\r\n      if (httpRequest.readyState === XMLHttpRequest.DONE) {\r\n        if (httpRequest.status === 200) {\r\n\t\t\t// 응답을 정상적으로 받음\r\n          return httpRequest.responseText;\r\n        } else {\r\n          return Error('request에 문제가 있습니다.');\r\n        }\r\n      } else {\r\n        return Error('request의 상태가 complete(4)가 아닙니다.');\r\n      }\r\n    }\r\n    catch( e ) {\r\n      return Error('Caught Exception: ' + e.description);\r\n    }\r\n  }\r\n\r\n  httpRequest.open(\"GET\", \"/src/data.json\");\r\n  httpRequest.send();\r\n})();\r\n```\r\n\r\n코드를 살펴보겠습니다.\r\n\r\n`const httpRequest = new XMLHttpRequest();` \r\n생성자를 이용해 XHR 객체 인스턴스를 생성합니다\r\n\r\n`httpRequest.onreadystatechange` \r\nonreadystatechange 내장 함수를 이용하여 서버의 상태에 따른 코드를 작성합니다. 내부의 코드 console.log를 살펴보면 아래와 같습니다.\r\n\r\n```js\r\nconsole.log(\r\n      `state : ${httpRequest.readyState} / status : ${httpRequest.status} / ${responseReady()}`\r\n    );\r\n```\r\n\r\n여기서 readyState는 서버의 응답 상태를 나타내며 아래 목록의 값을 가질 수 있습니다.\r\n- 0 (uninitialized) -(**request가 초기화되지 않음**)\r\n- 1 (loading) -(**서버와의 연결이 성사됨**)\r\n- 2 (loaded) -(**서버가 request를 받음**)\r\n- 3 (interactive) -(**request(요청)을 처리하는 중**)\r\n- 4 (complete) -(**request에 대한 처리가 끝났으며응답할 준비가 완료됨**)\r\n\r\nstatus code에 대한 설명은 생략합니다.\r\n\r\n그리고 responseReady() 함수의 반환값이 마지막으로 위치합니다.\r\n\r\n여기까지가 요청에 따른 응답을 처리하는 코드를 작성한 부분이고\r\n\r\n```js\r\n  httpRequest.open(\"GET\", \"/src/data.json\");\r\n  httpRequest.send();\r\n```\r\n\r\n이 open, send 부분이 요청을 하는 부분입니다. 이 코드로 인해 지금까지 설명한 코드들이 실행되게됩니다.\r\n\r\nopen을 하면 위에서 설명한 state가 1번까지 실행되며\r\nsend를 하면 4번까지 작동하며 응답을 받을 수 있게 됩니다.\r\n\r\nopen 메소드의 파라미터\r\n- 첫번째로 HTTP 요청 메소드(GET,  POST, HEAD)가 위치하게 됩니다.\r\n- 두번째 파라미터는 요청 URL로 주소 또는 경로가 될 수 있습니다.\r\n- 세번째 파라미터는 생략가능하며 요청이 비동기적으로 실행될지 여부를 결정합니다. \r\n\t- default: true\r\n\t- false로 설정된 경우 동기적으로 작동합니다. (send()함수에서 서버로부터 응답이 올 때까지 기다림)\r\n\r\n아래는 지금까지 코드의 콘솔 출력입니다.\r\n\r\n```bash\r\n< state : 1 / status : 0 / Error: request의 상태가 complete(4)가 아닙니다. \r\n\r\n< state : 2 / status : 200 / Error: request의 상태가 complete(4)가 아닙니다. \r\n\r\n< state : 3 / status : 200 / Error: request의 상태가 complete(4)가 아닙니다. \r\n\r\n< state : 4 / status : 200 / { \"name\": \"Jhon\", \"age\": 29 }\r\n```\r\n\r\nstate가 4로 즉 `XMLHttpRequest.DONE`이며 complete 상태일때 응답을 받을 수 있는 상태가 되었고 응답을 받은 것을 확인 할 수 있습니다.\r\n\r\n## Fetch\r\n기존의 XHR 객체를 이용한 AJAX는 복잡하기도 하며 가독성이 떨어졌었습니다. 그래서 등장한 것이 Fetch API로 ES6(ES2015)에서 표준이 되었습니다.\r\nFetch는 반환값으로 Promise를 가집니다. 이 또한 ES6에 등장한 것으로 여기서는 이에 대해 자세히 설명하지 않고 기본적인 사용법을 기술합니다.\r\n\r\n```js\r\nfetch( resource, init )\r\n  .then( callback )\r\n  .catch( callback )\r\n```\r\n\r\n기본적으로 fetch는 이러한 구조를 가집니다.\r\n\r\nfetch의 파라미터\r\n- resource : 요청 주소, URL, 경로\r\n- init (optional) : 설정 객체\r\n\r\n아래는 설정 객체의 예\r\n```js\r\nconst init = {\r\n  method: \"POST\",\r\n\tbody: JSON.stringify(data),\r\n\theaders: {\r\n    \"Content-Type\": \"application/json\"\r\n  },\r\n\tcredentials : \"same-origin\"\r\n}\r\n```\r\n설정 객체의 요소들은 아래 링크에서 확인할 수 있습니다.\r\n[fetch() #parameters | MDN](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\r\n\r\n이제 간단한 예제를 살펴보겠습니다.\r\n\r\n```js\r\n// data.json : {name: \"Jhon\", age: 29}\r\n\r\nfetch('/src/data.json')\r\n  .then(response => {\r\n    // 첫번째 then\r\n    if(response.status === 200){\r\n      return response.json()\r\n    } else {\r\n      console.log(response.statusText);\r\n    }\r\n  })\r\n  .then(jsonData => {\r\n    // 두번째 then\r\n    console.log(jsonData); // Object {name: \"Jhon\", age: 29}\r\n  })\r\n  .catch(err => {\r\n    console.log(err)\r\n  })\r\n```\r\n\r\nfetch에 요청할 경로를 적고 필요의 경우 설정 객체 또한 전달합니다.\r\n그 결과로 Response 인스턴스가 반환됩니다. 첫번째 then에서 response가 그것입니다. Response 객체의 속성들을 살펴보면 상태를 나타내는 status(정수), statusText(문자)가 있고 요청에 대한 헤더 정보를 담고 있는 header, 그리고 응답 내용을 담고 있는 body가 있습니다.\r\n\r\n위의 코드를 살펴보면 fetch 요청 후,\r\n첫번째 then에서 상태 코드가 200일 경우 response.json()을 리턴하며, 상태 코드가 다를 경우에는 상태 문자를 출력합니다.\r\n두번째 then으로 넘겨지게 되면 이제 첫번째 then에서 넘겨받은 값을 출력하게 됩니다.\r\n\r\n조금 더 자세히 살펴보면\r\n첫번째 then에서 response.json()을 바로 출력하지 않고 다음 then으로 리턴하여 넘겨준 것은 response.json()은 기대하는 실제 값이 아닌 Promise를 가지고 있기 때문입니다. 이 과정을 살펴보면 아래와 같습니다.\r\n\r\nResponse 객체의 body 값을 추출해내기 위해서는 타입에 따라 아래와 같은 메소드를 사용해야 합니다.\r\n- arrayBuffer()\r\n- blob()\r\n- json()\r\n- text()\r\n- formData()\r\n\r\n위 메소드들은 모두 Promise를 반환합니다. 그리고 이 Promise가 resolve되어 다음 then에서는 실제 값을 다룰 수 있게 됩니다.\r\n\r\n여기까지가 기본적인 내용이며 실제 사용 할 때는 필요에 따라 심화로 init object, Header, Request에 대해서 알아보고 사용하는 것이 좋습니다.\r\n---- \r\nReferences\r\n- [Ajax 시작하기 - 웹 개발자 안내서 | MDN](https://developer.mozilla.org/ko/docs/Web/Guide/AJAX/Getting_Started)\r\n- [MDN - XMLHttpRequest](https://developer.mozilla.org/ko/docs/Web/API/XMLHttpRequest) \r\n- [WindowOrWorkerGlobalScope.fetch() - Web APIs | MDN](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch)\r\n- [정말 멋진 Fetch API! | Mozilla 웹 기술 블로그](http://hacks.mozilla.or.kr/2015/05/this-api-is-so-fetching/)\r\n","excerpt":"AJAX(AsynchronousJavaScriptAndXML)는 비동기 자바스크립트를 뜻하는 것으로, 이제는 비동기적 자바스크립트 동작을 하는 기술들을 통들어서도 AJAX라고 부릅니다. 최초로 Microsoft의 Internet Explorer…","fields":{"slug":"/ajax-xhr-fetch/"},"frontmatter":{"date":"May 14, 2019","title":"AJAX, XMLHttpRequest와 Fetch 살펴보기","tags":["javascript","ajax","ES6"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n**(macOS Mojave 환경에서의 포스팅입니다)**\r\n\r\npyenv는 nvm(Node Version Manager)과 비슷하게 필요에 따라 다양한 파이썬 버전으로 실행할 수 있는 환경을 제공하는 버전 매니저이다.\r\n\r\n프로젝트별 버전을 달리 사용하는 용도가 아니더라도 macOS에서 Python을 설치하고 디폴트 버전을 바꾸는 등 설정을 하는 과정보다 pyenv를 사용하는 것이 훨씬 간편하다.\r\n\r\n## pyenv 설치\r\n\r\n우선 pyenv를 설치하기 위해 패키지 관리자인 HomeBrew가 설치되어있어야 한다. HomeBrew가 설치되지 않았다면 터미널에서 아래 명령어를 통해 설치한다.\r\n\r\n```shell\r\n$ ruby -e \"$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)”\r\n```\r\n\r\nHomeBrew가 준비되었다면 아래 명령어로 pyenv를 설치한다.\r\n\r\n```shell\r\n$ brew install pyenv\r\n```\r\n\r\n## Python 설치\r\n\r\npyenv 설치 후 아래 명령어를 통해 pyenv를 통해 설치할 수 있는 리스트를 확인 할 수 있다.\r\n\r\n```shell\r\n$ pyenv install --list\r\n```\r\n\r\n확인된 리스트에서 원하는 버전을 선택해 설치한다. 예로 3.7.2 버전을 아래 명령어를 통해 설치한다.\r\n\r\n```shell\r\n$ pyenv install 3.7.2\r\n```\r\n\r\nmacOS 버전이 Mojave라면 인스톨 단계에서 에러가 발생할 수 있는데 에러가 발생했다면 아래 명령어를 실행 후 다시 인스톨하면 된다.\r\n\r\n```shell\r\n$ sudo installer -pkg /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg -target /\r\n```\r\n\r\n설치 후에는 아래 명령어를 통해 확인해 볼 수 있다. 아래 명령어는 pyenv를 통해 설치된 리스트를 확인 할 수 있다.\r\n\r\n```shell\r\n$ pyenv versions\r\n```\r\n\r\n이제 설치한 버전을 글로벌 환경에서 디폴트로 사용할 수 있도록 지정해준다.\r\n\r\n```shell\r\n$ pyenv global 3.7.2\r\n```\r\n\r\n지정 후에 적용하려면 아래 명령어가 필요하다.\r\n\r\n```shell\r\n$ eval \"$(pyenv init -)\"\r\n```\r\n\r\n차후에 이 명령어가 필요없도록 `.zshrc` 또는 `.bashrc` 에 해당 명령어를 추가하여 간단하게 터미널을 재시작하면 적용되도록 할 수 있다.\r\n\r\n```shell\r\n$ vi ~/.zshrc\r\n```\r\n\r\n위 명령어로 `.zshrc` 의 하단에 `eval \"$(pyenv init -)\"` 를 추가해주자.\r\n\r\n이제 터미널을 재실행하고 아래 명령어를 통해 원하는 버전이 적용된 것을 확인 할 수 있다.\r\n","excerpt":"(macOS Mojave 환경에서의 포스팅입니다) pyenv는 nvm(Node Version Manager…","fields":{"slug":"/install-python-use-pyenv/"},"frontmatter":{"date":"Feb 20, 2019","title":"pyenv를 이용해 Python 설치하기 (macOS)","tags":["python"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n## Tablo - Bookmark and manage tabs\r\n\r\n다운로드 링크 : [Chrome WebStore - Tablo](https://chrome.google.com/webstore/detail/tablo-bookmark-and-manage/aoccnljcdmmbihgabpoljghfcmbflkhc)\r\n\r\n우선 Tablo 앱을 만들게 된 것은 나만의 링크들을 담아두는 즐겨찾기를 만들고자 시작했고,\r\n\r\n그 방식은 현재 열려있는 탭들을 나만의 리스트에 옮겨 관리할 수 있게 되는 방식을 원했다.\r\n\r\n그래서 만들어진 것이 Tablo이고 아래는 기능에 대한 간략한 설명이다.\r\n\r\n### 열려있는 탭을 기준으로 나만의 북마크 리스트 만들기\r\n\r\n우측에 현재 열려있는 탭의 리스트가 있다,  \r\n\r\n좌측에는 'trello' 혹은 'Github projects'와 비슷한 인터페이스의 칸반 보드가 위치한다.\r\n\r\n우측의 열려있는 탭 리스트에서 링크를 드래그하여 좌측의 원하는 칸안에 드랍하면 된다.\r\n\r\n### 웹 서핑 중 페이지 링크를 담기\r\n\r\nCart 기능이라고 불린다. 웹 서핑중 이 페이지를 Tablo에 저장하고 싶다면,\r\n\r\n우측 상단에 크롬 확장 프로그램 툴바에 위치한 Tablo 아이콘을 클릭하면 '카트에 담기'가 보이게 되고 해당 기능을 이용하면\r\n\r\nTablo에서 우측에 Cart 부분에 담기게 된다. 이제 링크를 Cart에서 드래그하여 원하는 곳에 분류하면 된다.\r\n\r\n## 개발\r\n\r\n전반적인 개발 스택은 아래와 같다\r\n\r\n- React\r\n- Redux\r\n- Webpack\r\n- SASS(SCSS)\r\n- Chrome Extension\r\n\r\n우선 React + Webpack으로 개발을 시작했다. 개발을 시작하자마자 바로 문제점을 만났는데 크롬 확장프로그램을 개발 중 계속해서 빌드하고 새로고침하는 방법을 쓰기는 너무나도 불편했다. 해결점을 찾다가 한 레포지토리([link](https://github.com/samuelsimoes/chrome-extension-webpack-boilerplate))를 발견해서 개발 중에도 계속해서 build 폴더가 변경되면서 핫로더 기능이 작동할 수 있게 되었다. 이 레포지토리를 클론하고 이 프로젝트에 맞게 Webpack을 수정하고 개발하기 시작했다.\r\n\r\n여러 컴포넌트가 있고 각 컴포넌트간에 드래그 앤 드랍이 왔다갔다 하면서 데이터를 관리하기가 어렵다는 것을 느끼게 되어 Redux를 쓰기 시작했다. Redux를 기본만 익혀두고 안쓴지 오래되었기 때문에 다시 익히는데 시간이 조금 오래 걸렸다. 지금 reducer 코드도 정리 안 된 것이 많지만 일단은 나중에 리팩토링하기로 했다.\r\n\r\n기본적으로 Redux를 써서 데이터를 관리하지만 데스크탑, 노트북이든 어디서든 똑같은 데이터가 공유되기를 원했다. 로그인 기능을 활용하기엔 정적 사이트인 크롬 확장프로그램은 어려웠고 그래서 Chrome Extension의 기능을 가져다쓴 Sync Storage를 활용해 어디서든 크롬 브라우저에 로그인만 되어있다면 데이터가 공유 될 수 있도록 했다.\r\n\r\n드래그 앤 드랍 부분이 이 프로젝트에서 상당히 많은 부분을 차지하는데 일단 라이브러리 없이 개발하고 싶었다. 그렇게 개발하였고 지금은 동작 부분에서는 문제가 없지만 코드 측면에서 많아진 드래그 앤 드랍 관련 함수들을 어떻게 정리할지가 고민이다. 또한 브라우저에서 마우스를 따라오는 드래그하는 개채가 기본적으로 opacity가 정해져있어 그것을 어떻게 해결할지도 고민이다. 윈도우 환경에서는 특히나 더 심해 드래그하는 개체가 잘 보이지 않는다.\r\n\r\n주절주절 말이 많았지만 지금까지 개발 후 다음으로 해야할 것들을 정리해보면\r\n\r\n- Redux 스터디 및 Redux 코드 리팩토링\r\n- DnD 관련 함수 정리\r\n- 드래그 개체의 opacity 조절 방법 찾기\r\n- 추가적인 기능 구현\r\n  - 칸반 보드의 색상 커스터마이징이 가능\r\n\r\n개선할 것이 많긴하지만 일단 어느정도 원하는 기능이 다 담길만큼 개발했다.\r\n\r\n백로그없이 기존에 생각하고 있는 것대로 구현하고 개발을 어느정도 마쳤더니 정리가 안된 느낌이 있지만 일단 지금은 이 프로젝트에 계속해서 시간을 투자할 수 없어 여기까지하고 차후에 리팩토링을 통해 해결해야겠다.\r\n","excerpt":"Tablo - Bookmark and manage tabs 다운로드 링크 : Chrome WebStore - Tablo 우선 Tablo…","fields":{"slug":"/tablo-develop/"},"frontmatter":{"date":"Jan 08, 2019","title":"크롬 확장프로그램 \"Tablo\" 소개 및 개발기","tags":["undefined"],"update":null}}}]}},"pageContext":{}}}