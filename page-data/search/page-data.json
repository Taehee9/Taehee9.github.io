{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n뒤늦은 Hooks 포스팅입니다. Hooks 기본을 정리해보고, 사용해오면서 알게 된 점도 정리해봅니다.  \r\n간단히 useState에 대해 설명하고, useEffect에 대해서는 조금 더 자세하게 알아봅니다.\r\n\r\n---\r\n\r\n# first\r\n## second\r\n### third\r\n#### fourth\r\n##### fifth\r\n###### sixth\r\n\r\n1. 처음\r\n2. 두번째\r\n3. 셋째\r\n4. 넷째\r\n\r\n```\r\ncode content\r\n```\r\n* 하나\r\n    + 둘\r\n        - 셋\r\n            * 넷\r\n\r\n**굵게**\r\n*기울여서*\r\n~~취소선~~\r\n\r\n> 인용문\r\n\r\n`인라인코드`\r\n\r\n```javascript\r\nlet sumNumbers = (firstNum, lastNum) => {\r\n  return firstNum + lastNum;\r\n};\r\nsumNumbers(100, 200);\r\n```\r\n\r\n[타이틀](https://naver.com)\r\n\r\n---\r\n\r\n![강아지!!](https://cdn.pixabay.com/photo/2018/04/23/14/38/adorable-3344414_1280.jpg)\r\n\r\n| 드라마 제목 | 주연 배우 | 방영일 |\r\n|:----------|:----------:|----------:|\r\n| **호텔 델루나** | 이지은, 여진구 | ~*2019.07.13. ~ 2019.09.01.*~ |\r\n| 멜로가 체질 | 천우희, 전여빈, 한지은, 안재홍 | 2019.08.09. ~ |\r\n| 이태원 클라쓰 | 박서준, 김다미 | 2020.01.31. ~ |\r\n\r\n- [ ] 체크박스\r\n- [x] 체크 ","excerpt":"뒤늦은 Hooks 포스팅입니다. Hooks 기본을 정리해보고, 사용해오면서 알게 된 점도 정리해봅니다. 간단히 useState에 대해 설명하고, useEffect에 대해서는 조금 더 자세하게 알아봅니다. first second third fourth…","fields":{"slug":"/react-hooks/"},"frontmatter":{"date":"Feb 19, 2020","title":"React Hooks: useState, useEffect 알아보기","tags":[null],"update":null}}},{"node":{"rawMarkdownBody":"\r\nGatsbyJS 설치 방법부터 배포하는 방법까지 정리해보자.\r\n\r\n---\r\n\r\n## GatsbyJS 설치 방법\r\n```\r\n$ npm install --global gatsby-cli\r\n```\r\n\r\n### Starter 이용\r\n[Gatsby 스타터](https://www.gatsbyjs.org/starters/?v=2)에서 마음에 드는 스타터 선택\r\n\r\n마음에 드는 스타터 클릭시 하단에 \r\n![source](source.PNG) 이 부분을 복사 붙여넣기\r\n\r\n```\r\n// 빈프로젝트 생성\r\n$ gatsby new [프로젝트명]\r\n\r\n// 스타터로 프로젝트 생성\r\n$ gatsby new [프로젝트명] [스타터 github 주소]\r\n```\r\n\r\n## 실행방법\r\n```\r\n$ gatsby develop\r\n```\r\n</br>\r\n\r\n\r\n## Github Pages 배포 방법\r\nGithub Pages에 배포하기 위해서 gh-pages 패키지 설치\r\n```\r\n$ npm install gh-pages --save-dev\r\n```\r\n\r\n### Github Pages 2가지 배포 방법\r\n#### 개인 사이트\r\nGit Repository = [사용자명].github.io\r\n\r\npakage.json에\r\n```\r\n{\r\n    \"script\": {\r\n        \"deploy\": \"gatsby build && gh-pages -d public -b master\"\r\n    }\r\n}\r\n```\r\n</br>\r\n\r\n#### 프로젝트 사이트\r\nGit Repository = 프로젝트명\r\n\r\n```\r\npackage.json에\r\n{\r\n    \"script\": {\r\n        \"deploy\": \"gatsby build --prefix-paths && gh-pages -d public\"\r\n    }\r\n}\r\n```\r\n\r\ngatsby-config.js 에\r\n```\r\nmodule.exports = {\r\n    pathPrefix: \"/[Git Repository 명]\"\r\n}\r\n```\r\n\r\n### 실제 배포\r\n```\r\n$ npm run deploy\r\n```\r\n입력해서 github pages에 배포\r\n</br>\r\n\r\n## 접속방법\r\n#### 개인 사이트\r\nhttps://[사용자명].github.io\r\n\r\n#### 프로젝트 사이트\r\nhttps://[사용자명].github.io/[프로젝트명]\r\n\r\n\r\n## Github에 commit\r\n> master가 배포되므로 꼭 develop에 commit 하기\r\n","excerpt":"GatsbyJS 설치 방법부터 배포하는 방법까지 정리해보자. GatsbyJS 설치 방법 Starter 이용 Gatsby 스타터에서 마음에 드는 스타터 선택 마음에 드는 스타터 클릭시 하단에 \n 이 부분을 복사 붙여넣기 실행방법 Github Pages…","fields":{"slug":"/gatsby-github-deploy/"},"frontmatter":{"date":"Feb 18, 2020","title":"Gatsby Blog 설치부터 배포 방법까지","tags":["blog","gatsby"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n2020년을 맞아 이미 많이 알고 있는 ES2015(ES6) 다음부터인 ES2016부터 ES2020까지 새로 나온 자바스크립트 기능들을 살펴보려고 합니다. \r\n\r\n모두 소개하는 건 아니고 비교적 도움이 되는, 대표적인 것들을 추려 소개합니다.  \r\n또한 기초적인 사전 지식의 설명은 생략될 수 있습니다.\r\n\r\n<br/>\r\n\r\n## ES2016\r\n\r\n### Array.prototype.includes\r\n\r\n배열 내장 함수 includes가 추가되었습니다.\r\n\r\n```javascript\r\n['a', 'b', 'c'].includes('a') // true\r\n```\r\n\r\n코드를 보면 쉽게 역할을 알 수 있습니다.\r\n배열에 아이템이 존재하는지 Boolean 값을 반환합니다.\r\n\r\n이 함수로 이제 `['a','b','c'].indexOf('a') > -1` 대신 좀 더 간결한 코드가 가능합니다.\r\n\r\n### Exponentiation operator\r\n\r\n제곱 연산자.\r\n기존에 제곱은 Math의 pow 함수를 이용했을 것입니다. \r\n이제는 간단하게 `**` 연산자로 가능하게 되었습니다.\r\n\r\n```javascript\r\nlet num = 2;\r\n\r\nMath.pow(num, 10); // 1024\r\n2 ** 10; // 1024\r\n\r\nnum **= 10;\r\nnum; // 1024\r\n```\r\n\r\n<br/>\r\n\r\n## ES2017\r\n\r\n### String padding\r\n\r\n문자열에 여백을 주기 위해 등장한 기능입니다. \r\n여백 뿐만 아니라 그 여백에 보충 문자를 추가할 수 있습니다.\r\n\r\n여백을 앞에 뒤에 추가할 수 있게 됩니다.\r\n\r\n```javascript\r\npadStart(targetLength [, padString])\r\npadEnd(targetLength [, padString])\r\n```\r\n\r\n간단한 예를 통해 살펴보겠습니다. start와 end의 차이는 앞뒤의 차이밖에 없으니 start만 살펴봅니다.\r\n\r\n`1월` 을 `01월` 과 같이 길이를 맞춰야 할 경우가 있다 이럴때 사용 할 수 있습니다.\r\n\r\n```javascript\r\n`1월`.padStart(1);        // \"1월\"\r\n`1월`.padStart(3);        // \" 1월\"\r\n`1월`.padStart(3, \"0\");   // \"01월\"\r\n`1월`.padStart(7, \"0AB\"); // \"0AB0A1월\"\r\n```\r\n\r\n1번째 라인처럼 문자열보다 작은 수를 지정하더라도 문자열이 잘리거나 하진 않습니다\r\n\r\n2번째 라인은 문자열의 길이보다 하나 긴 3을 넣어 하나의 여백이 추가된 모습입니다.\r\n\r\n3번째 라인이 원하는 의도인 코드입니다.\r\n\r\n4번째 라인처럼 보충 문자를 배열로 작성하면 배열을 순회 반복하며 여백을 채우며 0, A, B를 채우고 다음으로 0, A까지 채워진 모습을 볼 수 있습니다.\r\n\r\n### Object.values()\r\n\r\nObject에 추가된 values 메소드는 객체의 key:value 에서 value 값들을 배열으로 반환합니다.\r\n\r\n```javascript\r\nconst obj1 = {name: \"Jhon\", age: 24};\r\nObject.values(obj1); // [\"Jhon\", 24]\r\n```\r\n\r\n### Object.entries()\r\n\r\n객체 안의 모든 속성을 각각 key, value가 담긴 배열로 하나의 배열에 담습니다.\r\n[[key, value], [key, value], [key, value] ...]\r\n\r\n```javascript\r\nconst obj1 = {name: \"Jhon\", age: 24};\r\n\r\nObject.keys(obj1);    // [\"name\", \"age\"]\r\nObject.values(obj1);  // [\"Jhon\", 24]\r\n\r\nObject.entries(obj1); // [[\"name\", \"Jhone\"], [\"age\", 24]]\r\n```\r\n\r\n### Object.getOwnPropertyDescriptors()\r\n\r\nObject에 기존에 있던 getOwnPropertyDescriptor에 이어 복수형 s가 붙은 getOwnPropertyDescriptors 메소드가 추가되었습니다.\r\n\r\n해당 메소드를 이해하기 위해서는 선행 지식으로 getOwnPropertyDescriptor가 무엇인지 알아야하며 속성 설명자의 네가지 속성을 알아야합니다. ([링크](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor) 참조)\r\n\r\n또한 Object.defineProperties() 같은 메소드를 알고 있어야 유용하게 활용할 방법이 생깁니다. 여기서는 자세한 설명없이 해당 메소드에 대해서만 설명합니다.\r\n\r\n```javascript\r\nObject.getOwnPropertyDescriptor(obj, prop)\r\n```\r\n\r\n기존의 getOwnPropertyDescriptor는 인자로 객체와 속성명을 전달해 해당 속성의 속성 설명자를 반환하는 메소드입니다.\r\n\r\n이제 여기서 설명하는 getOwnPropertyDescriptors는 속성명을 전달하지 않고 객체만 전달함으로 객체내의 모든 속성에 대한 속성 설명자를 반환합니다. \r\n\r\n```javascript\r\nObject.getOwnPropertyDescriptor(obj)\r\n```\r\n\r\n두개의 예제입니다.\r\n\r\n```javascript\r\nconsole.log(Object.getOwnPropertyDescriptor(obj1, \"name\"));\r\n// Object {value: \"Jhon\", writable: true, enumerable: true, configurable: true}\r\n\r\nconsole.log(Object.getOwnPropertyDescriptors(obj1));\r\n// Object {\r\n//   name: {value: \"Jhon\", writable: true, enumerable: true, configurable: true}, \r\n//   age: {value: 24, writable: true, enumerable: true, configurable: true}\r\n// }\r\n```\r\n\r\n### Trailing commas\r\n\r\n함수의 마지막 매개변수와 인자에도 콤마를 넣을 수 있습니다.\r\n\r\n아래와 같이 말이죠. 해당 기능이 왜 추가되었는지는 다양한 의견이 있습니다. 흥미가 있는 분들은 한번 검색해보세요.\r\n\r\n```javascript\r\nconst foo = (a, b, c,) => {}\r\n```\r\n\r\n### async/await\r\n\r\n사실상 ES2017의 핵심이라고 볼 수 있습니다. \r\n\r\n새로운 비동기 처리 함수로 기존의 Promise 보다 가독성이 좋은 코드를 작성할 수 있게 되었습니다. 선행적으로 비동기 처리에 대한 지식과 Promise의 이해가 필요합니다.\r\n\r\n해당 내용은 여기서 간단히 다루기에는 중요하고 내용이 길어 따로 포스팅을 할 예정입니다.\r\n\r\n아래 링크는 async/await를 설명한 캡틴판교님의 포스트입니다.\r\n\r\n[CAPTAIN PANGYO - 자바스크립트 async와 await](https://joshua1988.github.io/web-development/javascript/js-async-await/)\r\n\r\n<br/>\r\n\r\n## ES2018\r\n\r\n### Rest/Spread Properties\r\n\r\n기존의 배열에서 사용하던 rest/spread를 객체에서도 사용가능하게 되었습니다.\r\n\r\n```javascript\r\n// Rest\r\nconst { one, two, ...others } = { one: 1, two: 2, three: 3, four: 4, five: 5 }\r\nconsole.log(one, two, others); // 1 2 {three: 3, four: 4, five: 5}\r\n\r\n// Spread\r\nconst obj1 = {one, two, ... others};\r\nconsole.log(obj); // {one: 1, two: 2, three: 3, four: 4, five: 5}\r\n\r\nconst obj2 = { one: 100, five: 500 };\r\nconst obj3 = { five: 5000 };\r\nconst obj = { ...obj1, ...obj2, ...obj3};\r\nconsole.log(obj); // {one: 100, two: 2, three: 3, four: 4, five: 5000}\r\n```\r\n\r\n마지막 라인의 obj의 출력을 보면 같은 속성 이름에 대해서는 앞의 것을 뒤의 것이 덮어쓴다는 것을 알 수 있다.\r\n\r\n### Promise.prototype.finally()\r\n\r\nthen, catch, finally에서 Promise는 기존에 then과 catch만 가능했으나 이제 finally도 추가되었습니다.\r\n\r\n```javascript\r\nPromise.resolve('reslove')\r\n.then((res) => console.log('success'))\r\n.catch((err) => console.log('fail'))\r\n.finally(() => console.log('finally'))\r\n```\r\n\r\n### Asynchronous iteration\r\n\r\n비동기 이터러블 객체를 순회하는 것이 가능해졌습니다.\r\n\r\n이해를 위해서는 Promise, async/await의 이해가 선행됩니다.\r\n\r\n```javascript\r\nfor await (const req of requests) {\r\nconsole.log(req)\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n## ES2019\r\n\r\n### String.trimStart() & trimEnd()\r\n\r\n문자열의 앞이나 뒤의 공백을 제거한다.\r\n\r\n앞을 제거하는 trimStart와 뒤를 제거하는 trimEnd가 있다.\r\n\r\n아래 예제를 보면 쉽게 이해할 수 있다.\r\n\r\n```javascript\r\nconst s = \"     hello world\";\r\nconst e = \"!     \";\r\n\r\nconsole.log(s + e + ';');\r\n// \"     hello world!     ;\"\r\n\r\nconsole.log(s.trimStart() + e.trimEnd() + ';');\r\n// \"hello world!;\"\r\n```\r\n\r\n### Optional Catch Binding\r\n\r\ncatch 매개변수 없이도 catch 블록을 사용할 수 있습니다.\r\n\r\n```javascript\r\ntry {\r\n// some code\r\n}\r\ncatch (err) {\r\n// error handling code\r\n}\r\n```\r\n\r\n위와 같이 `catch(err){}` 또는 `catch(){}` 와 같이 사용하던 것을 아래와 같이 사용할 수 있습니다.\r\n\r\n```javascript\r\ntry {\r\n// some code\r\n}\r\ncatch {\r\n// error handling code\r\n}\r\n```\r\n\r\n### Object.fromEntries()\r\n\r\n위에서 설명한 `Object.entries()` 의 정반대입니다.\r\n\r\n객체를 entries로 배열로 만들었다면 fromEntries로 다시 객체로 만들 수 있다는 이야기입니다. entires를 이해했다면 간단하게 아래 예제를 통해 알 수 있습니다.\r\n\r\n```javascript\r\nconst obj1 = {name: \"Jhon\", age: 24};\r\n\r\nconst entries = Object.entries(obj1); \r\nconsole.log(entries); // [[\"name\", \"Jhone\"], [\"age\", 24]]\r\n\r\nconst fromEntries = Object.fromEntries(entries);\r\nconsole.log(fromEntries); // {name: \"Jhon\", age: 24}\r\n```\r\n\r\n### Array.flat() & flatMap()\r\n\r\nflat 메소드는 배열안의 배열을 쉽게 합칠 수 있게 됩니다.\r\n예제를 통해 쉽게 이해할 수 있습니다.\r\n\r\n```javascript\r\nconst arr = [1, , 2, [3, 4, [5, 6]]];\r\n\r\nconsole.log(arr.flat());  // [1, 2, 3, 4, [5, 6]]\r\nconsole.log(arr.flat(1)); // [1, 2, 3, 4, [5, 6]]\r\n\r\nconsole.log(arr.flat(2)); // [1, 2, 3, 4, 5, 6]\r\n```\r\n\r\nflat의 인자로는 배열의 깊이를 넘겨줄 수 있으며, 전달된 인자가 없을 경우 default는 1이다. 또한 빈 배열은 무시된다.\r\n\r\nflatMap 메소드는 `map()`과 `flat()`이 합쳐진 것으로 볼 수 있다. 우선 map을 통해 새로운 배열을 만들고 flat을 통해 배열이 합쳐진다. (flatMap의 깊이는 1입니다)\r\n\r\n```javascript\r\nconst arr = [1,2,3];\r\n\r\nconst map = arr.map(v => [v]);\r\nconst flatMap = arr.flatMap(v=> [v]);\r\n\r\nconsole.log(map);         // [[1], [2], [3]]\r\nconsole.log(map.flat());  // [1, 2, 3]\r\n\r\nconsole.log(flatMap);     // [1, 2, 3]\r\n```\r\n\r\n<br/>\r\n\r\n## ES2020\r\n\r\n### Dynamic Import\r\n\r\n파일 import를 동적으로 할 수 있게 되었습니다.\r\n\r\n아래 예제는 if문에 따라 import한 파일의 사용 유무가 달라지는데 조건에 맞지 않더라도 일단은 최상단의 import를 통해 파일을 불러옵니다.\r\n그러나 이제는 두번째 코드 예제와 같이 Dynamic Import로 인해 불필요한 동작을 줄일 수 있게 되었습니다.\r\n\r\n```javascript\r\nimport config from './config.js';\r\n\r\nif(response) {\r\nage = config.age;\r\n}\r\n\r\nif(response) {\r\nimport('./config.js')\r\n.then(config => {\r\n  age = config.age;\r\n  console.log(config);\r\n}\r\n}\r\n```\r\n\r\n참고로 Dynamic import 예제인 두번째 코드에서 console.log의 출력 결과는 `{age: 24, skills: [\"react\", \"webpack\"], default: \"Jhon\"}` 입니다.\r\n그렇다면 config 파일의 내용은 아래와 같습니다.\r\n\r\n```javascript\r\nexport const age = 24;\r\n\r\nexport const skills = [\"react\", \"webpack\"];\r\n\r\nexport default \"Jhon\";\r\n```\r\n\r\ndefault로 export를 한 것은 default라는 속성 이름을 가지는 것을 알아두세요.\r\n\r\n### BigInt\r\n\r\nBigInt는 `2^53` 보다 큰 정수를 취급하기 위해 등장했습니다.\r\n\r\n숫자 뒤에 n이 붙는 특징을 가지고 있습니다.\r\n예로 `10n` 은 숫자 `10`을 뜻한다는 의미입니다.\r\n\r\n자세한 예와 설명은 아래 예제로 설명하겠습니다.\r\n\r\n```javascript\r\nconst int1 = Number.MAX_SAFE_INTEGER + 1; \r\n// 9007199254740992\r\n\r\nconst int2 = Number.MAX_SAFE_INTEGER + 2; \r\n// 9007199254740992  <= ~993이 아니다.\r\n\r\nconst bigInt2 = BigInt(Number.MAX_SAFE_INTEGER) + 2n; \r\n// 9007199254740993n <= ~993이 되었다.\r\n\r\nconsole.log(typeof int1, typeof int2, typeof bigInt2); \r\n// number number bigint\r\n\r\nconsole.log(typeof 9007199254740993n); // bigint\r\nconsole.log(9007199254740993n === bigInt2); // true\r\n// 일반적인 숫자 뒤에 n을 붙이는 것으로 bitint 타입을 가진다는 것을 알 수 있습니다.\r\n\r\nconsole.log(BigInt(10), BigInt(10n));\r\n// 10n 10n <= BitInt의 인자로는 n의 여부가 중요하지 않다.\r\n\r\nconsole.log(10 === BigInt(10)); // false\r\nconsole.log(10 == BigInt(10)); // true\r\n\r\n// console.log(9007199254740993n + 1);\r\n// 위 코드는 에러가 발생한다. bigint를 연산할때는 number 타입과 섞어쓰는 것이 안된다.\r\n```\r\n\r\n### Promise.allSettled\r\n\r\n`Promise.all()`은 모든 작업이 성공(reslove)해야 실행되는 특징과 달리 `Promise.allSettled()`은 도중에 실패(reject)되더라도 모든 실행을 할 수 있습니다.\r\n\r\n아래 예제를 통해 코드와 실행 결과를 살펴봅시다.\r\n\r\n```javascript\r\nconst p1 = new Promise((resolve, reject) => resolve(\"p1, resolved\"));\r\nconst p2 = new Promise((resolve, reject) => resolve(\"p2, resolved\"));\r\nconst p3 = new Promise((resolve, reject) => reject(\"p3, rejected\"));\r\n\r\nPromise.all([p1, p2, p3])\r\n.then(response => console.log(response))\r\n.catch(err => {\r\nconsole.log(err);\r\n});\r\n/*\r\nconsole.log(response)\r\n{status: \"fulfilled\", value: \"p1, resolved\"}\r\n{status: \"fulfilled\", value: \"p2, resolved\"}\r\n{status: \"rejected\", reason: \"p3, rejected\"}\r\n*/\r\n\r\nPromise.allSettled([p1, p2, p3])\r\n.then(response => console.log(response))\r\n.catch(err => {\r\nconsole.log(err);\r\n});\r\n/*\r\nconsole.log(err);\r\np3, rejected\r\n*/\r\n```\r\n\r\n### Nullish Coalescing Operator\r\n\r\n`a ?? b` 로 나타내는 연산자입니다. `null`이나 `undefined`일 때만 `b`를 반환합니다.\r\n\r\n0은 false를 의미하기도 합니다.\r\n따라서 `0 || 'A'` 는 `A` 가 될겁니다. \r\n하지만 0이 의미있는 값이면 0 또한 사용해야 할 것입니다.\r\n또한 삼항 연산자를 단축시켜 사용할 수 있는 장점도 있습니다.\r\n\r\n예제를 통해 살펴봅시다.\r\n\r\n```javascript\r\n0 || 'A'    // A\r\n0 ?? 'A'    // 0\r\n\r\n0 ? 0 : 'A' // A\r\n0 ?? 'A'    // 0\r\n```\r\n\r\n### Optional Chaining\r\n\r\n`foo.a.b` 에 접근한다고 했을 때, `a`가 없다면 오류가 발생하게 됩니다.\r\n\r\n따라서 오류를 방지하기 위해 `if(foo.a && foo.a.b)` 와 같이 사용하곤 합니다.\r\n\r\n하지만 Optional Chaining을 이용하면 오류가 발생하지 않고 undefined를 반환받습니다.\r\n\r\nOptional Chaining은 `foo.a?.b` 와 같이 표현합니다.\r\n\r\n```javascript\r\nconst foo = {\r\na: {\r\nb: true\r\n}\r\n};\r\n\r\nconsole.log(foo.a.b); // true\r\nconsole.log(foo.b?.b); // undefined\r\n\r\nconsole.log(foo.b.aa); // TypeError: Cannot read property 'aa' of undefined\r\n```","excerpt":"2020년을 맞아 이미 많이 알고 있는 ES2015(ES6) 다음부터인 ES2016부터 ES202…","fields":{"slug":"/es2016-es2020/"},"frontmatter":{"date":"Jan 22, 2020","title":"ECMAScript ES2016~ES2020 정리","tags":["javascript"],"update":"Feb 06, 2020"}}}]}},"pageContext":{}}}