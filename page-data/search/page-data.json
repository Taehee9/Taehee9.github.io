{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n2020년을 맞아 이미 많이 알고 있는 ES2015(ES6) 다음부터인 ES2016부터 ES2020까지 새로 나온 자바스크립트 기능들을 살펴보려고 합니다. \r\n\r\n모두 소개하는 건 아니고 비교적 도움이 되는, 대표적인 것들을 추려 소개합니다.  \r\n또한 기초적인 사전 지식의 설명은 생략될 수 있습니다.\r\n\r\n<br/>\r\n\r\n## ES2016\r\n\r\n### Array.prototype.includes\r\n\r\n배열 내장 함수 includes가 추가되었습니다.\r\n\r\n```javascript\r\n['a', 'b', 'c'].includes('a') // true\r\n```\r\n\r\n코드를 보면 쉽게 역할을 알 수 있습니다.\r\n배열에 아이템이 존재하는지 Boolean 값을 반환합니다.\r\n\r\n이 함수로 이제 `['a','b','c'].indexOf('a') > -1` 대신 좀 더 간결한 코드가 가능합니다.\r\n\r\n### Exponentiation operator\r\n\r\n제곱 연산자.\r\n기존에 제곱은 Math의 pow 함수를 이용했을 것입니다. \r\n이제는 간단하게 `**` 연산자로 가능하게 되었습니다.\r\n\r\n```javascript\r\nlet num = 2;\r\n\r\nMath.pow(num, 10); // 1024\r\n2 ** 10; // 1024\r\n\r\nnum **= 10;\r\nnum; // 1024\r\n```\r\n\r\n<br/>\r\n\r\n## ES2017\r\n\r\n### String padding\r\n\r\n문자열에 여백을 주기 위해 등장한 기능입니다. \r\n여백 뿐만 아니라 그 여백에 보충 문자를 추가할 수 있습니다.\r\n\r\n여백을 앞에 뒤에 추가할 수 있게 됩니다.\r\n\r\n```javascript\r\npadStart(targetLength [, padString])\r\npadEnd(targetLength [, padString])\r\n```\r\n\r\n간단한 예를 통해 살펴보겠습니다. start와 end의 차이는 앞뒤의 차이밖에 없으니 start만 살펴봅니다.\r\n\r\n`1월` 을 `01월` 과 같이 길이를 맞춰야 할 경우가 있다 이럴때 사용 할 수 있습니다.\r\n\r\n```javascript\r\n`1월`.padStart(1);        // \"1월\"\r\n`1월`.padStart(3);        // \" 1월\"\r\n`1월`.padStart(3, \"0\");   // \"01월\"\r\n`1월`.padStart(7, \"0AB\"); // \"0AB0A1월\"\r\n```\r\n\r\n1번째 라인처럼 문자열보다 작은 수를 지정하더라도 문자열이 잘리거나 하진 않습니다\r\n\r\n2번째 라인은 문자열의 길이보다 하나 긴 3을 넣어 하나의 여백이 추가된 모습입니다.\r\n\r\n3번째 라인이 원하는 의도인 코드입니다.\r\n\r\n4번째 라인처럼 보충 문자를 배열로 작성하면 배열을 순회 반복하며 여백을 채우며 0, A, B를 채우고 다음으로 0, A까지 채워진 모습을 볼 수 있습니다.\r\n\r\n### Object.values()\r\n\r\nObject에 추가된 values 메소드는 객체의 key:value 에서 value 값들을 배열으로 반환합니다.\r\n\r\n```javascript\r\nconst obj1 = {name: \"Jhon\", age: 24};\r\nObject.values(obj1); // [\"Jhon\", 24]\r\n```\r\n\r\n### Object.entries()\r\n\r\n객체 안의 모든 속성을 각각 key, value가 담긴 배열로 하나의 배열에 담습니다.\r\n[[key, value], [key, value], [key, value] ...]\r\n\r\n```javascript\r\nconst obj1 = {name: \"Jhon\", age: 24};\r\n\r\nObject.keys(obj1);    // [\"name\", \"age\"]\r\nObject.values(obj1);  // [\"Jhon\", 24]\r\n\r\nObject.entries(obj1); // [[\"name\", \"Jhone\"], [\"age\", 24]]\r\n```\r\n\r\n### Object.getOwnPropertyDescriptors()\r\n\r\nObject에 기존에 있던 getOwnPropertyDescriptor에 이어 복수형 s가 붙은 getOwnPropertyDescriptors 메소드가 추가되었습니다.\r\n\r\n해당 메소드를 이해하기 위해서는 선행 지식으로 getOwnPropertyDescriptor가 무엇인지 알아야하며 속성 설명자의 네가지 속성을 알아야합니다. ([링크](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor) 참조)\r\n\r\n또한 Object.defineProperties() 같은 메소드를 알고 있어야 유용하게 활용할 방법이 생깁니다. 여기서는 자세한 설명없이 해당 메소드에 대해서만 설명합니다.\r\n\r\n```javascript\r\nObject.getOwnPropertyDescriptor(obj, prop)\r\n```\r\n\r\n기존의 getOwnPropertyDescriptor는 인자로 객체와 속성명을 전달해 해당 속성의 속성 설명자를 반환하는 메소드입니다.\r\n\r\n이제 여기서 설명하는 getOwnPropertyDescriptors는 속성명을 전달하지 않고 객체만 전달함으로 객체내의 모든 속성에 대한 속성 설명자를 반환합니다. \r\n\r\n```javascript\r\nObject.getOwnPropertyDescriptor(obj)\r\n```\r\n\r\n두개의 예제입니다.\r\n\r\n```javascript\r\nconsole.log(Object.getOwnPropertyDescriptor(obj1, \"name\"));\r\n// Object {value: \"Jhon\", writable: true, enumerable: true, configurable: true}\r\n\r\nconsole.log(Object.getOwnPropertyDescriptors(obj1));\r\n// Object {\r\n//   name: {value: \"Jhon\", writable: true, enumerable: true, configurable: true}, \r\n//   age: {value: 24, writable: true, enumerable: true, configurable: true}\r\n// }\r\n```\r\n\r\n### Trailing commas\r\n\r\n함수의 마지막 매개변수와 인자에도 콤마를 넣을 수 있습니다.\r\n\r\n아래와 같이 말이죠. 해당 기능이 왜 추가되었는지는 다양한 의견이 있습니다. 흥미가 있는 분들은 한번 검색해보세요.\r\n\r\n```javascript\r\nconst foo = (a, b, c,) => {}\r\n```\r\n\r\n### async/await\r\n\r\n사실상 ES2017의 핵심이라고 볼 수 있습니다. \r\n\r\n새로운 비동기 처리 함수로 기존의 Promise 보다 가독성이 좋은 코드를 작성할 수 있게 되었습니다. 선행적으로 비동기 처리에 대한 지식과 Promise의 이해가 필요합니다.\r\n\r\n해당 내용은 여기서 간단히 다루기에는 중요하고 내용이 길어 따로 포스팅을 할 예정입니다.\r\n\r\n아래 링크는 async/await를 설명한 캡틴판교님의 포스트입니다.\r\n\r\n[CAPTAIN PANGYO - 자바스크립트 async와 await](https://joshua1988.github.io/web-development/javascript/js-async-await/)\r\n\r\n<br/>\r\n\r\n## ES2018\r\n\r\n### Rest/Spread Properties\r\n\r\n기존의 배열에서 사용하던 rest/spread를 객체에서도 사용가능하게 되었습니다.\r\n\r\n```javascript\r\n// Rest\r\nconst { one, two, ...others } = { one: 1, two: 2, three: 3, four: 4, five: 5 }\r\nconsole.log(one, two, others); // 1 2 {three: 3, four: 4, five: 5}\r\n\r\n// Spread\r\nconst obj1 = {one, two, ... others};\r\nconsole.log(obj); // {one: 1, two: 2, three: 3, four: 4, five: 5}\r\n\r\nconst obj2 = { one: 100, five: 500 };\r\nconst obj3 = { five: 5000 };\r\nconst obj = { ...obj1, ...obj2, ...obj3};\r\nconsole.log(obj); // {one: 100, two: 2, three: 3, four: 4, five: 5000}\r\n```\r\n\r\n마지막 라인의 obj의 출력을 보면 같은 속성 이름에 대해서는 앞의 것을 뒤의 것이 덮어쓴다는 것을 알 수 있다.\r\n\r\n### Promise.prototype.finally()\r\n\r\nthen, catch, finally에서 Promise는 기존에 then과 catch만 가능했으나 이제 finally도 추가되었습니다.\r\n\r\n```javascript\r\nPromise.resolve('reslove')\r\n.then((res) => console.log('success'))\r\n.catch((err) => console.log('fail'))\r\n.finally(() => console.log('finally'))\r\n```\r\n\r\n### Asynchronous iteration\r\n\r\n비동기 이터러블 객체를 순회하는 것이 가능해졌습니다.\r\n\r\n이해를 위해서는 Promise, async/await의 이해가 선행됩니다.\r\n\r\n```javascript\r\nfor await (const req of requests) {\r\nconsole.log(req)\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n## ES2019\r\n\r\n### String.trimStart() & trimEnd()\r\n\r\n문자열의 앞이나 뒤의 공백을 제거한다.\r\n\r\n앞을 제거하는 trimStart와 뒤를 제거하는 trimEnd가 있다.\r\n\r\n아래 예제를 보면 쉽게 이해할 수 있다.\r\n\r\n```javascript\r\nconst s = \"     hello world\";\r\nconst e = \"!     \";\r\n\r\nconsole.log(s + e + ';');\r\n// \"     hello world!     ;\"\r\n\r\nconsole.log(s.trimStart() + e.trimEnd() + ';');\r\n// \"hello world!;\"\r\n```\r\n\r\n### Optional Catch Binding\r\n\r\ncatch 매개변수 없이도 catch 블록을 사용할 수 있습니다.\r\n\r\n```javascript\r\ntry {\r\n// some code\r\n}\r\ncatch (err) {\r\n// error handling code\r\n}\r\n```\r\n\r\n위와 같이 `catch(err){}` 또는 `catch(){}` 와 같이 사용하던 것을 아래와 같이 사용할 수 있습니다.\r\n\r\n```javascript\r\ntry {\r\n// some code\r\n}\r\ncatch {\r\n// error handling code\r\n}\r\n```\r\n\r\n### Object.fromEntries()\r\n\r\n위에서 설명한 `Object.entries()` 의 정반대입니다.\r\n\r\n객체를 entries로 배열로 만들었다면 fromEntries로 다시 객체로 만들 수 있다는 이야기입니다. entires를 이해했다면 간단하게 아래 예제를 통해 알 수 있습니다.\r\n\r\n```javascript\r\nconst obj1 = {name: \"Jhon\", age: 24};\r\n\r\nconst entries = Object.entries(obj1); \r\nconsole.log(entries); // [[\"name\", \"Jhone\"], [\"age\", 24]]\r\n\r\nconst fromEntries = Object.fromEntries(entries);\r\nconsole.log(fromEntries); // {name: \"Jhon\", age: 24}\r\n```\r\n\r\n### Array.flat() & flatMap()\r\n\r\nflat 메소드는 배열안의 배열을 쉽게 합칠 수 있게 됩니다.\r\n예제를 통해 쉽게 이해할 수 있습니다.\r\n\r\n```javascript\r\nconst arr = [1, , 2, [3, 4, [5, 6]]];\r\n\r\nconsole.log(arr.flat());  // [1, 2, 3, 4, [5, 6]]\r\nconsole.log(arr.flat(1)); // [1, 2, 3, 4, [5, 6]]\r\n\r\nconsole.log(arr.flat(2)); // [1, 2, 3, 4, 5, 6]\r\n```\r\n\r\nflat의 인자로는 배열의 깊이를 넘겨줄 수 있으며, 전달된 인자가 없을 경우 default는 1이다. 또한 빈 배열은 무시된다.\r\n\r\nflatMap 메소드는 `map()`과 `flat()`이 합쳐진 것으로 볼 수 있다. 우선 map을 통해 새로운 배열을 만들고 flat을 통해 배열이 합쳐진다. (flatMap의 깊이는 1입니다)\r\n\r\n```javascript\r\nconst arr = [1,2,3];\r\n\r\nconst map = arr.map(v => [v]);\r\nconst flatMap = arr.flatMap(v=> [v]);\r\n\r\nconsole.log(map);         // [[1], [2], [3]]\r\nconsole.log(map.flat());  // [1, 2, 3]\r\n\r\nconsole.log(flatMap);     // [1, 2, 3]\r\n```\r\n\r\n<br/>\r\n\r\n## ES2020\r\n\r\n### Dynamic Import\r\n\r\n파일 import를 동적으로 할 수 있게 되었습니다.\r\n\r\n아래 예제는 if문에 따라 import한 파일의 사용 유무가 달라지는데 조건에 맞지 않더라도 일단은 최상단의 import를 통해 파일을 불러옵니다.\r\n그러나 이제는 두번째 코드 예제와 같이 Dynamic Import로 인해 불필요한 동작을 줄일 수 있게 되었습니다.\r\n\r\n```javascript\r\nimport config from './config.js';\r\n\r\nif(response) {\r\nage = config.age;\r\n}\r\n\r\nif(response) {\r\nimport('./config.js')\r\n.then(config => {\r\n  age = config.age;\r\n  console.log(config);\r\n}\r\n}\r\n```\r\n\r\n참고로 Dynamic import 예제인 두번째 코드에서 console.log의 출력 결과는 `{age: 24, skills: [\"react\", \"webpack\"], default: \"Jhon\"}` 입니다.\r\n그렇다면 config 파일의 내용은 아래와 같습니다.\r\n\r\n```javascript\r\nexport const age = 24;\r\n\r\nexport const skills = [\"react\", \"webpack\"];\r\n\r\nexport default \"Jhon\";\r\n```\r\n\r\ndefault로 export를 한 것은 default라는 속성 이름을 가지는 것을 알아두세요.\r\n\r\n### BigInt\r\n\r\nBigInt는 `2^53` 보다 큰 정수를 취급하기 위해 등장했습니다.\r\n\r\n숫자 뒤에 n이 붙는 특징을 가지고 있습니다.\r\n예로 `10n` 은 숫자 `10`을 뜻한다는 의미입니다.\r\n\r\n자세한 예와 설명은 아래 예제로 설명하겠습니다.\r\n\r\n```javascript\r\nconst int1 = Number.MAX_SAFE_INTEGER + 1; \r\n// 9007199254740992\r\n\r\nconst int2 = Number.MAX_SAFE_INTEGER + 2; \r\n// 9007199254740992  <= ~993이 아니다.\r\n\r\nconst bigInt2 = BigInt(Number.MAX_SAFE_INTEGER) + 2n; \r\n// 9007199254740993n <= ~993이 되었다.\r\n\r\nconsole.log(typeof int1, typeof int2, typeof bigInt2); \r\n// number number bigint\r\n\r\nconsole.log(typeof 9007199254740993n); // bigint\r\nconsole.log(9007199254740993n === bigInt2); // true\r\n// 일반적인 숫자 뒤에 n을 붙이는 것으로 bitint 타입을 가진다는 것을 알 수 있습니다.\r\n\r\nconsole.log(BigInt(10), BigInt(10n));\r\n// 10n 10n <= BitInt의 인자로는 n의 여부가 중요하지 않다.\r\n\r\nconsole.log(10 === BigInt(10)); // false\r\nconsole.log(10 == BigInt(10)); // true\r\n\r\n// console.log(9007199254740993n + 1);\r\n// 위 코드는 에러가 발생한다. bigint를 연산할때는 number 타입과 섞어쓰는 것이 안된다.\r\n```\r\n\r\n### Promise.allSettled\r\n\r\n`Promise.all()`은 모든 작업이 성공(reslove)해야 실행되는 특징과 달리 `Promise.allSettled()`은 도중에 실패(reject)되더라도 모든 실행을 할 수 있습니다.\r\n\r\n아래 예제를 통해 코드와 실행 결과를 살펴봅시다.\r\n\r\n```javascript\r\nconst p1 = new Promise((resolve, reject) => resolve(\"p1, resolved\"));\r\nconst p2 = new Promise((resolve, reject) => resolve(\"p2, resolved\"));\r\nconst p3 = new Promise((resolve, reject) => reject(\"p3, rejected\"));\r\n\r\nPromise.all([p1, p2, p3])\r\n.then(response => console.log(response))\r\n.catch(err => {\r\nconsole.log(err);\r\n});\r\n/*\r\nconsole.log(response)\r\n{status: \"fulfilled\", value: \"p1, resolved\"}\r\n{status: \"fulfilled\", value: \"p2, resolved\"}\r\n{status: \"rejected\", reason: \"p3, rejected\"}\r\n*/\r\n\r\nPromise.allSettled([p1, p2, p3])\r\n.then(response => console.log(response))\r\n.catch(err => {\r\nconsole.log(err);\r\n});\r\n/*\r\nconsole.log(err);\r\np3, rejected\r\n*/\r\n```\r\n\r\n### Nullish Coalescing Operator\r\n\r\n`a ?? b` 로 나타내는 연산자입니다. `null`이나 `undefined`일 때만 `b`를 반환합니다.\r\n\r\n0은 false를 의미하기도 합니다.\r\n따라서 `0 || 'A'` 는 `A` 가 될겁니다. \r\n하지만 0이 의미있는 값이면 0 또한 사용해야 할 것입니다.\r\n또한 삼항 연산자를 단축시켜 사용할 수 있는 장점도 있습니다.\r\n\r\n예제를 통해 살펴봅시다.\r\n\r\n```javascript\r\n0 || 'A'    // A\r\n0 ?? 'A'    // 0\r\n\r\n0 ? 0 : 'A' // A\r\n0 ?? 'A'    // 0\r\n```\r\n\r\n### Optional Chaining\r\n\r\n`foo.a.b` 에 접근한다고 했을 때, `a`가 없다면 오류가 발생하게 됩니다.\r\n\r\n따라서 오류를 방지하기 위해 `if(foo.a && foo.a.b)` 와 같이 사용하곤 합니다.\r\n\r\n하지만 Optional Chaining을 이용하면 오류가 발생하지 않고 undefined를 반환받습니다.\r\n\r\nOptional Chaining은 `foo.a?.b` 와 같이 표현합니다.\r\n\r\n```javascript\r\nconst foo = {\r\na: {\r\nb: true\r\n}\r\n};\r\n\r\nconsole.log(foo.a.b); // true\r\nconsole.log(foo.b?.b); // undefined\r\n\r\nconsole.log(foo.b.aa); // TypeError: Cannot read property 'aa' of undefined\r\n```","excerpt":"2020년을 맞아 이미 많이 알고 있는 ES2015(ES6) 다음부터인 ES2016부터 ES202…","fields":{"slug":"/es2016-es2020/"},"frontmatter":{"date":"Jan 22, 2020","title":"ECMAScript ES2016~ES2020 정리","tags":["javascript"],"update":"Feb 06, 2020"}}},{"node":{"rawMarkdownBody":"\r\n뒤늦은 Hooks 포스팅입니다. Hooks 기본을 정리해보고, 사용해오면서 알게 된 점도 정리해봅니다.  \r\n간단히 useState에 대해 설명하고, useEffect에 대해서는 조금 더 자세하게 알아봅니다.\r\n\r\n---\r\n\r\nHooks는 React 16.8부터 등장한 새로운 기능입니다.  \r\nClass Component가 아니더라도 Functional Component에서 state 및 기타 기능을 사용할 수 있게 합니다.\r\n\r\n아래는 리액트 공식 문서의 Hooks 설명 일부입니다.\r\n\r\n> Hook는 알고 있는 React 컨셉을 대체하지 않습니다. 대신에, Hook는 props, state, context, refs, 그리고 lifecycle와 같은 React 개념에 좀 더 직관적인 API를 제공합니다. 또한 Hook는 이 개념들을 엮기 위해 새로운 강력한 방법을 제공합니다.\r\n\r\n일반적으로 Functional Component를 사용하게 되면 state를 사용할 수 없고 React LifeCycle을 사용할 수 없다는 한계에 부딪치게 되는데 Hooks의 등장으로 새로운 방법이 제공됩니다. (Effect Hooks 부분에서 자세히 알아봅니다)\r\n\r\n## useState()\r\n\r\n기존의 Class Component에서 사용하던 것을 보면 아래와 같습니다.\r\n\r\n```js\r\nclass Example extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      count: 0\r\n    };\r\n  }\r\n```\r\n\r\n위와 같이 state를 선언하고 `this.setState({ count: 1 })`와 같이 setState 함수를 통해 state 값을 변경할 것입니다.\r\n\r\n기존의 state를 다루는 방법은 useState Hooks를 이용하게 됩니다.  \r\n아래의 코드는 useState를 사용한 예제입니다.\r\n\r\n```js\r\nimport React, { useState } from 'react';\r\n\r\nconst Example = () => {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <p>You clicked {count} times</p>\r\n      <button onClick={() => setCount(count + 1)}>Click me</button>\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\nuseState는 아래와 같이 사용합니다.\r\n\r\n```js\r\nconst [count, setCount] = useState(0);\r\n```\r\n\r\n`useState()`가 `count`, `setCount`로 [구조 분해 할당](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment '구조 분해 할당')되어있습니다.  \r\nuseState는 state 변수와 해당 변수를 변경할 수 있는 함수(즉, setState 함수)를 반환합니다.  \r\n따라서 아래와 같은 방법으로도 사용할 수 있습니다. 이렇게 사용할 일은 없겠지만 말입니다.\r\n\r\n```js\r\nconst countVariables = useState(0);\r\n\r\ncountVariables[1](20); // == setCount\r\nconsole.log(countVariables[0]); // 20, == count\r\n```\r\n\r\nClass Component 방식에서 사용하던 setState를 통해서는 기존의 state와 새로운 state를 합치는 방법으로 state 값이 변경되었으나, useState를 사용한 setState인 예제에서 setCount를 통해서는 state를 합치는 방식이 아닌 count state만을 변경하게 됩니다.\r\n\r\n### 요약\r\n\r\n#### 선언\r\n\r\n```js\r\nimport React, { useState } from 'react';\r\n\r\nconst Example = () => {\r\n  const [count, setCount] = useState(0);\r\n  //...\r\n```\r\n\r\n#### 갱신\r\n\r\n```js\r\n<button onClick={() => setCount(count + 1)}>\r\n// or\r\n<button onClick={() => setCount(prevCount => prevCount + 1)}>\r\n  // 기존의 setState 함수와 유사하게 prevState를 사용할 수 있습니다.\r\n```\r\n\r\n#### state 사용, 가져오기\r\n\r\n```js\r\n<p>You clicked {count} times</p>\r\n```\r\n\r\n## useEffect()\r\n\r\nuseState는 간단하고 사용하기 쉽습니다.  \r\nuseEffect는 간단한 사용은 쉬울지 모르나, 제대로 동작을 이해하려면 깊게 공부가 필요해보입니다. 따라서 여기서는 사용함에 있어 햇갈리지 않고 오류를 범하지 않으면서 기본적인 동작을 이해하는 수준에서 기술하겠습니다. 기존 Class Component의 Life Cycle을 이해하고 있다는 전제하에 진행합니다.\r\n\r\n아래 코드를 보겠습니다.\r\n\r\n```js\r\nimport React, { useEffect, useState } from 'react';\r\n\r\nexport const FuncComp = () => {\r\n  const [count1, setCount1] = useState(0);\r\n  const [count2, setCount2] = useState(0);\r\n\r\n  useEffect(() => {\r\n    console.log('useEffect');\r\n  });\r\n\r\n  return (\r\n    <div>\r\n      <button\r\n        onClick={() => {\r\n          setCount1(count1 + 1);\r\n        }}\r\n      >\r\n        FuncComp>count1 + (current: {count1})\r\n      </button>\r\n\r\n      <button\r\n        onClick={() => {\r\n          setCount2(count2 + 1);\r\n        }}\r\n      >\r\n        FuncComp>count2 + (current: {count2})\r\n      </button>\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\n해당 코드는 count1, count2의 state를 가지고 있습니다.  \r\n그리고 각각의 state를 변경(증가)하는 버튼이 위치합니다.\r\n\r\nuseEffect가 위치한 곳을 봐주세요.  \r\n여기서 useEffect의 안에 함수가 실행되는 시점.  \r\n즉, console.log가 작동하는 시점을 기존 Class Component의 LifeCycle의 관점에서 보면 아래와 같습니다.\r\n\r\n- componentDidMount\r\n- componentDidUpdate\r\n\r\n마운트와 업데이트 시점에서 “useEffect” 문구가 출력되게 됩니다.  \r\n위의 예에서는 첫 로드시, `count1` `count2`가 업데이트 될 때 출력됩니다.\r\n\r\n간단히 보자면 위 useEffect안의 함수는 “매 렌더링마다 실행된다”라고 생각하면 쉽습니다.\r\nprops, state가 변경될때마다 렌더링이 실행될테니말입니다.\r\n\r\n### 의존성 추가\r\n\r\n이제 아래 코드를 살펴보겠습니다.\r\n\r\n```js\r\nuseEffect(() => {\r\n  console.log('useEffect');\r\n}, [count1]);\r\n```\r\n\r\n`useEffect(fn)`형태에서 `useEffect(fn, [])`가 되어 인자로 배열이 추가되었습니다.\r\n\r\n여기서 배열은 **의존성**을 담은 배열로,  \r\n위와 같이 `count1`을 담는다면 이제 마운트시에 호출되고, 그 후로는 `count1`이 변경될때만 호출되어 “useEffect”문구가 출력될 것입니다.\r\n\r\n위의 예제에서 `count1`을 증가시키는 버튼을 누르면 “useEffect”문구가 출력될것이고, `count2`에서는 출력되지 않습니다.\r\n\r\n여기서 의존성 배열을 비운다면 어떻게 될까요\r\n\r\n```js\r\nuseEffect(() => {\r\n  console.log('useEffect');\r\n}, []);\r\n```\r\n\r\n위의 코드는 간단하게 말하면 componentDidMount의 역활을 대체할 수 있습니다.  \r\n의존성 배열 자체를 인자로 넘기지 않으면 모든 state(+props)가 변경될 때 호출되게 되지만 넘긴다면 해당 의존성이 변경될때 호출되게 되고 비어있다면 마운트시에만 호출되게 되는 것입니다.  \r\n따라서 componentDidMount를 구현하고 싶다면 해당 코드와 같이 작성하면 됩니다.\r\n\r\n### CleanUp\r\n\r\n아래 코드를 살펴봅시다. 의존성으로 `count1`을 가진 이펙트입니다.\r\n\r\n```js\r\nuseEffect(() => {\r\n  console.log('count1', count);\r\n\r\n  return () => {\r\n    console.log('count1 CleanUp', count);\r\n  };\r\n}, [count]);\r\n```\r\n\r\n위의 코드를 보면 return 라인이 추가되어 함수를 반환합니다.\r\n\r\n마운트 시, 그리고 `count1`에 변동이 있을 때 “count1” 문구가 출력될 것을 예상할 수 있습니다.\r\n“count1 CleanUp”은 언제 출력될까요?\r\n\r\n일단 마운트가 되면 “count1”이 출력됩니다.\r\n그 후 count1을 증가시키게되면 아래와 같은 과정을 거치게됩니다.  \r\n증가시키기 전인 count 값은 0입니다.  \r\n(이해를 위한 과정 설명으로 실제 작동은 이와 다를 수 있습니다)\r\n\r\n1. count = 0인 해당 이펙트(위의 코드) 클린업 과정 실행\r\n2. count = 1에 해당하는 렌더링\r\n3. count = 1에 해당하는 이펙트 실행\r\n   이를 통해 업데이트 이전에 클린업이 실행된다는 사실을 알고있으면 됩니다.\r\n\r\n또한 클린업은 언마운트시에도 작동하게 됩니다.\r\n따라서 만약 해당 컴포넌트가 언마운트되면 위 코드의 클린업도 실행되게 됩니다.\r\n\r\n아래 코드를 살펴보겠습니다.\r\n\r\n```js\r\nuseEffect(() => {\r\n  console.log('mount');\r\n\r\n  return () => {\r\n    console.log('unmount');\r\n  };\r\n}, []);\r\n\r\nuseEffect(() => {\r\n  console.log('update count1');\r\n\r\n  return () => {\r\n    console.log('update count1 or unmount');\r\n  };\r\n}, [count]);\r\n```\r\n\r\n코드의 첫번째 이펙트는 componentDidMount의 기능을 한다고 설명했던 코드입니다.  \r\n두번째 이펙트는 바로 위에서 살펴본 코드와 같습니다.\r\n\r\n아래의 동작을 하면 어떤 순서로 출력문이 나올지 보겠습니다.\r\n\r\n1. 페이지 로드 (컴포넌트 마운트)\r\n2. count1 증가 버튼 클릭\r\n3. 해당 컴포넌트 사라지게함 (언마운트)\r\n\r\n```shell\r\n< \"mount\"\r\n< \"update count1\"\r\n< \"update count1 or unmount\"\r\n< \"update count1\"\r\n< \"update count1 or unmount\"\r\n< \"unmount\"\r\n```\r\n\r\n1~2라인은 마운트에 해당하는 출력입니다.  \r\n3~4라인은 `count1`값을 업데이트하면서 클린업-\\>이펙트의 과정을 거친 출력입니다.  \r\n5~6라인은 컴포넌트가 언마운트되면서 이펙트들의 클린업이 실행된 출력입니다.\r\n\r\n6라인을 보아 해당 이펙트(빈 의존성 배열)의 클린업은 componentWillUnmount의 기능을 하는 것을 알 수 있습니다.\r\n\r\n클린업은 DOM에 추가한 이벤트 리스너를 컴포넌트가 언마운트될때 제거할 경우 등의 경우에서 사용되게 될겁니다.\r\n\r\n### 요약\r\n\r\n**Mount (componentDidMount)**\r\n\r\n```js\r\nuseEffect(() => console.log('mount'), []);\r\n```\r\n<br/>\r\n\r\n**Unmount (componentWillUnmount)**\r\n\r\n```js\r\nuseEffect(() => () => console.log('unmount'), []);\r\n```\r\n<br/>\r\n\r\n**Update Any**\r\n\r\n```js\r\nuseEffect(() => console.log('will update any'));\r\n```\r\n<br/>\r\n\r\n**Update Any or Unmount**\r\n\r\n```js\r\nuseEffect(() => () => console.log('will update any or unmount'));\r\n```\r\n<br/>\r\n\r\n**Update `Count`**\r\n\r\n```js\r\nuseEffect(() => console.log('will update count'), [count]);\r\n```\r\n<br/>\r\n\r\n**Update `Count` or Unmount**\r\n\r\n```js\r\nuseEffect(() => () => console.log('will update count or unmount'), [count]);\r\n```\r\n<br/>\r\n<br/>\r\n\r\n---\r\n<br/>\r\n\r\n**References**\r\n\r\n- [React Document | Hooks](https://reactjs.org/docs/hooks-intro.html 'React Document | Hooks')\r\n- [stackoverflow | react hooks useEffect() cleanup for only componentWillUnmount?](https://stackoverflow.com/a/55041347)\r\n","excerpt":"뒤늦은 Hooks 포스팅입니다. Hooks 기본을 정리해보고, 사용해오면서 알게 된 점도 정리해봅니다. 간단히 useState에 대해 설명하고, useEffect에 대해서는 조금 더 자세하게 알아봅니다. Hooks는 React 16.…","fields":{"slug":"/react-hooks/"},"frontmatter":{"date":"Jan 08, 2020","title":"React Hooks: useState, useEffect 알아보기","tags":["react"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n**지금 이 글을 보고 있는 블로그는 Borderless 테마를 사용하고 있는 블로그입니다.**\r\n\r\n_Gatsby를 이용해 제작되었으며 Gatsby에 대한 간략한 설명은 이전 글([Gatsby로 블로그 만들기](/create-gatsby-blog))에서 확인 할 수 있습니다._\r\n\r\n**[Borderless 블로그 - 소개](/develop-blog-v3_2)**에서 borderless 테마의 기능과 특징을 확인하세요.\r\n\r\n이 블로그와 같은 블로그를 만들고 싶다면 이 글을 간략하게 참고하시고,  \r\n**[Documents](<https://github.com/junhobaik/junhobaik.github.io/wiki/Document-(Borderless)>)**에서 자세한 방법을 참고하세요.\r\n\r\n---\r\n\r\n_\\* 아래 설명과 문서는 Github Pages에 배포되는 것을 기준으로 설명합니다._  \r\n_\\* 이 글에서는 매우 간략하게 방법을 기술하고 있습니다. 자세한 것은 문서에서 확인하세요_\r\n\r\n## Install\r\n\r\n해당 블로그로 시작하기 위한 방법은 두가지가 있습니다.\r\n\r\n1. 테마 Repository Fork 후 사용\r\n1. 테마 Repository Clone 후 사용\r\n\r\n### 1. **Fork**로 시작하기\r\n\r\n- 해당 Repository를 Fork 한 후,\r\n\r\n1. Repository의 이름을 \"**username**.github.io\"로 변경합니다.\r\n1. `Setting > Branches - Default branch`에서 기본 Branch를 변경합니다. **develop**를 선택하고 Update 버튼을 눌러 진행하세요.\r\n1. 이제 본인의 Repository를 Clone 합니다.\r\n1. `$ npm i` 명령어로 패키지 설치\r\n1. `$ npm start` 명령어로 개발 서버 시작  \r\n   \"localhost:8000\"에서 확인할 수 있습니다.\r\n\r\n### 2. **Clone**으로 시작하기\r\n\r\n```shell\r\n$ git clone -b develop https://github.com/junhobaik/junhobaik.github.io.git [SITE_DIRECTORY]\r\n$ npm install\r\n```\r\n\r\n위의 과정을 통해 develop 브랜치를 기본으로 해당 저장소를 클론하고 필요한 패키지를 설치합니다.\r\n\r\n```shell\r\n$ npm start\r\n```\r\n\r\n개발 서버를 실행하며 localhost:8000에서 확인할 수 있습니다.\r\n\r\n## Basic Settings\r\n\r\n`./config.js` 파일을 개인에 맞춰 수정합니다.  \r\n문자열은 ''로 비워두어 해당 기능을 비활성화 할 수 있습니다. (Site MetaData는 필수로 작성)\r\n\r\n아래는 예제입니다.\r\n\r\n```javascript\r\nmodule.exports = {\r\n  /** Site MetaData (Required all)*/\r\n  title: `Dev.White`,\r\n  description: `Junho Baik's Development Blog`,\r\n  author: `Junho Baik`,\r\n  siteUrl: 'https://junhobaik.github.io',\r\n\r\n  /** Header */\r\n  profileImageFileName: 'profile.png',\r\n\r\n  /** Home > Bio information*/\r\n  comment: 'Jr. Web Front-end Developer. / javascript, react ...',\r\n  name: 'Junho Baik',\r\n  company: '',\r\n  location: 'Korea',\r\n  email: 'junhobaik@gmail.com',\r\n  website: 'https://junhobaik.github.io',\r\n  linkedin: '',\r\n  facebook: '',\r\n  instagram: 'https://www.instagram.com/junhobaik',\r\n  github: 'https://github.com/junhobaik',\r\n\r\n  /** Post */\r\n  enablePostOfContents: true,\r\n  disqusShortname: 'junhobaik',\r\n\r\n  /** Optional */\r\n  googleAnalytics: 'UA-123123123-0',\r\n  googleAdsenseClient: 'ca-pub-5001380215831339',\r\n  googleAdsenseSlot: '5214956675',\r\n};\r\n```\r\n\r\n## Writing Posts\r\n\r\n`./posts`에 마크다운 파일을 위치시켜 게시물을 만들 수 있습니다.\r\n\r\n`./drafts`에 마크다운 파일을 위치시켜 임시 게시물을 만들 수 있습니다.  \r\n(개발 환경에서만 표시, 배포시 표시되지 않는 게시물)\r\n\r\n### Markdown YAML Front matter\r\n\r\n마크다운 상단에 아래와 같은 형식으로 게시물 정보를 입력합니다. 여기는 제목과 날짜가 필수로 들어가며 추가적으로 태그와 키워드를 넣을 수 있습니다.  \r\n그 후 하단에는 게시물의 내용을 입력합니다.\r\n자세한 작성법은 문서의 Markdown YAML Front matter란을 확인하세요.\r\n\r\n```\r\n---\r\ntitle: title here...\r\ndate: 2018-01-01\r\ntags:\r\n  - javascript\r\n  - ES6\r\nkeywords:\r\n  - keyword1\r\n  - keyword2\r\n---\r\n\r\n... Content here ...\r\n\r\n```\r\n\r\n## Deploy\r\n\r\n```\r\n$ npm run deploy\r\n```\r\n\r\n위의 명령어로 배포가 시작됩니다. master 브랜치로 commit이 자동으로 이루어지며,\r\n반영되기까지는 수십초 정도, 때로는 최대 수분의 시간이 소요됩니다.\r\n\r\n이제 본인의 주소로 들어가 확인할 수 있습니다.\r\n\r\n---\r\n\r\n더 자세한 Borderless 테마 사용법은 [Documents](<https://github.com/junhobaik/junhobaik.github.io/wiki/Document-(Borderless)>)를 참고하세요.\r\n","excerpt":"지금 이 글을 보고 있는 블로그는 Borderless 테마를 사용하고 있는 블로그입니다. Gatsby를 이용해 제작되었으며 Gatsby에 대한 간략한 설명은 이전 글(Gatsby로 블로그 만들기)에서 확인 할 수 있습니다. Borderless…","fields":{"slug":"/develop-blog-v3_3/"},"frontmatter":{"date":"Dec 30, 2019","title":"Borderless 테마로 Gatsby 블로그 만들기","tags":["undefined"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n정적 사이트 제작 프레임워크 Gatsby를 이용해 만든 블로그,  \r\n“Borderless” 테마입니다.\r\n\r\n- 심플한 디자인\r\n- 마크다운 지원\r\n- 게시물 태그 기능\r\n- 게시물 검색 기능\r\n- 시리즈 게시물 기능\r\n- Google Analytics\r\n- Google Adsense\r\n- Disqus 댓글 기능\r\n- 검색 엔진 최적화(SEO)\r\n\r\n## 화면 설명\r\n\r\n### Home 화면\r\n\r\n게시물 목록을 볼 수 있는 홈 화면으로,  \r\n타이틀 이미지가 크게 표시되며 프로필 정보가 함께 표시됩니다.  \r\n게시물 목록에는 게시물의 제목, 날짜, 태그, 요약이 표시됩니다.  \r\n프로필 정보에는 소개 문구, 이름, 회사, 위치, 메일, 웹사이트, RSS, 소셜(페이스북, 링크드인, 인스타그램, 깃허브)를 표시할 수 있습니다.\r\n\r\n![](DraggedImage.png)\r\n\r\n스크롤 다운시 헤더와 프로필 정보가 숨겨져 게시물 목록에 집중할 수 있습니다.\r\n\r\n![](DraggedImage-1.png)\r\n\r\n### Post 화면\r\n\r\n게시물 화면입니다.  \r\n헤더는 스크롤 다운시 감춰지며 게시물의 내용에 집중할 수 있습니다.  \r\n화면의 크기가 충분히 넓을 경우 목차가 우측에 표시되며, 그렇지 않을 경우 게시물의 상단에 목차 버튼으로 목차를 볼 수 있습니다.  \r\n목차는 클릭하여 해당 위치로 이동할 수 있고, 스크롤 위치에 따라 보고있는 목차 부분이 강조되어 보고있는 위치를 알 수 있습니다.\r\n\r\n![](DraggedImage-2.png)\r\n\r\n![](screenshot.png)\r\n\r\n게시물에 하단에는 게시물을 소셜 공유 할 수 있는 버튼들이 위치합니다.  \r\n그 아래로는 광고와 댓글이 위치합니다.\r\n\r\n#### 시리즈 게시물\r\n\r\n만약 시리즈 게시물이라면 위와 같이 게시물 상단에 시리즈 목록이 표시됩니다.\r\n\r\n![](DraggedImage-4.png)\r\n\r\n### 태그 화면\r\n\r\n태그 화면에서는 모든 태그가 표시되며,  \r\n게시물 수가 많은 태그는 텍스트 크기가 크게 표시됩니다.  \r\n현재 보고있는 태그는 텍스트가 진하게 표시됩니다.  \r\n아래는 태그에 해당하는 게시물 목록이 표시됩니다.\r\n\r\n![](DraggedImage-5.png)\r\n\r\n### 검색 화면\r\n\r\n제목, 제목+내용으로 검색이 가능합니다.  \r\n검색 결과에 따른 게시물 목록이 아래 표시됩니다.\r\n\r\n![](DraggedImage-6.png)\r\n\r\n## 그 외 기능\r\n\r\n- 간단히 설정 파일의 내용 몇가지만 수정하면 자신의 블로그로 활용할 수 있습니다.\r\n- Google Analytics의 TrackingID를 설정에서 입력하여 쉽게 등록 및 관리할 수 있습니다.\r\n- 자신의 Google Adsense 정보를 설정에서 입력해서 쉽게 구글 애드센스를 활용할 수 있습니다.\r\n- 자신의 Disqus 사이트 생성 후 shortname을 설정에서 입력하면 쉽게 댓글 기능을 활성화 할 수 있습니다.\r\n- 검색 엔진 최적화로 기본 설정만 입력하면 따로 부가적인 작업 없이 구글 검색 결과에 문제 없이 노출될 수 있습니다.\r\n- 웹 표준 준수로 Safari 브라우저 등 읽기 모드(Reader Mode)를 지원합니다.\r\n- 마크다운내에서 이모지, 수학 표기법(ktex)를 지원합니다.\r\n- 임시 게시물(draft)을 작성할 수 있습니다. 개발 환경에서는 표시되며 배포시 표시되지 않습니다.\r\n\r\n## Borderless 블로그로 자신의 블로그 시작하기\r\n\r\n지금 보고있는 이 블로그를 자신의 블로그로 커스터마이징하여 사용할 수 있습니다.\r\n\r\n아래 링크를 통해 Get Started, Document를 확인 할 수 있습니다.\r\n\r\n[Documents](<https://github.com/junhobaik/junhobaik.github.io/wiki/Document-(Borderless)>)\r\n","excerpt":"정적 사이트 제작 프레임워크 Gatsby를 이용해 만든 블로그, “Borderless” 테마입니다. 심플한 디자인 마크다운 지원 게시물 태그 기능 게시물 검색 기능 시리즈 게시물 기능 Google Analytics Google Adsense…","fields":{"slug":"/develop-blog-v3_2/"},"frontmatter":{"date":"Dec 30, 2019","title":"Borderless 블로그 - 소개","tags":["blog"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n![](DraggedImage.png)\r\n\r\n[기존 블로그](https://priceless-darwin-0a5ad6.netlify.com/)에서 새로 블로그를 구현했다.\r\n\r\n테마 이름은 “Borderless”이다.  \r\n말그대로 블로그 디자인 요소에 선이 없어서 이렇게 지었다.\r\n\r\n이번에도 동일하게 Gatsby를 이용하여 제작했고 태그와 검색 기능이 있는 것은 이전 블로그와 비슷한 구조이다.\r\n\r\n그런데 이전 블로그는 GraphQL도 완전 백지 상태에서 껴맞추기식으로 구현해서 지저분한 곳이 있었고,  \r\n디자인쪽으로도 깔끔하고자했지만 뭔가 조잡한듯한 느낌을 지울 수 없었다.\r\n\r\n블로그를 운영하면서 느끼게 된 점을 바탕으로 다시 디자인하고 생각하여 만들게 되었다.\r\n\r\n홈화면을 화려하고 예쁘게 만들고 검색이나 태그 기능을 예쁘고 다양한 기능으로 무장하고... 하는 것도 좋겠지만,\r\n\r\n블로그 유입은 9할 이상이 검색을 통해서 이루어진다. 따라서 방문자는 게시물을 보는 것이 제일 중요하고 그 이후에 블로그를 둘러보는 행동을 하는 사람은 거의 없다고 보면 된다.\r\n\r\n그에 맞춰서 최대한 게시물에 집중 할 수 있는 디자인을 하고, 블로그를 시작한 의도에 맞춰 내가 필요하고 사용하기 편하게만 만들면 되는 것이다.\r\n\r\n그래서 딱 몇가지만 고려했다.\r\n\r\n- 내 정보를 보여줄 수 있었으면,\r\n- 뭔가를 살펴볼땐 그것에만 집중 할 수 있어야한다.\r\n- 불필요한 스타일, 애니메이션, 기능은 제거하자.\r\n\r\n그래서 구현한 결과는 이렇게 된다.\r\n\r\n**내 정보를 보여줄 수 있었으면,**  \r\n좌측에 개인 프로필과 메뉴가 위치한 블로그를 자주 볼 수 있다. 그러한 UI를 어느정도 원했다 프로필이 있었으면 했다. 하지만 좌측에 항상 뭐가 있다면 내용에 집중하는데 방해가 된다고 생각했고 반응형 디자인에도 좋지 않다고 생각해서 이러한 UI 보다는 다른 UI를 생각하게 되었다.  \r\n상단에 헤더가 위치하고, 블로그 로고 이미지와 블로그 제목이 좌측으로, 우측에는 메뉴(태그, 검색)가 위치한다.  \r\n게시물이나, 태그, 검색등의 작업을 할때는 로고와 텍스트가 작은 크기로 위치하다가 홈화면(게시물 목록 화면)으로 위치하면 로고 이미지의 크기가 커진다. 그리고 로고 이미지와 제목 아래 프로필 정보들이 나열된다. 이렇게 구현하면 마치 좌측에 프로필이 위치한 UI와 비슷하게 보인다. 하지만 홈화면에서 게시물 목록을 훑어보기 위해 스크롤하면 헤더와 프로필 정보가 감춰지면서 게시물 목록에만 집중 할 수 있게 된다.\r\n\r\n![](DraggedImage-1.png)\r\n\r\n**뭔가를 살펴볼땐 그것에만 집중 할 수 있어야한다.**  \r\n기본적으로 헤더를 항상 표시가 아닌 스크롤에 따라 숨기고 나타나도록 구현했다.  \r\n그래서 게시물을 읽을땐 온전히 게시물에만 집중 할 수 있고, 그 외로 표시되는 것은 TableOfContents 즉, 목차 뿐이다. 이것도 투명도를 낮춰 게시물을 읽는데 집중할 수 있도록 했다.\r\n\r\n![](DraggedImage-2.png)\r\n\r\n홈화면에서는 앞서 프로필을 설명하는 부분에서 설명한 것과 같이 스크롤 시에는 헤더와 프로필 정보가 모두 숨겨지며 보이는 것은 게시물 목록 뿐이다.\r\n\r\n**불필요한 스타일, 애니메이션, 기능은 제거하자.**  \r\n기존에는 선, 배경색으로 개체들을 꾸미고 그림자를 입히고, 거기에 마우스 오버시 살짝 앞으로 나오는 듯한 애니메이션을 넣는 등 예뻐보이기 위해 이것저것 했는데 이번에는 정말 심플 그 자체가 되고자 했다.  \r\n그래서 생각한게 선과 색을 넣지 말자는 것이었다.  \r\n스타일에 선, 색, 그림자가 없다. (마크다운 게시물 안에는 당연하게 있을 수 있다..)  \r\n따라서 입체감도 없다. 머터리얼 디자인이 유행하면서 입체감에 많은 신경을 썼었는데 이번에는 아예 반대로 입체감이 없이 해보기로 했다. 어짜피 내용에만 집중하도록 디자인하다보니 입체감이 중요하지 않았다. 불필요한 요소는 보이지 않을테니까.  \r\n그리고 애니메이션은 최소화했다. 헤더와 프로필 부분 말고는 큰 애니메이션이 없다.  \r\n이 블로그 테마 이름을 Borderless라고 했는데, 바로 선이 없다는 이유에서다.\r\n\r\n---\r\n\r\n이러한 것 이외에도 세세한 구석에 신경을 많이 썼다.  \r\nUX를 고려해서 어느 곳에서도 부드럽게 전환이 가능하도록 신경썼고,  \r\n블로그가 기본적으로 해야하는 기능, 그리고 추가적으로 있으면 좋은 기능들도 당연히 구현했다.  \r\n대표적으로 Google Analytics, Disqus 가 있다. 애널리틱스는 웹 운영에 필수고, 댓글 또한 블로그에 없어서는 안될 기능이다.  \r\n구현 중에 본인의 Disqus를 새로 설정하면서 기존 댓글이 지워진 아쉬움이 있긴하다.\r\n\r\n글을 쓰는 현재 아직 몇가지 해야할 것이 남았다.  \r\n몇가지 수정할 게 남았고, 그 다음으로 해야할 것이 다른 사람들이 이용할 수 있게 만들어두는 것이다. 기본적인 정보만 수정하면 자신의 블로그로 만들어 사용할 수 있게 처음부터 고려해서 만들어졌다. 이전 블로그도 이와 비슷하게 배포했는데 메일이나 댓글로 질문이 몇번와서 이번에는 문서를 조금 더 정성들여 적어봐야겠다.\r\n\r\n다음으로는 간단하게 블로그를 소개하고, 그 다음에는 이 블로그를 자신의 블로그로 만드는 방법을 자세하게 적어볼 수 있도록 하려 한다.\r\n","excerpt":"기존 블로그에서 새로 블로그를 구현했다. 테마 이름은 “Borderless”이다. 말그대로 블로그 디자인 요소에 선이 없어서 이렇게 지었다. 이번에도 동일하게 Gatsby…","fields":{"slug":"/develop-blog-v3_1/"},"frontmatter":{"date":"Dec 30, 2019","title":"Borderless 블로그 - 개발기","tags":["blog","gatsby"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n이 글은 개발해서 운영하고 있는 서비스에 대한 잡담과 같은 후기이다.\r\n\r\n현재까지 개발해서 지속적으로 운영하고 있는 결과물은 5개 정도이다.\r\n\r\n- Blog\r\n- Netflix AutoSkip\r\n- Tablo\r\n- Tablo (version 2)\r\n- WhatSubs\r\n\r\n## [Blog](https://junhobaik.github.io/)\r\n\r\n최근 새로 새단장을 했다. 지금 보고 있는 이 블로그이다. 새로 만들게 된 이유는 심플함을 항상 추구했지만 뭔가 항상 맘에 들지 않았고 그래서 새로 처음부터 구현하면서 몇몇 코드만 가져다가 만들게 되었다. 그러는 김에 있었으면 하는 기능도 몇가지 추가할 겸 말이다.  \r\n이번에 블로그는 완전 깔끔하게 게시물에 집중할 수 있는 디자인으로 만들었다. 블로그 테마(?)의 이름은 \"Borderless\"로 지었다. 디자인은 말 그대로 선이 없다. 스타일에 border가 존재하지 않는다. 선(border)뿐만 아니라 배경색, 그림자를 넣지 않았다. 그러면서도 세련되게 만들려고 노력을 많이 했다. 지금은 개인적으로 상당히 만족스럽게 만들어진것 같다. 아직은 구현이 끝나지 않았다. 디테일한 몇군데 수정만 거치고 나면 완성될 것 같다. 전에 쓰던 블로그와 비슷하게 다른 분들도 사용이 가능하게 배포할 예정이다.\r\n\r\n게시물 부분에서는 업데이트를 자주 못했지만 개인적으로 저장하기 위해 시작했고 블로그를 개발하는 것도 스터디에 한부분이었던 블로그인데 조회수를 보면 조금 더 신경써야되나 싶다.\r\n\r\nGoogle Analytics를 통해 살펴보면 올해 총 페이지뷰가 대략 11만이 넘었다.  \r\n애널리틱스를 자세히 살펴보다보면 재밌는 부분이 많다. 다른 사이트에서 내 블로그를 링크를 통해 들어오면 그 링크된 사이트가 어디인지 알 수 있는데 거길 들어가서 살펴보면 내 글도 누군가에게 도움이 되고 있구나라는 생각이 든다.\r\n생활코딩의 강의 댓글에 내 블로그 글을 보면 도움이 될거라는 댓글을 보고 굉장히 뿌듯했던 기억이 난다.\r\n\r\n그리고 몇달전인가 도입한 에드센스를 살펴보면 조회된 애드센스 광고 단위수가 2만이 넘었다.  \r\n이것도 수익보다는 에드센스 도입을 한번 해보자라고 스터디 차원에서 한 것이었다.\r\n지금까지 총 수익은 7달러이다. 광고 차단 프로그램 탓도 있을 수 있겠다. 광고 차단 프로그램을 막을 수 있겠지만 수익을 생각하고 구현했던 것도 아니고 또한 광고 노출이 아닌 직접 클릭을 해야 수익이 나오는 것 같다.\r\n\r\n그리고 블로그를 남들도 쓸 수 있도록 구현했는데 (이것도 스터디 차원에서 해본..) fork해서 블로그로 잘 운영하고 있는 분도 계시는 걸 보니 또 뿌듯했다. 업데이트를 제대로 한번 해야겠다는 생각도 든다. 지금은 게시물만 종종 올리고 블로그 자체는 만족하고 그냥 쓰고 있으니 말이다.\r\n\r\n## [Netflix AutoSkip](https://chrome.google.com/webstore/detail/netflix-autoskip-intro-ne/pfcombngcgnehkbdoafkhdcfdmklboai)\r\n\r\n간단하고 간략한 코드로 구현된 크롬 확장프로그램이다.\r\n\r\n넷플릭스를 크롬 브라우저로 보는데 키보드와 마우스에서 멀리 떨어져서 볼 경우 인트로 스킵이나 다음 동영상을 넘기는 버튼을 누르러 다시 컴퓨터나 TV 앞으로 가는 것이 귀찮아 만들었는데 생각보다 많은 사람들이 쓰고 있다. 현재 3000명 정도가 전세계에서 쓰고 있고 이것도 애널리틱스에서 실시간 접속자로 전세계에서 접속하고 있는 위치 모습을 보면 재미있다.\r\n\r\n만드는 것들이 모두 내가 필요해서 만들기 시작한 것들이 대부분인데 이 앱은 쓰는 사람들이 좀 있고 버그가 있었을 적엔 메일로 피드백이 몇번 오기도 했다. 그런데 이 웹앱을 사겠다는 메일이 몇군데서, 그것도 다른 나라에서 왔었는데 이게 뭔가 싶다. 엄청 많은 사람이 쓰고 있는 것도 아니고 간단한 코드로 구현되었고 코드도 다 공개되어있는데...\r\n\r\nDOM 트리가 변경되는 것을 기준으로 기능이 동작하는데 이번에 넷플릭스 UI가 조금 변경되면서 최근에 새로 업데이트를 했다.\r\n\r\n얼마 전 수정하면서 기능이 유사한 다른 앱들을 살펴보니 아직 대응들을 안한 것인지 인트로 스킵과 다음 에피소드 재생 대기를 스킵하는 것이 모두 잘되는 것은 내 앱 뿐이었다.\r\n\r\n## [Tablo](https://chrome.google.com/webstore/detail/tablo-bookmark-and-manage/aoccnljcdmmbihgabpoljghfcmbflkhc)\r\n\r\ntrello와 비슷한 UI로 task가 아닌 link를 저장해 즐겨찾기와 같이 이용하는 크롬 확장프로그램으로 크롬의 새탭을 열면 열리는 웹앱이다. 크롬 시작화면 웹앱이라고도 할 수 있다.\r\n\r\n현재 열려있는 탭 목록을 표시하고 거기서 드래그해서 자신만의 즐겨찾기 목록을 만드는게 주요 컨셉이었고 확장 프로그램 아이콘을 통해 웹 서핑 중 즐겨찾기 목록에 추가하는 것도 가능하다.\r\n\r\n개발을 하고 따로 계속해서 발전시키지는 않았다. UI가 가로 스크롤이 필요한 UI이다보니 가로 스크롤에 대한 고민을 계속하긴 했었고 그에 대해 몇가지 변경이 이뤄지긴 했다.\r\n\r\n개인적으로 필요해서 만들었고 잘 쓰고 있긴 했지만 계속해서 발전시키지 않은 이유는 새로운 기능을 포함해 새롭게 다시 만들 생각을 하고 있었기 때문이었고 그로 인해 Tablo version2를 만들게 되었다.\r\n\r\n## [Tablo (version 2)](https://chrome.google.com/webstore/detail/tablo/aflhcldanmopecmjjinnenkcddghjnkn)\r\n\r\n이번에는 세로 형식의 trello 형식이 아닌 가로 형식으로 바꾸었고, 기존의 현재 열린 탭들 목록에서 자신의 즐겨찾기 목록으로 드래그하는 것, 확장 프로그램 아이콘을 통해 웹 서핑중 해당 사이트를 자신의 즐겨찾기 목록에 추가하는 것은 그대로 유지되었다.\r\n\r\n추가된 주요 기능은 간단하게 말하면 rss 구독 기능이다. rss 구독 주소를 등록할 수 있고 구독한 사이트들의 게시물이 화면에 보이게 된다.\r\n\r\n내가 브라우저를 켰을때 어디로 이동할 지 즐겨찾기와 같은 목록이 보였으면 좋겠고,  \r\n내가 관심있는 기술 블로그들의 최신 게시물을 쉽게 한곳에서 확인하고 싶었고,  \r\n웹 서핑이나 서치중에 나중에 보기위해 저장할 곳이 필요했다.\r\n\r\n위와 같은 이유를 모두 만족하는 내게 필요한 웹앱을 만들었다.\r\n원하는 기능은 거의 구현했으며 크롬 웹스토어에 출시했다 이제 디테일한 수정과 개선을 계속해나가면 된다.\r\n\r\n## [WhatSubs](https://junhobaik.github.io/whatsubs-dev-story/)\r\n\r\n최근에 만들었고 구글 플레이스토어, 앱스토어 심사를 통과했다.  \r\n[개발기](https://junhobaik.github.io/whatsubs-dev-story/)도 간단히 써놓은 것이 있다.\r\n\r\nWhat(무엇) + Subscription(구독)을 합친 이름으로 큰 고민 없이 만들었는데 생각보다 맘에 든다.\r\n\r\nWhatSubs는 구독 관리에 도움을 주는 앱으로, 자신이 구독하는 항목을 쉽게 목록에 추가하고 그 목록을 한눈에 쉽게 확인해 구독을 관리하는데 도움을 줄 수 있는 앱이다.\r\n\r\n구독하는 서비스가 많아지다보니 어디서 어떤 결제수단으로 구독을 해 두었는지 까먹기도하고 확인하기에도 불편해서 한눈에 확인하고자 만든 앱이다. 또, 어디서든 쉽게 확인하려면 핸드폰이 낫겠다 싶어 이참에 React Native앱을 만들어보고자 제작하기 시작했다.\r\n\r\nUI/UX에 많은 시간을 들였고 개인적으로는 만족스럽게 결과를 만들어냈지만 내 기준으로 만들다보니 최신 갤럭시 노트와 최신 아이폰과 같이 화면비가 긴 화면에 적합하게 만들어져 UI/UX로 아쉬운 점이 남았다. 해상도와 화면비를 고려해서 컨텐츠의 크기를 수정하기도 했지만 여전히 아쉬운 점이 많다.\r\n\r\n---\r\n\r\n## P.S.\r\n\r\n지속적으로 운영을 할거라면 개발 외에도 내 앱을 소개하는 페이지에도 신경을 좀 더 써야하나 싶다. 홍보까진 아니더라도 말이다.  \r\n이번에 출시한 WhatSubs는 소개 페이지를 그나마 포토샵을 오랜만에 사용해 만들었다. 아무래도 앱스토어와 플레이스토어에 올라가다보니 조금은 신경을 썼다. 그에 비해 다른 웹앱인 크롬 확장 프로그램들은 구글 프레젠트에서 대강 만들어 올리다보니 조금은 부실해보이는데 나중에라도 더 신경을 써서 만들어야겠다는 생각이 든다.\r\n","excerpt":"이 글은 개발해서 운영하고 있는 서비스에 대한 잡담과 같은 후기이다. 현재까지 개발해서 지속적으로 운영하고 있는 결과물은 5개 정도이다. Blog Netflix AutoSkip Tablo Tablo (version 2) WhatSubs Blog…","fields":{"slug":"/dev-log-2019/"},"frontmatter":{"date":"Dec 29, 2019","title":"현재까지 개발한 결과물에 대한 이야기 2019","tags":["undefined"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nApp Store Connect에서 앱 정보를 입력하고 실제로 출시한다면  \r\nApp Store에서 입력한 항목들은 어디에 어떻게 위치하게 될 지 정리해보았습니다.\r\n\r\n아래는 App Store Connect에서 입력하고  \r\nApp Store에 직접적으로 표시될 내용들입니다.\r\n선택항목 및 표시되지 않는 항목은 제외한 목록입니다.\r\n\r\n- 이름\r\n- 부제\r\n- 등급\r\n- 앱 미리보기 및 스크린샷\r\n- 프로모션 텍스트\r\n- 설명\r\n- 아이콘\r\n- 카테고리\r\n- 지원 URL\r\n- 저작권\r\n- 개인정보 처리방침 URL\r\n\r\n## 검색 결과 화면\r\n\r\n앱 스토어 검색을 통해 해당 앱을 찾는다면 검색 결과 목록에서 표시되는 내용은 아래와 같습니다.  \r\n**아이콘**, **이름**, **부제** 그리고 **앱 미리보기 및 스크린샷**이 아래와 같이 나타납니다.\r\n\r\n![](DraggedImage.png)\r\n\r\n또한 부제의 경우 길이에 따라 줄임표로 내용이 생략될 수 있습니다.\r\n앱 미리보기 및 스크린샷의 경우 앱 미리보기가 우선이며 그 뒤로 스크린샷이 위치합니다.\r\n\r\n## 앱 상세 화면\r\n\r\n![](DraggedImage-1.png)\r\n상단에는 위와 같이 **아이콘**, **이름**, **부제**, **등급**, **앱 미리보기 및 스크린샷**이 위치합니다.\r\n\r\n![](DraggedImage-2.png)\r\n스크린샷 아래로는 우선 **프로모션 텍스트**가 위치하며 *더보기*를 누를 경우에 이어서 **설명**이 추가적으로 노출되게 됩니다.\r\n\r\n![](DraggedImage-3.png)\r\n하단에서는 리뷰 부분에 앱 지원을 누르게 되면 입력해둔 **지원 URL**의 주소로 이동합니다.  \r\n**카테고리**는 두개의 카테고리를 입력해두더라도 첫번째 카테고리만 표시되게 됩니다.  \r\n**등급**은 상단 화면의 연령에 이어서 다시 연령 등급이라는 항목으로 표시됩니다.  \r\n**저작권**은 입력해둔 저작권에 앞에 ©가 추가되어 표기됩니다.  \r\n개인정보 처리방침을 누르게 되면 입력한 **개인정보 처리방침 URL**로 이동합니다.\r\n\r\n(참고로 정보의 언어는 앱 스토어 커넥트에서 지정한 기본 언어가 나타나는 것이 아닙니다)\r\n\r\n## 추가 정보\r\n\r\n### 검색에 반영되는 항목\r\n\r\n- 이름\r\n- 부제\r\n- 태그\r\n  태그의 경우에는 심사에 영향을 미칠 수 있으니 주의해서 작성해야합니다.\r\n\r\n### 개인정보 처리방침 만들기\r\n\r\n개인정보 처리방침이 없으면 심사에 올릴 수 없습니다.\r\n[개인정보보호 종합포털](https://www.privacy.go.kr/ '개인정보보호 종합포털')의 개인정보처리방침 만들기 메뉴를 들어가서 절차에 따라 만들 수 있습니다. 절차에 따라 완성된 내용이더라도 추가적인 검토와 수정은 필수입니다.\r\n","excerpt":"App Store Connect에서 앱 정보를 입력하고 실제로 출시한다면 App Store에서 입력한 항목들은 어디에 어떻게 위치하게 될 지 정리해보았습니다. 아래는 App Store Connect에서 입력하고 App Store…","fields":{"slug":"/app-store-connect-form/"},"frontmatter":{"date":"Dec 06, 2019","title":"App Store Connect에 입력한 내용이 App Store에 어떻게 보일까?","tags":["undefined"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n![](a1.png)\r\n\r\n**[Google Play Store](https://play.google.com/store/apps/details?id=com.junhobaik.whatsubs)**  \r\n**[Apple App Store](https://apps.apple.com/kr/app/whatsubs/id1489637056)**\r\n\r\n---\r\n\r\nWhatSubs라는 iOS, Android 플랫폼의 React Native 앱을 최근에 만들게 되었습니다.\r\n지금은 두 플랫폼에서 모두 심사가 끝나고 출시가 되었습니다.\r\n아무래도 개인적인 필요에 의해 만들기 시작하였고 수요가 많은 앱이 될거라고 생각하진 않지만 이번에는 배포까지 전반적인 과정을 체험해보고자 이렇게 출시하게 되었습니다.\r\n\r\n앱을 간단히 소개하면 자신이 구독한 구독 서비스를 등록하고 리스트를 통해 확인할 수 있는 구독 관리에 도움을 주는 앱이라고 할 수 있습니다.\r\n\r\n다양한 구독 서비스를 사용하면서 구독 후 사용하지 않는데 깜박하고 해지를 안하거나, 결제 수단이 다양하다보니 각 결제 수단별로 구독한 항목을 확인하는데 어려움을 느껴 만들게 된 앱입니다.\r\n\r\n기존에는 웹과 크롬 확장 프로그램을 주로 개발해왔는데 이번에는 제대로 React Native앱을 만들어보고자 리액트 네이티브 문서를 보면서 기초부터 공부하며 만들게 되었습니다. 또 백엔드는 없는 독립형 앱을 만들고자 했습니다.\r\n\r\n### 리액트 네이티브\r\n\r\n리액트 네이티브를 사용하면서 어려웠던 점이나 느낀 점\r\n\r\n- 생각보다 React와 달리 제약이 많다  \r\n   Angular와 Vue보다 React를 선호하는 이유가 좀 더 자유롭다는 것이었습니다. 그런데 React Native는 다양한 플랫폼에서 동작하게 하려는 이유 등으로 이해는 가지만 생각보다 구현 할 방법에 제약이 있었습니다.\r\n- 노치, 펀치홀 대응  \r\n   노치와 펀치홀을 대응하는데 있어 쉽지가 않았습니다. 매끄러운 UI를 대응하기 위해서는 라이브러리 사용이 필요했고, 사용하더라도 완전히 android와 ios를 동시에 편하게 대응하기는 어려웠습니다.\r\n- 해상도 대응?  \r\n   다양한 기기, 다양한 화면비, 다양한 해상도가 있다보니 앱에서 표시되는 컨텐츠 내용의 양이 차이가 생겨 여기에 대응하는 것이 힘들었습니다. 처음에는 화면비로 대응을 했더니 화면비가 높으나 해상도가 낮은 기기로 좀 연식이 있는 기기와 같은 예외가 생겨 다시 해상도를 기준으로 컨텐츠의 크기를 조절해야했습니다. 이 부분에 대해서는 차후에도 디테일한 수정이 필요하다고 생각하고 있습니다.\r\n- Expo  \r\n   이번에는 Expo를 통해 개발하고, 번들링을 하게 되었는데 만약 Expo가 없으면 많이 불편하겠다는 생각을 했습니다. create-react-app 없이 개발할 수 있듯 React-Native도 그럴 수 있게 공부가 더 필요하겠다는 생각했습니다.\r\n- UI / UX  \r\n   RN에만 해당하는 것은 아니지만 모바일 앱으로 개발하면서 더욱 UI에 고민이 많았습니다. 게다가 한 화면에서 모든 정보를 보여주기를 원했기때문에 어떻게 할까 고민을 많이 했습니다. 지금의 화면에 만족하고는 있지만 본인이 화면비가 긴타입의 핸드폰을 사용하고 있고 본인을 기준으로 개발하다보니 저해상도의 예전 폰들에서는 내용이 덜 표시되는 문제는 뒤늦게 알게 되어 컨텐츠의 크기 등을 조절했지만 완전 만족스럽지는 못합니다.\r\n\r\n### 앱 출시\r\n\r\n앱 출시를 하면서 느낀 점\r\n\r\n- 저작권, 라이선스  \r\n   항상 개발을 하면서 저작권을 중요하게 생각했습니다. 다양한 회사와 서비스의 로고가 들어가다보니 저작권에는 문제가 없는지 알아보게 되었고, 알아보면서 다시 한번 저작권은 어렵다는 생각을 또 한번 했습니다. 그리고 이번에는 앱 출시에 있어서 앱 내부에 ‘오픈소스 라이선스’라는 것을 넣어서 앱 내에서 사용한 패키지, 라이브러리에 대한 라이선스 내용을 첨부했습니다.\r\n- 영어 공부를 해야겠다?  \r\n   개발하는데 있어 라이브러리 등등 도큐먼트에 가서 사용법을 익히는 정도는 괜찮았지만 출시에 있어 가이드 문서를 보는건 역시 힘들었습니다. 어서 영어 공부를 더 해야겠다는 생각이 들었습니다... 또한 다국어 처리를 하는데 있어서도 번역기로는 한계가 있었고 전에 만든 Tablo 웹앱은 다국어 처리를 했으나 일단은 이 WhatSubs앱은 한국을 대상으로 출시했고 차후에 다국어 처리가 가능하도록 개발을 진행했으니 나중에 몇가지만 더 구현하고 내용을 채우면 될 것 같습니다.\r\n- 개인정보  \r\n   앱스토어에서는 개인정보처리방침을 마련하지 않으면 앱을 올리지 못합니다. 일상 그냥 넘기던 그 긴 문서를 직접 만들어야한다니 막막했는데 개인정보처리방침을 쉽게 만들 수 있게 된 공공사이트가 있어 만들 수 있었습니다. 허나 지금 앱은 독립형앱이고 서버가 없어 따로 수집하는 개인정보가 없기 때문에 이렇게 쉬웠던 것이지 만약에 개인정보를 수집하는 앱이라면 더 알아봐야 할 것이 많고 작성하는데도 어려울뿐더러 개인정보처리방침을 따라 개인정보 처리를 하고 폐기를 하고 관리를 해야한다면 앱을 운영하는 것이 그리 쉽지만은 않겠다는 생각이 들었습니다.\r\n\r\n---\r\n\r\n- 아이폰의 왼쪽 사이드를 슬라이드하여 뒤로가기, 안드로이드폰의 뒤로가기 버튼(하드웨어, 소프트웨어)의 기능과 그에 따른 화면의 스택, 그리고 노치 영역을 고려한 View인 SafeAreaView를 사용하기 위해 사용한 모듈은 `react-native-gesture-handler`\r\n\r\n- 개인정보처리방침을 만들때 이용한 사이트는 [개인정보보호 종합포털](https://www.privacy.go.kr/ '개인정보보호 종합포털')이며 ‘개인정보처리방침 만들기’ 메뉴를 이용하면 된다.\r\n","excerpt":"Google Play Store Apple App Store WhatSubs라는 iOS, Android 플랫폼의 React Native…","fields":{"slug":"/whatsubs-dev-story/"},"frontmatter":{"date":"Dec 05, 2019","title":"WhatSubs 앱 개발기 (React-Native, Expo)","tags":["react-native"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nCSS 방법론은 스타일을 정의하는데 있어 엘리먼트의 class와 id를 어떻게 다루는지, 네이밍을 어떻게 하는지의 방법을 정의해 더 직관적인 스타일 코드를 작성하고 팀 단위의 개발을 원할하게 하는데 사용된다.  \r\n대표적으로는 BEM, OOCSS, SMASS가 있으며 여기서는 BEM에 대해 간단히 알아보겠다.\r\n\r\nBEM의 공식 가이드 홈페이지는 [https://en.bem.info](https://en.bem.info/ 'bem')로 영어와 러시아어가 지원된다.\r\n\r\n## BEM?\r\n\r\nBEM은 **Block**, **Element**, **Modifier** 세개 단어의 약자이다.  \r\n크게 세가지를 통해서 네이밍을 하게 된다.\r\n\r\nBEM은 기본적으로 id가 아닌 class만 사용하는 것을 지향하며, CSS tag도 쓰지 않는다.  \r\n세개(B,E,M)의 요소를 기준으로 클래스명을 작명하게 된다.\r\n\r\n```css\r\n.error #test { ... } ❌ id 사용\r\n.info h1 { ... } ❌ tag 사용\r\n\r\n.info__text { ... } 👍\r\n```\r\n\r\n## Block\r\n\r\nBlock을 기준으로 네이밍을 시작하게 되며 블록의 이름 뒤에 `__`로 연결하여 Element 이름을 작성하게 된다.\r\n\r\n블록은 **독립적으로 기능**하는 단위이다.\r\n\r\n```html\r\n<div class=\"big-text\" /> ❌\r\n\r\n<div class=\"error\" /> 👍\r\n```\r\n\r\n큰 텍스트(big-text)를 정의한 것은 텍스트라는 **목적** 또는 크다는 **모양**을 기술하였으므로 하나의 독립적 기능을 하는 단위라 볼 수 없다.  \r\n오류(error)라 정의한 것은 무엇을 하는가, **기능**. 즉 오류라는 기능을 수행한다는 독립적인 단위가 될 수 있다.\r\n\r\n블록에는 position, margin과 같이 외부적인 위치를 조정하는 스타일을 지정할 수 없다.\r\n\r\n**=\\> 독립성과 재사용성의 보장**  \r\n무엇을 하는지 정의하고 외부적인 위치를 조정하는 position, margin과 같은 스타일을 넣지 않으므로 블록이 움직이거나 다른 곳에서 이 블록을 또 사용하더라도 독립성을 유지할 수 있게 되는 것이다.\r\n\r\n블록은 중첩될 수 있으며, 여러 중첩을 거칠 수 있다.\r\n\r\n```html\r\n<!-- header 블록 -->\r\n<header class=\"header\">\r\n  <!-- 중첩된 logo 블록 -->\r\n  <div class=\"logo\" />\r\n  <!-- 중첩된 serch-from 블록 -->\r\n  <div class=\"search-form\" />\r\n</header>\r\n```\r\n\r\n## Element\r\n\r\nElement는 블록을 구성하는 단위로 블록과 분리될 수 없는 블록의 하위 요소이다.  \r\n따라서 블록 이름 없이 사용할 수 없으며,  \r\n블록 이름 뒤에 언더바 2개`__`로 연결하여 작성한다.\r\n\r\n엘리먼트는 위에서 예를 든 `big-text`를 통해서 살펴보면,  \r\nbig과 같은 모양을 나타내는 것은 옳지 않다.  \r\ntext와 같은 목적을 나타내는 것은 사용할 수 있다.\r\n\r\n```html\r\n<div class=\"search-form\">\r\n  <h1 class=\"search-from__big\"></h1> ❌ \r\n  <span class=\"search-from__text\"></span> 👍 \r\n  <input class=\"search-from__input\" /> 👍\r\n</div>\r\n```\r\n\r\n엘리먼트 또한 블록과 같이 중첩될 수 있으며, 여러 중첩을 거칠 수 있다.\r\n\r\n```html\r\n<form class=\"search-form\">\r\n  <div class=\"search-form__content\">\r\n    <input class=\"?\" /> 👈\r\n    <!--\r\n\t\t\t\"search-form__content__input\" ?\r\n\t\t\t\"search-form__input\" ?\r\n    -->\r\n  </div>\r\n</form>\r\n```\r\n\r\n위에서 input 태그를 보면 계층이 블록\\>엘리먼트\\>엘리먼트이다.\r\n그렇다고해서 Block `search_form`안의 Element `content`안의 `input`이라고 해서 `search-form__content__input`라고 네이밍을 하는 것은 옳지 않다.\r\n\r\n엘리먼트의 이름은 이어서 계층구조를 가지게 작성되어서는 안된다.  \r\n따라서 `search-form__input`으로 작성되어야 맞다.\r\n\r\n```css\r\n.block {\r\n}\r\n.block__elem1 {\r\n}\r\n.block__elem2 {\r\n}\r\n.block__elem3 {\r\n}\r\n```\r\n\r\n```html\r\n<div class=\"block\">\r\n  <div class=\"block__elem1\">\r\n    <div class=\"block__elem2\"></div>\r\n    <div class=\"block__elem3\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Change -->\r\n<div class=\"block\">\r\n  <div class=\"block__elem1\">\r\n    <div class=\"block__elem2\"></div>\r\n  </div>\r\n\r\n  <div class=\"block__elem3\"></div>\r\n</div>\r\n```\r\n\r\n이러한 구조를 따르면 위의 코드를 통해 알 수 있듯 블록의 구조가 변경되더라도 해당 엘리먼트들의 규칙을 유지할 수 있게 된다.\r\n\r\n여기까지 살펴보면 아래 코드를 보면 옳지 않다는 생각이 든다.\r\n\r\n```html\r\n<div class=\"search-form\">\r\n  <input class=\"input\" />\r\n  <button class=\"button\">Search</button>\r\n</div>\r\n```\r\n\r\n하지만 input, button을 엘리먼트가 아닌 하나하나의 블록으로 살펴 볼 수 있기 때문에 틀린 코드라고 할 수 없다. 따라서 꼭 블록 안에 엘리먼트가 있어야 하는 것은 아니라고 할 수 있다.\r\n\r\n## Modifier\r\n\r\nModifier는 블록이나 엘리먼트의 모양이나 상태, 또는 행동을 정의합니다.  \r\n블록, 엘리먼트 뒤에 하나의 언더바`_`로 이어 기술합니다.\r\n\r\n예를 들어 어떤 사이즈인지 `size_m`, 어떤 상태인지 `disabled` `focused`, 어떤 동작인지 `directions_left-top`를 적으면 된다.\r\n\r\n### Types of modifiers\r\n\r\n**Boolean**\r\n\r\n- `block-name_modifier-name`\r\n- `block-name__element-name_modifier-name`\r\n  위와 같은 패턴으로 작성하는 것으로,\r\n\r\n`focused`와 `disabled`와 같이 상태를 나타내는 것은 보통 boolean 값을 가질 것을 생각하는데 이럴때는 **true**라고 가정하고 작성하는 것을 원칙으로 한다.\r\n\r\n```html\r\n<form class=\"search-form search-form_focused\"></form>\r\n```\r\n\r\n`search-form_focused`의 `_focused` 부분이 true라고 가정, 포커스가 된 상태의 검색폼이라고 할 수 있다\r\n\r\n**Key-value**\r\n\r\n- `block-name_modifier-name_modifier-value`\r\n- `block-name__element-name_modifier-name_modifier-value`\r\n\r\n`테마: 아일랜드` 와 같이 키-벨류를 나타내는 듯한 이름을 말한다.\r\n\r\n```html\r\n<form class=\"search-form search-form_theme_islands\"></form>\r\n```\r\n\r\n`theme_islands`와 같이 키와 벨류를 하나의 언더바로 분리한 모양으로 작성하면 된다.\r\n\r\n## Mix\r\n\r\n```html\r\n<div class=\"header\">\r\n  <div class=\"search-form header__search-form\" />\r\n</div>\r\n```\r\n\r\n클래스를 나눠보면 아래와 같다.\r\n\r\n- `header` Block\r\n- `header__search-from` Element\r\n- `search-form` Block\r\n\r\n정리하면,\r\n\r\n`header` Block에 `search-from` Block의 스타일과 동작을 Mix해 header 블록의 search-from이라는 `header__search-from`을 만들었다.\r\n\r\n이는`header__search-from`를 이용해 `header`, `search-from` 각각의 Block의 독립성을 유지하면서 `search-form` 블록에 margin이나 position을 조정할 수 있게 된다.\r\n\r\n## File structure\r\n\r\nBEM 방법론은 파일 구조에도 쓰일 수 있다. 프로젝트 구조를 작성할 때 폴더, 파일명에 규칙을 적용해 아래와 같이 작성할 수도 있다.\r\n\r\n```\r\nsearch-form/ #Block\r\n\r\n    __input/ #Element\r\n        search-form__input.css\r\n        search-form__input.js\r\n\r\n    __button/ #Element\r\n        search-form__button.css\r\n        search-form__button.js\r\n\r\n    _theme/ #Modifier\r\n        search-form_theme_islands.css\r\n        search-form_theme_lite.css\r\n\r\n    search-form.css\r\n    search-form.js\r\n```\r\n\r\n파일 구조를 작성하기위한 규칙은 아래와 같다.\r\n\r\n- 하나의 Block은 하나의 디랙토리에 해당한다.\r\n- Block과 디렉토리의 이름은 동일해야한다.\r\n- Block의 구현은 별도의 파일로 나눈다. (`header.js`, `header.css`)\r\n- Block 디렉토리가 루트 디렉토리가 되며 아래에 해당 블록의 Element, Modifier 디렉토리가 있는다.\r\n- Element 디렉토리의 이름은 두개의 언더바 (`__`)로 시작한다 (`header/__logo/`, `menu/__item/`)\r\n- Modifier 디렉토리의 이름은 하나의 언더바 (`_`)로 시작한다.(`header/_fixed/`, `menu/_theme_islands/`)\r\n- Element와 Modifier의 구현은 별도의 파일로 나눈다. (`header__input.js`, `header_theme_islands.css`)\r\n\r\n---\r\n\r\n- References - [BEM Quick-start](https://en.bem.info/methodology/quick-start 'bem quick start')\r\n","excerpt":"CSS 방법론은 스타일을 정의하는데 있어 엘리먼트의 class와 id를 어떻게 다루는지, 네이밍을 어떻게 하는지의 방법을 정의해 더 직관적인 스타일 코드를 작성하고 팀 단위의 개발을 원할하게 하는데 사용된다. 대표적으로는 BEM, OOCSS…","fields":{"slug":"/css-bem/"},"frontmatter":{"date":"Nov 12, 2019","title":"CSS 방법론 - BEM","tags":["css"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n_해당 포스트는 macOS 환경을 기준으로 작성되었습니다_\r\n\r\n[**NVM**(Node Version Manager)](https://github.com/nvm-sh/nvm)\r\n\r\nNode 버전을 쉽게 관리 할 수 있다.\r\n예로 사용하던 패키지가 Node 버전이 업데이트를 함에 따라 호환이 되지 않을 경우가 생길 때 NVM없이 Node 버전을 되돌리기는 간단한 작업은 아니다. 이런 경우 NVM이 요긴하게 사용될 것이고 이 외에도 팀규모의 개발 등 많은 곳에서 Node 버전 관리가 필요할 수 있다.\r\n\r\n## 설치\r\n\r\n```bash\r\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash\r\n```\r\n> [NVM | Installation](https://github.com/nvm-sh/nvm#installation-and-update)\r\n\r\n## 사용\r\n\r\n현재 사용 가능한 Node Version List를 보여준다.\r\n```bash\r\n> nvm ls-remote\r\n```\r\n\r\n특정 버전의 Node를 설치합니다.\r\n```bash\r\n> nvm install <version>\r\n```\r\n\r\n또는 LTS Version으로 설치\r\n```bash\r\n> nvm install --lts\r\n```\r\n\r\n사용할 Node 버전 설정\r\n```bash\r\n> nvm use <version>\r\n```\r\n> 처음 설치한 Node 버전은 자동으로 사용하게 설정이 되어있습니다.\r\n\r\n이렇게 간단하게 버전을 설치하고 사용을 설정하면 됩니다.\r\n설치된 리스트를 확인해보면 아래와 유사한 출력을 볼 수 있습니다.\r\n\r\n```bash\r\n> nvm list\r\n       \r\n       v10.16.0\r\n->     v10.16.2\r\ndefault -> lts/* (-> v10.16.2)\r\nnode -> stable (-> v10.16.2) (default)\r\nstable -> 10.16 (-> v10.16.2) (default)\r\niojs -> N/A (default)\r\nunstable -> N/A (default)\r\nlts/* -> lts/dubnium (-> v10.16.2)\r\nlts/argon -> v4.9.1 (-> N/A)\r\nlts/boron -> v6.17.1 (-> N/A)\r\nlts/carbon -> v8.16.0 (-> N/A)\r\nlts/dubnium -> v10.16.2\r\n```\r\n\r\n설치되어있는 버전은 `10.16.0`과 `10.16.2`가 있고,\r\n현재 사용중인 버전이 `10.16.2`인 것을 확인 할 수 있습니다.\r\n\r\n만약 여기서 새로운 최신 LTS 버전의 Node가 나왔고 사용하자고 한다면 두가지 경우가 있을 것입니다.\r\n1. 새 LTS 버전을 설치하고 새로운 환경(설치된 패키지가 없는 깨끗한 상태)에서 사용을 시작하겠다.\r\n2. 새 LTS 버전을 설치하지만 기존에 사용하던 패키지는 그대로 가져가서 새로운 버전에 기존의 환경을 유지하고 싶다.\r\n\r\n\r\n1번의 경우에는 간단하게 버전을 설치하고 설치한 버전을 사용하기로 설정하면 됩니다.\r\n2번의 경우는 새 버전을 설치하고 기존의 패키지를 가져오는 과정이 필요합니다.\r\n아래서 설명하겠습니다.\r\n\r\n## 사용하던 Node Version을 업데이트하기\r\n\r\n이 경우는 새로운 버전으로 업데이트하지만 기존의 패키지는 가져옵니다.\r\n사용하던 환경(패키지) 그대로 사용하면서 버전만 업데이트하고 싶은 경우입니다.\r\n\r\n그때 사용하는 명령은 아래와 같습니다.\r\n```bash\r\n> nvm install <version> --reinstall-packages-from=<version>\r\n```\r\n\r\n예를 들면 아래와 같습니다.\r\n```bash\r\n> nvm install 11.11.1 --reinstall-packages-from=10.16.2\r\n```\r\n\r\n위 명령어를 통해 새로운 `11.11.1` 버전을 설치하고 기존에 사용하던 버전 `10.16.2`의 패키지를 설치할 Node 버전(`11.11.1`)에 reinstall하는 과정을 거치게 됩니다.\r\n\r\n---- \r\n\r\nReferences\r\n- [github | nvm-sh/nvm](https://github.com/nvm-sh/nvm)\r\n","excerpt":"해당 포스트는 macOS 환경을 기준으로 작성되었습니다 NVM(Node Version Manager) Node 버전을 쉽게 관리 할 수 있다.\n예로 사용하던 패키지가 Node 버전이 업데이트를 함에 따라 호환이 되지 않을 경우가 생길 때 NVM…","fields":{"slug":"/nvm-install/"},"frontmatter":{"date":"Aug 08, 2019","title":"NVM, Node 설치 및 관리하기","tags":["node","javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nMongoDB 문서를 참고해,\r\nCheatSheet 개념으로 정리해본 기초 Mongo Shell CRUD 명령어.\r\n\r\n이 포스트에서는 기초적인 것만 다루며 `writeConcern` Option, Evaluation Query 등은 다루지 않습니다.\r\n\r\n\r\n## Database\r\n\r\n### Database 목록\r\n```bash\r\n> show databases\r\n```\r\n\r\n### Database 선택\r\n```bash\r\n> use db_name\r\n```\r\n> 존재하지 않는 DB 선택 시, 이후 DB 삽입등이 이루어지면 자동으로 생성된다.\r\n\r\n### Database 제거\r\n```bash\r\n> db.dropDatabase()\r\n```\r\n> 현재 선택되어있는 Database를 제거한다.\r\n\r\n\r\n\r\n## Collection\r\n\r\n### Collection 생성\r\n[`db.createCollection(name, [options])`](https://docs.mongodb.com/manual/reference/method/db.createCollection/index.html)\r\n```bash\r\n> db.createCollection(collection_name)\r\n```\r\n> 일반적으로 insert시 지정한 collection이 없는 콜렉션이면 자동으로 생성되므로 따로 Collection을 생성할 필요는 없지만 options를 활용하기 위해서는 createCollection을 사용한다.\r\n\r\n### Collection 제거\r\n```bash\r\n> db.collection_name.drop()\r\n```\r\n\r\n### Collection 이름 변경\r\n[`db.collection.renameCollection(target, [dropTarget])`](https://docs.mongodb.com/manual/reference/method/db.collection.renameCollection/)\r\n```bash\r\ndb.rrecord.renameCollection(\"record\")\r\n```\r\n\r\n\r\n\r\n## Insert\r\n\r\n### 하나의 Document 삽입\r\n[`db.collection.insertOne(document, [options])`](https://docs.mongodb.com/manual/reference/method/db.collection.insertOne/#db.collection.insertOne)\r\n```bash\r\n> db.collection_name.insertOne(\r\n  { name: \"Jhon\", age: 24 }\r\n)\r\n```\r\n\r\n### 여러 Document 삽입\r\n[`db.collection.insertMany(Array of documents, [options])`](https://docs.mongodb.com/manual/reference/method/db.collection.insertMany/#db.collection.insertMany)\r\n```bash\r\n> db.collection_name.insertMany(\r\n  [\r\n    { name: \"Jhon\", age: 24 },\r\n    { name: \"Darcy\", age: 26 },\r\n    { name: \"Ted\", age: 22 }\r\n  ]\r\n)\r\n```\r\n\r\n**ordered**: (boolean/default:true) Document를 기술한 순서대로 삽입\r\n```bash\r\n> db.collection_name.insertMany(\r\n  [\r\n    { name: \"Jhon\", age: 24 },\r\n    { name: \"Darcy\", age: 26 },\r\n    { name: \"Ted\", age: 22 }\r\n  ],\r\n  { ordered: true }\r\n)\r\n```\r\n\r\n\r\n\r\n\r\n## Query (find)\r\n\r\nuser Collection의 모든 Document 선택\r\n```bash\r\n> db.user.find()\r\n```\r\n\r\n**pretty()**: 결과를 읽기 좋은 형식으로 보여줌\r\n```bash\r\n> db.user.find().pretty()\r\n```\r\n\r\nCollection에서 name 필드의 값이 ‘Jhon’인 Dcoument 선택\r\n```bash\r\n> db.user.find({ name: \"Jhon\" })\r\n```\r\n\r\n### [비교 연산자](https://docs.mongodb.com/manual/reference/operator/query-comparison/#query-selectors-comparison) \r\n- $eq: 지정한 값과 같은\r\n- $gt: 지정한 값보다 큰\r\n- $gte: 지정한 값보다 크거나 같은\r\n- $in: 지정한 배열 안에 속하는\r\n- $lt: 지정한 값보다 작은\r\n- $lte: 지정한 값보다 작거나 같은\r\n- $ne: 지정한 값과 같지 않은\r\n- $nin: 지정한 배열 안에 속하지 않는\r\n\r\nCollection에서 level 필드의 값이 3이상인 Document 선택\r\n```bash\r\ndb.user.find(\r\n  {\r\n    level: { $gte: 3 }\r\n  }\r\n)\r\n```\r\n\r\nCollection에서 level 필드의 값이 2 또는 5 인 Document 선택\r\n```bash\r\n> db.user.find(\r\n  {\r\n    level: { $in: [2, 5] }\r\n  }\r\n)\r\n```\r\n\r\n\r\n### 논리 연산자\r\n- $or\r\n- $and\r\n- $not : 지정 조건이 false면 true, true이면 false\r\n- $nor : 모든 지정 조건이 false면 true\r\n\r\nCollection에서 status가 ‘A’이고 qty가 30 이상인 Document 선택\r\n```bash\r\n> db.inventory.find( \r\n  {\r\n    $and: [\r\n      { status: \"A\" },\r\n      { qty: { $lt: 30 } }\r\n    ]\r\n  }\r\n)\r\n\r\n> db.inventory.find( \r\n  { \r\n    status: \"A\", \r\n    qty: { $lt: 30 } \r\n  } \r\n)\r\n```\r\n> 위의 두 명령은 동일한 명령이라 할 수 있다.\r\n\r\nCollection에서 status가 ‘A’이거나 qty가 30 이상인 Document 선택\r\n```bash\r\ndb.inventory.find( { $or: [ { status: \"A\" }, { qty: { $lt: 30 } } ] } )\r\n```\r\n\r\n$and와 $or의 혼합 사용\r\n```bash\r\ndb.inventory.find( {\r\n     status: \"A\",\r\n     $or: [ { qty: { $lt: 30 } }, { item: /^p/ } ]\r\n} )\r\n```\r\n\r\n### Match an Embedded/Nested Document\r\n\r\n`comments: { author: \"Jhon\", comment: \"Good!\" }`를 완전히 일치 시킨 선택 명령\r\n```bash\r\ndb.users.find(\r\n  { comments: { author: \"Jhon\", comment: \"Good!\" } }\r\n)\r\n```\r\n> comments: { comment: \"Good!\" , author: \"Jhon\", } 를 선택할 시 순서가 달라 정확히 일치하지 않기 때문에 결과가 나오지 않습니다.\r\n\r\n### Query on Nested Field\r\n\r\n`{ size: { w: 20, h: 40 } }`와 같은 형식의 Document들이 있을 때 size 필드 안의 h 가 15 이상인 도큐먼트 선택\r\n```bash\r\ndb.inventory.find( { \"size.h\": { $lt: 15 } } )\r\n```\r\n\r\n### Query an Array\r\n\r\n#### Match an Array\r\ntags가 `[\"red\", \"blank\"]`로 요소와 순서 모두가 정확히 일치하는 Document 선택\r\n```bash\r\ndb.inventory.find( { tags: [\"red\", \"blank\"] } )\r\n```\r\n\r\ntag안에 red가 있는 document 선택\r\n```bash\r\ndb.inventory.find( { tags: \"red\" } )\r\n```\r\n\r\n#### $all\r\ntags가 ‘red’, ‘blank’ 두가지를 가지고 있는 Dcouments\r\n```bash\r\ndb.inventory.find( { tags: { $all: [\"red\", \"blank\"] } } )\r\n```\r\n> 순서와 상관없고, 정확히 일치하는게 아닌 포함하고 있으면 된다.\r\n\r\n#### $elemMatch\r\n`dim_cm: [12, 16]`와 같은 형식이 있다.\r\n`dim_cm` 배열 안에 22초과, 30미만의 값을 포함하고 있는 Document를 선택\r\n```bash\r\ndb.inventory.find( { dim_cm: { $elemMatch: { $gt: 22, $lt: 30 } } } )\r\n```\r\n\r\n#### Query for an Element by the Array Index Position\r\n`dim_cm` 배열의 1번째 index 요소가 25 초과인 Document 선택\r\n```bash\r\ndb.inventory.find( { \"dim_cm.1\": { $gt: 25 } } )\r\n```\r\n\r\n#### Query an Array by Array Length\r\ntags 배열의 길이가 3인 Document 선택\r\n```bash\r\ndb.inventory.find( { \"tags\": { $size: 3 } } )\r\n```\r\n\r\n### Query for Null or Missing Fields\r\n`{ _id: 1, item: null }, { _id: 2 }` 두개의 Document가 있다.\r\n아래는 item이 null인 document를 선택한다.\r\n```bash\r\ndb.inventory.find( { item: null } )\r\n```\r\n> { _id: 2 }도 item:null 이기 떄문에 두개의 Document가 모두 선택된다._\r\n아래와 같이 하면 첫번째 document만 정상적으로 선택할 수 있다.\r\n```bash\r\ndb.inventory.find( { item : { $type: 10 } } )\r\n```\r\n> [BSON types](https://docs.mongodb.com/manual/reference/bson-types/)\r\nitem이 존재하지 않는 Document를 선택한다.\r\n```bash\r\ndb.inventory.find( { item : { $exists: false } } )\r\n```\r\n\r\n\r\n\r\n## Update\r\n\r\n### [db.collection.updateOne(filter, update, options)](https://docs.mongodb.com/manual/reference/method/db.collection.updateOne/#db.collection.updateOne)\r\n`{ name: \"Jhon\", age: 29 }`에서 age를 25로 변경\r\n```bash\r\ndb.user.updateOne(\r\n  { name: \"Jhon\" },\r\n  { $set: { age: 25 } }\r\n)\r\n```\r\n\r\noptions의 upsert 속성을 사용하면 만약 Kay가 존재하지 않을 시 Document를 새로 만들며 업데이트 된다.\r\n```bash\r\n> db.user.updateOne(\r\n  {name:\"Kay\"},\r\n  { $set: { age: 25 } },\r\n  {upsert: true}\r\n)\r\n```\r\n\r\n배열 field에 값 추가하기 (`skills: []`)\r\n```bash\r\n> db.user.updateOne(\r\n  {name:\"Jhon\"},\r\n  {$push: {skills: 'react'}}\r\n)\r\n```\r\n\r\n배열 field에 값 추가하기 + 정렬\r\n```bash\r\n# 여러개 추가 시 $each 사용\r\n# 알파벳순으로 정렬시 $sort 사용\r\n\r\n> db.user.updateOne(\r\n  {name:\"Jhon\"},\r\n  {$push: \r\n    skills: {\r\n      $each: ['vue', 'angular'],\r\n      $sort: 1\r\n    }\r\n  }\r\n)\r\n```\r\n\r\n배열 field에 값 제거하기\r\n```bash\r\n> db.user.updateOne(\r\n  {name:\"Jhon\"},\r\n  {$pull: {skills: 'react'}}\r\n)\r\n```\r\n\r\n배열 field에서 여러값 제거하기\r\n```bash\r\n> db.user.updateOne(\r\n  {name:\"Jhon\"},\r\n  {$pull: {skills: $in: ['angular', 'vue']}}\r\n)\r\n```\r\n\r\n\r\n### [db.collection.updateMany(filter, update, options)](https://docs.mongodb.com/manual/reference/method/db.collection.updateMany/#db.collection.updateMany)\r\nlevel이 3이상인 document의 admin을 true로 변경\r\n```bash\r\ndb.user.updateMany(\r\n  { level: {$gte: 3} },\r\n  { $set: {admin: true} }\r\n)\r\n```\r\n\r\n### [db.collection.replaceOne(filter, replacement, options)](https://docs.mongodb.com/manual/reference/method/db.collection.replaceOne/#db.collection.replaceOne)\r\nname:”Kay”인 Document를 `{name:\"Kai\", age: 21}`로 교체한다.\r\n```bash\r\n> db.user.replaceOne(\r\n  {name:\"Kay\"},\r\n  {name:\"Kai\", age: 21}\r\n)\r\n```\r\n> 교체, 업데이트 후에도 도큐먼트의 ID는 유지된다.\r\n\r\n### [db.collection.update(query, update, options)](https://docs.mongodb.com/manual/reference/method/db.collection.update/#db.collection.update)\r\ndocumnet를 replace 하기\r\n```bash\r\n# 이름이 Jhon인 도큐먼트를 name Jun, age 21으로 교체\r\n\r\n> db.user.update(\r\n  {name:\"Jhon\"}, {name: \"Jun\", age: 21}\r\n)\r\n```\r\n\r\n여러 Document Update, options의 multi 속성이 필요하다, 또는 insertMany를 사용하는 방법도 있다.\r\n```bash\r\n> db.user.update(\r\n  {level: {$lte:3}},\r\n  {$set: {admin: false}},\r\n  {multi: true}\r\n)\r\n```\r\n\r\n\r\n\r\n## Delete\r\n\r\ninventory Collection안의 모든 Document가 삭제된다.\r\n```bash\r\ndb.inventory.deleteMany({})\r\n```\r\n\r\nCollection안의 status가 A인 Dcoument가 모두 삭제된다.\r\n```bash\r\ndb.inventory.deleteMany({ status : \"A\" })\r\n```\r\n\r\nCollection안의 status가 D인 Dcoument가 하나 삭제된다.\r\n```bash\r\ndb.inventory.deleteOne( { status: \"D\" } )\r\n```\r\n\r\n\r\n---- \r\n\r\nReferences\r\n- [MongoDB | Documentation](https://docs.mongodb.com/manual/)\r\n","excerpt":"MongoDB 문서를 참고해,\nCheatSheet 개념으로 정리해본 기초 Mongo Shell CRUD 명령어. 이 포스트에서는 기초적인 것만 다루며  Option, Evaluation Query 등은 다루지 않습니다. Database Database…","fields":{"slug":"/mongodb-basic-crud/"},"frontmatter":{"date":"Jul 30, 2019","title":"MongoDB 기초, CRUD 명령어","tags":["mongodb"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n![](screenshot.png)\r\n\r\n개발환경 구성에 앞서 제일 먼저 필요하다고 할 수 있는 터미널 환경 세팅.\r\n\r\n여기서는 **zsh** 쉘을 사용하며, **oh my zsh** 설치 후  \r\nzsh 플러그인 매니저인 **zplug**를 설치하여 플러그인을 관리합니다.  \r\n또한 터미널 앱으로는 **hyper**를 사용합니다.\r\n\r\nmacOS를 처음 설치해 깨끗한 상태에서 환경을 구성하는 과정으로 Brew 설치부터 시작하게 됩니다.\r\n\r\nHomeBrew가 설치되어있다면 Brew 설치 부분은 건너뛰면 됩니다.  \r\n또한 mac Catalina를 사용중이라면 zsh 설치 및 설정 부분은 건너뛰면 됩니다.\r\n\r\n> catalina 버전부터는 기본 쉘이 zsh로 설정되어 있어 설치 및 설정이 불필요\r\n\r\n## Brew 설치\r\n\r\nBrew 설치에 앞서 xcode command line tools의 설치가 필요합니다.\r\n\r\n_Xcode command line tools 설치_\r\n\r\n```bash\r\nxcode-select --install\r\n```\r\n\r\n_HomeBrew 설치_\r\n\r\n```bash\r\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\r\n```\r\n\r\n_zsh 설치_\r\n\r\n```bash\r\nbrew install zsh\r\n```\r\n\r\n_oh-my-zsh 설치_\r\n\r\n```bash\r\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\r\n```\r\n\r\n_기본 쉘 변경 (bash -\\> zsh)_\r\n\r\n```bash\r\nchsh -s `which zsh`\r\n```\r\n\r\n> non-standard shell 오류 발생 시\r\n> /etc/shells 파일에 `which zsh`를 통해서 확인한 경로를 최하단에 추가합니다.\r\n> 위 명령어를 다시 실행한 후 재부팅을 합니다.\r\n\r\n여기까지 했다면 터미널을 실행하면 zsh 쉘로 실행되는 것을 확인 할 수 있습니다.\r\n\r\n## zplug 설치 및 설정\r\n\r\n[https://github.com/zplug/zplug](https://github.com/zplug/zplug)\r\n\r\nzplug는 zsh 플러그인을 쉽게 설치 및 관리 할 수 있는 플러그인 매니저입니다.\r\n\r\n### zplug 설치\r\n\r\n```bash\r\n$ curl -sL --proto-redir -all,https https://raw.githubusercontent.com/zplug/installer/master/installer.zsh | zsh`\r\n```\r\n\r\n또는 `$ brew install zplug` 로 설치가 가능합니다.\r\n\r\n### zplug 설정\r\n\r\n`.zshrc` 파일을 수정합니다.\r\nvi, open, code 등 맘에 드는 방법으로 수정하시면 됩니다.\r\n\r\n```bash\r\nvi ~/.zshrc\r\n```\r\n\r\n`.zshrc` 파일의 내용을 전부 지우고, 아래 내용으로 대체합니다.\r\n\r\n```bash\r\n# .zshrc (use zplug)\r\n\r\nsource ~/.zplug/init.zsh\r\n\r\n# Plugins\r\nzplug \"plugins/git\",   from:oh-my-zsh\r\nzplug \"lib/completion\",   from:oh-my-zsh\r\nzplug 'lib/key-bindings', from:oh-my-zsh\r\nzplug \"lib/directories\",  from:oh-my-zsh\r\n\r\nzplug \"zsh-users/zsh-syntax-highlighting\"\r\nzplug \"zsh-users/zsh-autosuggestions\"\r\n\r\nzplug 'dracula/zsh', as:theme\r\n\r\n# Install plugins if there are plugins that have not been installed\r\nif ! zplug check --verbose; then\r\n    printf \"Install? [y/N]: \"\r\n    if read -q; then\r\n        echo; zplug install\r\n    fi\r\nfi\r\n\r\n# Then, source plugins and add commands to $PATH\r\nzplug load\r\n```\r\n\r\n기본적인 oh-my-zsh의 플러그인과,\r\n`zsh-syntax-highlighting`, `zsh-autosuggestions` 플러그인이 포함된 내용입니다.\r\n또한 테마는 `dracula` 를 사용하고 있습니다.\r\n\r\n기본적인 사용 방법은 아래서 설명할 것이고,\r\n자세한 설정 방법은 [공식 문서](https://github.com/zplug/zplug)를 참고하시기 바라며,\r\n아래는 본인이 사용하는 Plugin 작성 내용입니다.\r\n\r\n```bash\r\n...\r\n\r\n# Plugins\r\nzplug \"lib/completion\",   from:oh-my-zsh\r\nzplug \"lib/key-bindings\", from:oh-my-zsh\r\nzplug \"lib/directories\",  from:oh-my-zsh\r\n\r\nzplug \"plugins/git\",      from:oh-my-zsh\r\nzplug \"plugins/autojump\", from:oh-my-zsh, frozen:1\r\n\r\nzplug \"zsh-users/zsh-completions\",              defer:0\r\nzplug \"zsh-users/zsh-autosuggestions\",          defer:1, on:\"zsh-users/zsh-completions\"\r\nzplug \"zsh-users/zsh-syntax-highlighting\",      defer:1, on:\"zsh-users/zsh-autosuggestions\"\r\nzplug \"zsh-users/zsh-history-substring-search\", defer:2, on:\"zsh-users/zsh-syntax-highlighting\"\r\n\r\nzplug \"denysdovhan/spaceship-prompt\", use:spaceship.zsh, from:github, as:theme\r\n\r\nzplug \"djui/alias-tips\"\r\n\r\n...\r\n```\r\n\r\n위에서 autojump 플러그인 사용을 위해서는 아래와 같이 설치가 필요합니다.\r\n\r\n```bash\r\n$ brew install autojump\r\n```\r\n\r\n또한 위에서 spaceship-prompt 테마를 사용하기 위해서는 powerline font 설치가 필요합니다.\r\n\r\n다양한 zsh 플러그인은 [awesome-zsh-plugin](https://github.com/unixorn/awesome-zsh-plugins) 문서에서 확인 할 수 있습니다.\r\n\r\n### zplug 사용법\r\n\r\n#### 플러그인 추가\r\n\r\n기본적으로는 `.zshrc`를 수정하여 사용하는 것을 권장합니다.\r\n\r\n`zplug \"djui/alias-tips\"`와 같이\r\n`zplug \"[username]/[repository name]\"`의 형식으로 쉽게 플러그인을 추가할 수 있습니다.\r\n\r\n```\r\nzplug \"[username]/[repository name]\", [tag]:[value]\r\n```\r\n\r\n또한 위와 같이 태그를 추가할 수 있습니다.\r\n\r\n위에서 테마를 아래와 같이 표시한 것을 보면 알 수 있습니다.\r\n\r\n```\r\nzplug 'dracula/zsh', as:theme\r\n```\r\n\r\n[공식 문서](https://github.com/zplug/zplug)에 설명과 다양한 예가 있으니 참고하시기 바랍니다.\r\n\r\n`.zshrc`를 수정하는 방식이 아닌 zplug의 명령어로만 제어하는 방법이 있습니다.\r\n터미널에서 아래 명령어(위에서 설명한 방식의 문구와 동일합니다)를 실행하면\r\n\r\n```bash\r\n$ zplug \"djui/alias-tips\"\r\n```\r\n\r\n플러그인이 자동으로 추가가 됩니다.\r\n\r\n이렇게 추가된 플러그인은 `.zshrc`가 아닌 `~/.zplug/packages.zsh` 에 기록되어 있습니다.\r\n따로 확인하는 것이 어려우니 `.zshrc` 에서만 작업하는 것을 추천합니다.\r\n\r\n#### zplug 명령어\r\n\r\n[공식 문서 | Commands for zplug](https://github.com/zplug/zplug#2-commands-for-zplug)\r\n\r\n기본적으로 추가한 플러그인이 설치되어 있지 않다면 터미널 시작시 설치할 것을 묻습니다.\r\n그런데 명령어를 이용해 추가한 경우에는 아래 명령어를 통해 설치를 할 수 있습니다.\r\n\r\n```bash\r\n$ zplug install\r\n```\r\n\r\n방금 설치한 플러그인을 터미널 재실행 없이 반영하려면 아래 명령어를 사용합니다.\r\n`--verbose` 옵션을 추가하면 자세한 내역이 출력됩니다.\r\n\r\n```bash\r\n$ zplug load\r\nor\r\n$ zplug load --verbose\r\n```\r\n\r\n플러그인 업데이트: `zplug update`\r\n플러그인 리스트 출력: `zplug list`\r\n\r\n그 외 명령어는 공식 문서를 참고하시기 바랍니다.\r\n\r\n## Hyper\r\n\r\n[공식 사이트](https://hyper.is/)\r\n\r\nHyper는 iTerm 보다 성능면에서는 떨어질 수 있으나 디자인면에서는 뛰어나며, Electron으로 Javascript, css, html을 기반으로 개발된 오픈소스 터미널 앱입니다.\r\n\r\n### 설치\r\n\r\n공식 사이트에서 [다운로드](https://hyper.is/#installation)하거나 brew를 이용해 설치합니다\r\n\r\n```bash\r\n$ brew cask install hyper\r\n```\r\n\r\n### 설정 및 플러그인\r\n\r\n`~/.hyper.js` 파일을 수정하여 설정 및 플러그인 추가를 할 수 있습니다.\r\n폰트, 스타일 및 기타 설정 그리고 플러그인을 관리합니다.\r\n\r\n아래는 본인이 사용중인 플러그인 목록입니다.\r\n\r\n```\r\nmodule.exports = {\r\n  config: {\r\n  opacity: 0.95,\r\n\r\n  fontFamily: 'Hack, Menlo, \"DejaVu Sans Mono\", \"DejaVu Sans Mono for Powerline\", Consolas, \"Lucida Console\", monospace',\r\n\r\n  // ...\r\n\r\n  plugins: [\r\n    `hypercwd`,\r\n    `hyper-search`,\r\n    // `hyper-statusline`,\r\n    `hyper-quit`,\r\n    `hyper-opacity`,\r\n    `hyper-tab-icons`,\r\n    `hyper-materialshell`\r\n  ],\r\n\r\n// ...\r\n```\r\n\r\n위 설정을 그대로 사용할 경우 미리 'Hack', 'Powerline' 폰트 설치가 필요합니다.\r\n\r\n다양한 플러그인은 [awesome-hyper](https://github.com/bnb/awesome-hyper) 문서에서 확인할 수 있습니다.\r\n\r\n여기까지 본인과 같은 설정을 했다면 최상단의 이미지와 같은 터미널을 보실 수 있습니다.\r\n","excerpt":"개발환경 구성에 앞서 제일 먼저 필요하다고 할 수 있는 터미널 환경 세팅. 여기서는 zsh 쉘을 사용하며, oh my zsh 설치 후 zsh 플러그인 매니저인 zplug를 설치하여 플러그인을 관리합니다. 또한 터미널 앱으로는 hyper…","fields":{"slug":"/mac-terminal-setting/"},"frontmatter":{"date":"Jul 24, 2019","title":"mac 터미널 환경 구성하기 (zsh, oh my zsh, zplug, hyper)","tags":["mac"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nMongoDB를 본격적으로 사용하기 앞서,\r\n설치와 실행 그리고 추가적인 툴의 설치와 사용까지 기본적으로 알아보겠습니다.\r\n\r\nmacOS / HomeBrew의 설치 환경에서 진행됩니다.\r\n\r\n## Install MongoDB\r\n\r\nTap the MongoDB Homebrew Tap\r\n```bash\r\n$ brew tap mongodb/brew\r\n```\r\n\r\nInstall MongoDB\r\n```bash\r\n$ brew install mongodb-community@4.0\r\n```\r\n\r\nRun MongoDB\r\n```bash\r\n$ mongod --config /usr/local/etc/mongod.conf\r\n\r\n$ brew services start mongodb-community@4.0\r\n```\r\n\r\n> `brew services start mongodb-community@4.0`의 과정을 거치지 않는다면 mongo shell을 이용하기 전 `mongod`명령을 통해 mongo 서버를 키는 과정이 필요하다.\r\n\r\nConnect and Use MongoDB\r\n```bash\r\n$ mongo\r\n```\r\n\r\n## 설치 없이 실습하기\r\n\r\n[https://mws.mongodb.com/](https://mws.mongodb.com/)\r\n\r\n위 주소로 접속하여 스터디 용도로 MongoDB 가상환경 내에서 사용해 볼 수 있다.\r\nreset 버튼을 누르거나 오랜 시간 작업이 없거나, 웹페이지를 새로고침하면 데이터가 날아가니 주의할 것.\r\n","excerpt":"MongoDB를 본격적으로 사용하기 앞서,\n설치와 실행 그리고 추가적인 툴의 설치와 사용까지 기본적으로 알아보겠습니다. macOS / HomeBrew의 설치 환경에서 진행됩니다. Install MongoDB Tap the MongoDB Homebrew…","fields":{"slug":"/mongodb-install/"},"frontmatter":{"date":"Jul 20, 2019","title":"MongoDB 설치하기 (mac, homebrew)","tags":["mongodb"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n현재 mac Catalina developer beta의 환경으로 사용하고 있었는데,\r\n\r\n지금까지 설치한 앱들이 너무 많고 메뉴바 또한 넘처나기 직전이다.  \r\nbartender, dozer와 같은 메뉴바 정리 앱으로 정리를 했는데도 말이다.\r\n\r\n그래서 macOS를 Catalina public beta로 클린 설치하여 다시 한번 앱들을 설치하며 새로운 환경을 구성할 예정이다.\r\n\r\n그 전에 사용하던 앱들을 한번 정리해보고,  \r\n이를 바탕으로 클린 설치로 os를 설치하고 필요한 앱만 다시 설치하고 그렇지 않은 앱은 설치하지 않고 필요할 떄만 찾아 설치할 예정이다.  \r\n\r\n**필수 설치 Apps**는 고민 없이 바로 설치할 앱들이고,  \r\n**그 외 Apps**는 일단 설치하지 않고 사용하다 필요하면 설치할 앱들이다.\r\n\r\n:credit_card:는 유료앱을 나타내며  \r\n:small_blue_diamond:는 유료앱이며, SetApp에서 사용가능한 앱을 나타낸다.  \r\n(본인은 구독형 앱스토어라고 할 수 있는 SetApp이라는 서비스를 구독하고 있다. 구독하고 있으면 SetApp에 있는 앱들은 모두 무료로 받을 수 있다)\r\n\r\n## 필수 설치 Apps\r\n\r\n### CurserSense :credit_card:  \r\n\r\n  Apple Magic Mouse를 사용중이라면 필수 설치 앱  \r\n  워낙 느린 매직 마우스의 속도를 증가시킨다, 단순 증가가 아니라 가속도에 따른 조절 등\r\n  아주 디테일한 수정이 가능하다.\r\n\r\n### BetterTouchTool :small_blue_diamond:\r\n\r\n  터치바, 매직마우스, 트랙패드에 있어 다양한 제스처 및 동작을 특정 동작에 대입시킬 수 있는 앱이다. 워낙 많은 기능이 들어가있어 다 활용하기 어려울 정도이다.  \r\n  본인은 주로 매직마우스의 터치 제스처로 우클릭을 하거나, 키보드 + 제스처 조합으로 윈도우의 크기 및 배치를 조절하는 등의 기능을 사용하고 있다.\r\n\r\n### Alfred 4 \r\n\r\n  맥의 기본 Spotlight를 대체하는 앱  \r\n  웹, 파일, 폴더 검색 및 시스템 제어, 워크플로우 등 생산성에 많은 도움이 된다.  \r\n  워크플로우 등 풀버전 사용에는 라이센스 구입이 필요하다.\r\n\r\n### Amphetamine\r\n\r\n  맥이 잠들기 모드에 들어가지 않고 계속 꺠어있게 하는 앱이다.  \r\n  이러한 기능을 가진 다양한 앱들이 있지만 여러 앱을 사용해본 결과 디자인이나 기능 등 모든 면에서 사용성이 최고다.\r\n\r\n### Apple Apps\r\n  - Pages\r\n  - Keynotes\r\n  - Numbers\r\n  - Xcode\r\n\r\n### 한컴오피스 한글 뷰어\r\n\r\n### BusyCal :small_blue_diamond:\r\n\r\n  일정 관리 캘린더 앱, 기본 앱보다 사용하기 편리해서 사용하고 있다.\r\n\r\n### Bartender :small_blue_diamond:\r\n\r\n  메뉴바 정리 앱, 아이콘을 눌러 원하는 목록으로 펼치고 필 수 있으며 맥에 기본으로 있는 아이콘 또한 숨길 수 있다.\r\n\r\n### Canary Mail :small_blue_diamond:\r\n\r\n  메일 앱, 기본 앱보다 기능이 많고 편리하며 보기도 좋아 사용하고 있다.\r\n\r\n### Chrome\r\n\r\n### CleanMyMac :small_blue_diamond:\r\n\r\n  시스템 청소 앱이라 보면 되는데, 맥에서 굳이 필요할까 싶지만 숨겨진 용량이 큰 파일을 정리할때나 또는 런치패드 spotlight 캐시 정리 및 오류 해결 등에 사용할 일이 있어 사용하고 있다.\r\n\r\n### Dozer\r\n\r\n  메뉴바 정리 앱, 점 두개를 이용하여 왼쪽 점의 좌측에 위치한 앱들은 오른쪽 점 클릭을 통해 숨길 수 있다.  \r\n  본인은 Dozer와 Bartender 두 앱을 이용해 메뉴바 정리를 하고 있다.\r\n\r\n### Endurance :small_blue_diamond:\r\n\r\n  절전 모드 앱이라고 보면 된다. 절전 모드를 켜면 스크린 밝기나 백그라운드 앱 숨기기, 프로세스 속도 낮추기 등 기능이 작동하도록 설정해 배터리 절약에 도움이 된다. 배터리 30% 이하시 자동 절전 모드로 사용하고 있다.\r\n\r\n### firefox Developer Edition\r\n\r\n  개발자를 위한 파이어폭스 브라우저, 개발자 툴이 잘되어있다. 또 부가적으로 개발을 위한 다양한 기능을 제공한다.\r\n\r\n### keka\r\n\r\n  압축 앱\r\n\r\n### GPG Suite\r\n\r\n  gpg key 관리 프로그램\r\n\r\n### iStat Menus :small_blue_diamond:\r\n\r\n  메뉴바 관련 앱, 메뉴바에 배터리, 날씨, CPU, RAM 등 다양한 정보를 아이콘으로 띄울 수 있다.  \r\n  특히 본인의 경우 매직 마우스나, 매직 키보드, 에어팟을 연결하면 메뉴바에 각각의 배터리를 확인 할 수 있게 할 수 있어 유용하게 사용중이다.\r\n\r\n### MindNode\r\n\r\n  mindmap 작성 앱, xmind와 고민을 했는데 mindnode가 훨신 보기 좋아 선택하게 되었다.\r\n\r\n### NightOwl\r\n\r\n  mac의 darkmode, lightmode를 원하는 시간에 자동으로 변경시켜준다.  \r\n  mac Catalina에서는 auto가 생김에 따라 필요가 없어진 앱이라 할 수도 있지만 본인은 특정 앱은 항상 라이트모드를 유지시켜주는 기능때문에 사용하고 있다.\r\n\r\n### Paste\r\n  \r\n  클립보드 내역 저장 및 확인 앱, 복사한 내용이 모두 저장되어 있어 이전에 복사한 내용도 다시 사용할 수 있다.\r\n\r\n### Send Anywhere\r\n\r\n### Slack\r\n\r\n### Things :credit_card:\r\n\r\n  할일 관리 앱\r\n\r\n### TimeMachineEditor\r\n\r\n  원하는 시간에, 또는 원하는 간격으로 타임 머신 백업이 작동하게 한다.\r\n\r\n### Typora\r\n\r\n  마크다운 에디터, 라이브 프리뷰 기능때문에 자주 활용한다.\r\n\r\n### Ulysses :small_blue_diamond:\r\n\r\n  글쓰기 앱, 마크다운 포멧을 지원하며 다양한 포멧으로 내보내기가 가능하다.\r\n  글쓰기 앱 중에서 탑에 속하는 앱이다. (Bear와 고민했었는데 tag 방식의 정리방식 보다 폴더 방식을 선호해 이 앱을 선택하였다)\r\n\r\n### Visual Studio Code\r\n\r\n### Wake Up Time\r\n\r\n  알람 앱\r\n\r\n### Parallels Desktop :credit_card:\r\n\r\n\r\n## 그 외 Apps\r\n\r\n### Magnet :credit_card:\r\n\r\n  윈도우 정리 앱, 드래그 하여 창을 좌측의 반으로 위치하는 등 이러한 동작이 가능하게 해주는 앱이다.  \r\n  BetterTouchTool에서도 가능하게 할 수 있는 기능이라 BTT앱으로 통합해 이 앱은 사용하지 않을 예정\r\n\r\n### iTerm\r\n\r\n  터미널 앱, mac catalina에서는 기본적으로 쉘이 zsh를 사용한다. 따라서 처음에 터미널 설정이 간략화되었는데 그래서 이번에는 iTerm 대신 hyper를 사용하고, 출력이 많은 복잡한 작업에는 기본 터미널을 사용할 예정이다.\r\n\r\n### Boom 3D :small_blue_diamond:\r\n\r\n  음향 관련 앱이다. EQ 및 소리 증폭의 용도인데 본인은 소리 증폭의 용도로 사용하고 있었다.\r\n\r\n### Runcat\r\n\r\n  메뉴바에 뛰어다니는 고양이 아이콘이 생긴다. cpu사용양에 따라 달리는 속도가 달라진다.  \r\n  귀여워서 사용하고 있었지만 앱 최소화를 위해 기존 사용하던 iStat menus의 cpu 사용량을 사용할 예정\r\n\r\n### PopClip :credit_card:\r\n\r\n  텍스트 드래그시 다양한 기능을 사용할 수 있는 툴팁이 드래그 위치에 뜬다. 다양한 복사 방식, 번역, 다른 앱과 연동된 기능 등  \r\n  원치 않을 때 동작하는 경우가 가끔 있고 생각보다 불필요한 것 같아 일단 이번에는 설치 안해보는 것으로..\r\n\r\n### Sip :small_blue_diamond:\r\n\r\n  Color picker, 편하게 화면의 특정 부분 색상이 무엇인지 알아낼 수 있다.  \r\n  필수 앱으로 넣을까 고민이 되었는데, 아마도 필요에 의해 금방 설치하게 될 것 같다.\r\n\r\n### Timing :small_blue_diamond:\r\n\r\n  컴퓨터 사용량 기록 앱, 어떤 앱을 어떤 사이트를 얼마나 사용했는지 기록해준다.  \r\n  그를 바탕으로 생산성이 몇프로인지 계산해준다. 이번에 mac catalina에서 스크린 타임이 있어 불필요해진 앱이라는 소리를 듣고 있다. 그런데 스크린 타임은 우리가 기대하는 방식으로 동작하지 않아 timing 앱이 필요하긴 한 것 같은데 고민을 좀 해봐야겠다.\r\n","excerpt":"현재 mac Catalina developer beta의 환경으로 사용하고 있었는데, 지금까지 설치한 앱들이 너무 많고 메뉴바 또한 넘처나기 직전이다. bartender, dozer와 같은 메뉴바 정리 앱으로 정리를 했는데도 말이다. 그래서 macOS…","fields":{"slug":"/my-mac-apps/"},"frontmatter":{"date":"Jul 15, 2019","title":"사용중인 mac App 목록 및 앱 추천","tags":["mac"],"update":null}}},{"node":{"rawMarkdownBody":"\r\na, b, c.. 라는 함수가 있다고 가정하자.\r\n```js\r\na(b,c(d,e()));\r\n```\r\n위와 같이 함수가 중첩되고 연속된다면 가독성도 좋지않고 작성하는데도 어려움이 있다.\r\n함수들을 연속적으로 사용하는 함수, 함수들을 함축하는 함수인 go/pipe에 대해 알아보자\r\n\r\n## go\r\n\r\ngo 함수는 인자를 받아 결과를 바로 산출해내는 함수이다.\r\n첫번째 인자는 시작이 되는 **값**을 받고, 나머지는 **함수**를 받아 첫번째 인자가 두번째 함수로 가 결과를 만들고 그 결과가 또 세번째 함수로가 그 결과가 만들어지는 과정이 마지막까지 계속된다.\r\n\r\n```js\r\ngo(\r\n  0,\r\n  a + 1,\r\n  a * 10,\r\n  console.log\r\n)\r\n```\r\n\r\n위와 같이 함수를 실행했을 때 기대값은 10이며 마지막 함수(console.log)가 실행되면서 10이 출력되는 것을 기대할 수 있다.\r\n\r\n```js\r\nconst go = (...func) =>\r\n  func.reduce((previousFunc, curretFunc) => {\r\n    return curretFunc(previousFunc);\r\n  });\r\n```\r\n\r\n간단히 나타내면 위와 같다.\r\n\r\n## pipe\r\n\r\npipe 함수는 **함수를 리턴하는 함수**로 인자로 함수들을 받아 그 함수들을 합성해 하나의 함수를 리턴한다. go와는 반환하는 것이 다르다.\r\n\r\n```js\r\nlet pipe = () => () => {}; // 함수를 리턴하는 함수\r\n\r\nconst p = pipe(\r\n  a => a + 1,\r\n  a => a * 10\r\n);\r\n\r\nconsole.log(p(0));\r\n```\r\n\r\n위와 같은 코드 구성이 될 것이며 `p`에는 합성된 함수가, 그리고 그 `p`를 실행한 `p(0)`의 출력은 10이 나올 것으로 기대할 수 있다.\r\n```js\r\npipe = (...funcs) => argument => funcs.reduce((acc, func) => func(acc), argument);\r\n\r\nconst p = pipe(\r\n  a => a + 1,\r\n  a => a * 10\r\n);\r\n\r\nconsole.log(p(0));\r\n```\r\n\r\npipe 함수를 작성하는 과정을 쪼개보면 아래와 같다\r\n```js\r\npipe = (...funcs) => {};\r\n// pipe 함수는 인자로 함수들을 받는다.\r\n\r\npipe = (...funcs) => () => {};\r\n// 함수를 리턴하게 될 것이다.\r\n\r\npipe = (...funcs) => argument => {};\r\n// 여기서 argument는 pipe 함수가 실행되어 함축된 함수, 그 함수의 매개 변수이다.\r\n\r\npipe = (...funcs) => argument => funcs.reduce(() => {}, argument);\r\n// 함수들을 함축해야 하므로 pipe의 인자로 들어온 함수들에 reduce를 사용한다.\r\n// reduce의 시작으로 함축된 함수의 매개변수인 argument를 전달해준다. (argument: 값)\r\n\r\npipe = (...funcs) => argument => funcs.reduce((acc, func) => func(acc), argument);\r\n// 이제 위와 같이 reduce의 첫번째 인자를 채워준다.\r\n// 처음 reduce가 실행될 때는 acc가 pipe 함수의 실행 결과인 함수의 인자 **값**이 들어간다.\r\n// 다음부터는 그 함수의 실행 결과 값이 acc가 되어 누산되는 과정이 된다.\r\n```\r\n\r\n작성한 pipe 코드에서 마지막 reduce의 동작은 go와 거의 같기 때문에 아래와 같이 작성해도 같은 코드라 할 수 있다.\r\n```js\r\npipe = (...funcs) => (argument) => go(argument, ...funcs);\r\n```\r\n\r\ngo의 경우에도 pipe 코드를 활용하여 작성 할 수 있다.\r\n결국 pipe를 실행해 함축된 함수를 실행하면 go를 한 동작과 거의 동일하기 때문이다.\r\n물론 위의 pipe에 go를 활용한 코드와 함께 사용은 불가하다.\r\n```js\r\ngo = (...fns) => {\r\n  const [argument, ...funcs] = fns;\r\n  return pipe(...funcs)(argument);\r\n  // 또는 return pipe.apply(null, funcs)(argument);\r\n}\r\n```\r\n\r\n\r\n---\r\n\r\nReferences\r\n- [inflearn | 함수형 프로그래밍과 JavaScript ES6+](https://www.inflearn.com/course/functional-es6)\r\n","excerpt":"a, b, c.. 라는 함수가 있다고 가정하자. 위와 같이 함수가 중첩되고 연속된다면 가독성도 좋지않고 작성하는데도 어려움이 있다.\n함수들을 연속적으로 사용하는 함수, 함수들을 함축하는 함수인 go/pipe에 대해 알아보자 go go…","fields":{"slug":"/functional-go-pipe/"},"frontmatter":{"date":"Jul 12, 2019","title":"JavaScript 함수형 프로그래밍, go / pipe","tags":["javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n\r\n\r\n이터러블 프로토콜은 ES6에서 도입된 것으로 간단히 말하면 \r\n**이터러블 프로토콜은 순회(반복) 가능한 객체를 나타내는 프로토콜**이라 할 수 있다.\r\n\r\n`for...of` 반복문, `...` 전개 연산자(Spread Operator), 구조 분해 등과 함께 동작 할 수 있도록 한 프로토콜이다. 이 말은 이터러블이여야만 이러한 동작이 가능하다는 것을 뜻하기도 한다.\r\n\r\n## iterable/iterator\r\n\r\n- 이터러블: 이터레이터를 반환하는 `Symbol.iterator`라는 키값의 메소드를 가진 객체\r\n- 이터레이터: `{ value, done }` 객체를 반환하는 `next()` 메소드를 가진 객체\r\n\r\n이제 예제를 통해 살펴보자.\r\n\r\n```js\r\nconst arr = [1, 2, 3];\r\n\r\nfor(const n of arr) {\r\n  console.log(n);\r\n}\r\n// 1 2 3\r\n\r\nconsole.log(...arr);\r\n// 1 2 3\r\n\r\nconst [first, ...remain] = arr;\r\nconsole.log(first, remain); // 1, [2, 3]\r\n```\r\n\r\n위는 일반적인 배열의 값들을 for...of 반복문으로 출력한 것이다.\r\n(예를 든 Array 외에도 이터러블이 가능한 반복가능한 객체로는 Map, Set, String, TypedArray, arguments 객체 등이 있다)\r\n앞서 말했듯 for...of 순회가 가능한 이유는 이터러블이기 때문인데 그것을 아래에서 확인해보자\r\n\r\n```js\r\nconsole.dir(arr);\r\n\r\n/*\r\n> Array(3)\r\n  > __proto__ : Array(0)\r\n     ...\r\n     > Symbol(Symbol.iterator): ƒ values()\r\n     ...\r\n*/\r\n```\r\n\r\n우선 Array의 내부(프로토타입 체인 내)에서 `Symbol(Symbol.iterator): ƒ values()`를 확인 할 수 있다.\r\nArray에는 `Symbol(Symbol.iterator)`라는 key를 가진 함수가 존재한다는 것을 알 수 있고 앞서 설명한 **이터레이터를 반환하는 `Symbol.iterator`라는 키값의 메소드를 가진 객체**에 부합하는 것을 볼 수 있다.\r\n\r\n만약 위의 코드를 아래와 같이 하면 어떻게 될까\r\n\r\n```js\r\nconst arr = [1, 2, 3];\r\n\r\narr[Symbol.iterator] = null;\r\n\r\nfor(const n of arr) { // Uncaught TypeError: arr is not iterable\r\n  console.log(n);\r\n}\r\nconsole.log(...arr);\r\n```\r\n\r\n`arr[Symbol.iterator] = null;`을 통해 이제 더이상 배열 arr은 이터러블이 아니게 되었다.\r\n그래서 for...of에서 arr은 이터러블이 아니라는 오류를 만나게 된다. 전개 연산자도 마찬가지다.\r\n\r\n여기까지 이터러블의 모습까지 확인해보았고 다음으로는 이터레이터를 확인해보자.\r\n\r\n`arr[Symbol.iterator]`는 함수이다. 그렇다면 `arr[Symbol.iterator]()`를 한다면 반환되는 것은 이터레이터가 될 것이다.\r\n\r\n```js\r\nconst arrIter = arr[Symbol.iterator]();\r\n\r\nconsole.log(arrIter); // Array Iterator {}\r\n```\r\n\r\n위 코드를 통해 반환된 것이 이터레이터 객체인 것을 확인했다.\r\n\r\n이터레이터는 **`{ value, done }` 객체를 반환하는 `next()` 메소드를 가진 객체**라고 했었는데 `next()` 메소드를 확인해보자.\r\n\r\n```js\r\nconsole.log(arrIter.next()); // {value: 1, done: false}\r\nconsole.log(arrIter.next()); // {value: 2, done: false}\r\nconsole.log(arrIter.next()); // {value: 3, done: false}\r\nconsole.log(arrIter.next()); // {value: undefined, done: true}\r\nconsole.log(arrIter.next()); // {value: undefined, done: true}\r\n```\r\n\r\n보는 것과 같이 `{ value, done }` 객체가 반환 된 것을 볼 수 있다.\r\nvalue값이 있을 때는 done이 false를 가지고, 이제 순회할 것이 없는 상황에는 done이 true를 가진다.\r\n\r\n또 다른 예제를 살펴보자.\r\n\r\n```js\r\nconst arrIter2 = arr[iterator]();\r\n\r\narrIter2.next();\r\n\r\nfor(const v of arrIter2){\r\n\tconsole.log(v);\r\n}\r\n// 2 3\r\n```\r\n\r\n반복문 전에 `next()`를 한번 해서 첫번째 값은 출력이 안된 모습을 확인 할 수 있다.\r\n\r\n## 사용자 정의 iterable protocol\r\n\r\n이터러블 프로토콜을 따라서 또한 순회 동작을 사용자 정의할 수 있다는 점이 이터러블을 활용하는데 있어 중요한 의의를 가진다.\r\n\r\n```js\r\nconst reverseIterable = a => {\r\n  return {\r\n    [Symbol.iterator]() {\r\n      let i = a.length;\r\n\r\n      return {\r\n        next() {\r\n          return i === 0 ? { value: undefined, done: true } : { value: i--, done: false };\r\n        },\r\n        [Symbol.iterator]() {\r\n          return this;\r\n        }\r\n      };\r\n    }\r\n  };\r\n};\r\n\r\nconst reverseArr = reverseIterable(arr);\r\nfor (const v of reverseArr) console.log(v); // 3 2 1\r\n\r\nconst reverseArrIter = reverseArr[Symbol.iterator]();\r\nconsole.log(reverseArrIter.next()); // {value: 3, done: false}\r\nfor (const v of reverseArrIter) console.log(v); // 2 1\r\n```\r\n\r\n위 코드는 일반적인 이터러블 순회를 반대 순서로 순회가 되도록 바꿔 본 커스텀 이터러블이다.\r\n\r\n부분적으로 자세히 살펴보자.\r\n\r\n이터러블은 **이터레이터를 반환 `Symbol.iterator`의 키값의 메소드를 가진 객체**라 했었으니\r\n아래와 같이 `return { [Symbol.iterator](){...} }` 와 같이 시작할 것이다.\r\n\r\n```\r\nconst reverseIterable = (a) => {\r\n  return {\r\n    [Symbol.iterator]() {\r\n      // ... \r\n    }\r\n  };\r\n};\r\n```\r\n\r\n또한 이터레이터는 **`{ value, done }` 객체를 반환하는 `next()` 메소드를 가진 객체**라 했었으니 아래와 같은 구조여야한다.\r\n\r\n```js\r\nconst reverseIterable = (a) => {\r\n  return {\r\n    [Symbol.iterator]() {\r\n      next() {\r\n            return { value: ..., done: ... }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n```\r\n\r\n이렇게 여기까지 작성한 코드는 아래와 같다.\r\n\r\n```js\r\nconst reverseIterable = (a) => {\r\n  return {\r\n    [Symbol.iterator]() {\r\n      let i = a.length;\r\n\r\n      return {\r\n        next() {\r\n          return i === 0 ? { value: undefined, done: true } : { value: i--, done: false };\r\n        }\r\n      };\r\n    }\r\n  };\r\n};\r\n```\r\n\r\n이터러블/이터레이터 프로토콜의 조건을 모두 갖춘 것 같다.\r\n맨 위의 완성된 코드가 아닌 바로 위의 코드로 한번 아래 코드를 실행해보자\r\n\r\n```js\r\nconst reverseArr = reverseIterable(arr);\r\n\r\nfor(const v of reverseArr) console.log(v); // 3 2 1\r\n```\r\n\r\n정상적으로 원하는 동작이 된 것 같다.\r\n하지만 아래의 방법으로 실행해보면 에러가 발생한다\r\n\r\n```js\r\nconst reverseArrIter = reverseArr[Symbol.iterator]();\r\n\r\nconsole.log(reverseArrIter.next()); // {value: 3, done: false}\r\n\r\nfor(const v of reverseArrIter) console.log(v);\r\n// Uncaught TypeError: reverseArrIter is not iterable\r\n```\r\n\r\n그 이유는 `reverseArr`의 경우에는 사용자가 정의한  `[Symbol.iterator]()`를 가지고 있어 이터러블하지만 `reverseArr[Symbol.iterator]()`를 통해 만든 이터레이터`reverseArrIter`는 이터레이터의 조건인 **`{ value, done }` 객체를 반환하는 `next()` 메소드를 가진 객체**는 만족하지만 내부(프로토타입 체인)에 `[Symbol.iterator]()`를 가지고 있지 않아 이터러블 하지 않기 때문이다.\r\n\r\nconsole.dir을 이용해 위에서 사용한 `arrIter`를 살펴보면 내부에 `[Symbol.iterator]()`를 가지고 있고 `reverseArrIter`는 그렇지 않은 것을 확인 할 수 있다.\r\n\r\n따라서 코드에서 `next()`와 함께 `[Symbol.iterator]() { return this }`를 리턴해 이터러블하게 해준 것이라 할 수 있다.\r\n\r\n이러하게 이터러블 프로토콜을 사용자 정의해서 사용할 수 있다면 순회 동작에 사용자가 원하는 동작을 넣을 수도 있고 더 나아가 원래 이터러블하지 않는 것조차 순회가 가능하게 이터러블하게 만들어 순회할 수 있게 될 수 있다.\r\n\r\n### 제너레이터\r\n\r\n```js\r\nfunction* gen() {\r\n  yield 1;\r\n  if(false) yield 2;\r\n  yield 3;\r\n  return 4;\r\n}\r\n\r\nconst gIter = gen();\r\n\r\nconsole.log(gIter.next()); \r\n// {value: 1, done: false}\r\n\r\nconsole.log(gIter[Symbol.iterator]);\r\n// ƒ [Symbol.iterator]() { [native code] }\r\n\r\nfor(const v of gIter) console.log(v);\r\n```\r\n\r\n제너레이터의 실행 결과인 제너레이터 객체는 이터레이터 객체이다.\r\n위 코드에서 `gIter.next()`가 가능한 것을 보면 알 수 있다.\r\n또한 `[Symbol.iterator]()`를 가지는 이터러블이기도 하다.\r\n\r\n제너레이터 객체는 이터레이터이자 이터러블이기 때문에 역시 순회가 가능하다.\r\n또한 제너레이터에는 마지막에 리턴 값을 만들 수 있다. 하지만 `done` 또한 `ture`가 되기 때문에 **순회의 대상이 되진 않는다.**\r\n\r\n이러한 제너레이터를 이용하면 위에서 사용자 정의 이터러블을 해본 것을 더 간단하게 바꿀 수 있다.\r\n\r\n```js\r\nfunction* gen2(a) {\r\n  let i = a.length;\r\n\r\n  while (i--) {\r\n    yield a[i];\r\n  }\r\n}\r\n\r\nconst g2Iter = gen2([1, 2, 3]);\r\nconsole.log(g2Iter.next()); // {value: 3, done: false} \r\nconsole.log(g2Iter.next()); // {value: 2, done: false}\r\nconsole.log(g2Iter.next()); // {value: 1, done: false}\r\n```\r\n\r\n## 정리\r\n\r\n- 이터러블 프로토콜: 순회(반복) 가능한 객체를 나타내는 프로토콜, 이터러블이면 순회가 가능하다.\r\n- 이터러블: 이터레이터를 반환하는 `Symbol.iterator`라는 키값의 메소드를 가진 객체\r\n- 이터레이터: `{ value, done }` 객체를 반환하는 `next()` 메소드를 가진 객체\r\n\r\n- 이터러블 프로토콜을 사용자 정의 할 수 있음에 따라 원하는 객체를 지정한 동작에 따라 순회할 수 있게 되어 원하는 값을 추출해내고 다양한 객체에 이를 적용해 결과를 얻을 수 있게 되었다.\r\n\r\n- 기본적으로 반복이 가능한 것으로는 (iterable이 내장되어있다) String, Array, TypedArray, Map, Set가 있다.\r\n\r\n---\r\n\r\nReferences\r\n- [MDN | The iterable protocol](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Iteration_protocols#iterable \"MDN | The iterable protocol\")\r\n- [https://ahnheejong.gitbook.io/ts-for-jsdev/02-ecmascript/element-enumeration/iterable-protocol](https://ahnheejong.gitbook.io/ts-for-jsdev/02-ecmascript/element-enumeration/iterable-protocol)\r\n","excerpt":"이터러블 프로토콜은 ES6에서 도입된 것으로 간단히 말하면 \n이터러블 프로토콜은 순회(반복) 가능한 객체를 나타내는 프로토콜이라 할 수 있다.  반복문,  전개 연산자(Spread Operator…","fields":{"slug":"/iterable-protocol/"},"frontmatter":{"date":"Jul 10, 2019","title":"이터러블 프로토콜, 이터러블/이터레이터","tags":["ES6","javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nAJAX(**A**synchronous**J**avaScript**A**nd**X**ML)는 비동기 자바스크립트를 뜻하는 것으로, 이제는 비동기적 자바스크립트 동작을 하는 기술들을 통들어서도 AJAX라고 부릅니다.\r\n\r\n최초로 Microsoft의 Internet Explorer가 탑재하기 시작했고, AJAX가 주족받고 웹 기술에서 빠지지 않는 주요 기술로 부상한 것은 Google의 Gmail과 Map으로 부터라고 할 수 있습니다.\r\n\r\n**이 포스트는 AJAX의 대표적인 API인  XMLHttpRequest와 Fetch의 기본적인 사용법과 속성들을 살펴봅니다.**\r\n\r\nAJAX하면 예전에는 XMLHttpRequest API를 이용하는 것이 일반적이었으며,\r\n그리고 불편함을 느낀 사람들이 jQuery를 통해 AJAX를 구현하기 시작했고 그 이후로 Fetch API가 ES2015 표준으로 등장하면서 이제는 일반적으로 Fetch API를 통해 구현하는 것이 일반적이 되었습니다. 이 포스트에서는 jQuery는 살펴보지 않겠습니다.\r\n\r\n## XMLHttpRequest\r\n [MDN - XMLHttpRequest](https://developer.mozilla.org/ko/docs/Web/API/XMLHttpRequest)\r\n\r\n우선 XMLHttpRequest로 AJAX를 구현하는 예를 보겠습니다.\r\n`/src/data.json`를 불러와보는 코드입니다.\r\n`/src/data.json`의 내용은 `{ \"name\": \"Jhon\", \"age\": 29 }` 입니다.\r\n\r\n\r\n```js\r\n(function() {\r\n  // XHR 인스턴스 생성\r\n  const httpRequest = new XMLHttpRequest();\r\n\r\n  // httpRequest의 내장 함수 onreadystatechange를 이용해\r\n  // 서버 상태의 변화에 따라 코드를 작성 할 수 있습니다.\r\n  httpRequest.onreadystatechange = event => {\r\n    console.log(\r\n      `state : ${httpRequest.readyState} / status : ${httpRequest.status} / ${responseReady()}`\r\n    );\r\n  };\r\n\r\n  // 서버로부터 응답을 받았는지와 정상적으로 처리된 응답인지를 검사하는 함수\r\n  const responseReady = () => {\r\n    try {\r\n      if (httpRequest.readyState === XMLHttpRequest.DONE) {\r\n        if (httpRequest.status === 200) {\r\n\t\t\t// 응답을 정상적으로 받음\r\n          return httpRequest.responseText;\r\n        } else {\r\n          return Error('request에 문제가 있습니다.');\r\n        }\r\n      } else {\r\n        return Error('request의 상태가 complete(4)가 아닙니다.');\r\n      }\r\n    }\r\n    catch( e ) {\r\n      return Error('Caught Exception: ' + e.description);\r\n    }\r\n  }\r\n\r\n  httpRequest.open(\"GET\", \"/src/data.json\");\r\n  httpRequest.send();\r\n})();\r\n```\r\n\r\n코드를 살펴보겠습니다.\r\n\r\n`const httpRequest = new XMLHttpRequest();` \r\n생성자를 이용해 XHR 객체 인스턴스를 생성합니다\r\n\r\n`httpRequest.onreadystatechange` \r\nonreadystatechange 내장 함수를 이용하여 서버의 상태에 따른 코드를 작성합니다. 내부의 코드 console.log를 살펴보면 아래와 같습니다.\r\n\r\n```js\r\nconsole.log(\r\n      `state : ${httpRequest.readyState} / status : ${httpRequest.status} / ${responseReady()}`\r\n    );\r\n```\r\n\r\n여기서 readyState는 서버의 응답 상태를 나타내며 아래 목록의 값을 가질 수 있습니다.\r\n- 0 (uninitialized) -(**request가 초기화되지 않음**)\r\n- 1 (loading) -(**서버와의 연결이 성사됨**)\r\n- 2 (loaded) -(**서버가 request를 받음**)\r\n- 3 (interactive) -(**request(요청)을 처리하는 중**)\r\n- 4 (complete) -(**request에 대한 처리가 끝났으며응답할 준비가 완료됨**)\r\n\r\nstatus code에 대한 설명은 생략합니다.\r\n\r\n그리고 responseReady() 함수의 반환값이 마지막으로 위치합니다.\r\n\r\n여기까지가 요청에 따른 응답을 처리하는 코드를 작성한 부분이고\r\n\r\n```js\r\n  httpRequest.open(\"GET\", \"/src/data.json\");\r\n  httpRequest.send();\r\n```\r\n\r\n이 open, send 부분이 요청을 하는 부분입니다. 이 코드로 인해 지금까지 설명한 코드들이 실행되게됩니다.\r\n\r\nopen을 하면 위에서 설명한 state가 1번까지 실행되며\r\nsend를 하면 4번까지 작동하며 응답을 받을 수 있게 됩니다.\r\n\r\nopen 메소드의 파라미터\r\n- 첫번째로 HTTP 요청 메소드(GET,  POST, HEAD)가 위치하게 됩니다.\r\n- 두번째 파라미터는 요청 URL로 주소 또는 경로가 될 수 있습니다.\r\n- 세번째 파라미터는 생략가능하며 요청이 비동기적으로 실행될지 여부를 결정합니다. \r\n\t- default: true\r\n\t- false로 설정된 경우 동기적으로 작동합니다. (send()함수에서 서버로부터 응답이 올 때까지 기다림)\r\n\r\n아래는 지금까지 코드의 콘솔 출력입니다.\r\n\r\n```bash\r\n< state : 1 / status : 0 / Error: request의 상태가 complete(4)가 아닙니다. \r\n\r\n< state : 2 / status : 200 / Error: request의 상태가 complete(4)가 아닙니다. \r\n\r\n< state : 3 / status : 200 / Error: request의 상태가 complete(4)가 아닙니다. \r\n\r\n< state : 4 / status : 200 / { \"name\": \"Jhon\", \"age\": 29 }\r\n```\r\n\r\nstate가 4로 즉 `XMLHttpRequest.DONE`이며 complete 상태일때 응답을 받을 수 있는 상태가 되었고 응답을 받은 것을 확인 할 수 있습니다.\r\n\r\n## Fetch\r\n기존의 XHR 객체를 이용한 AJAX는 복잡하기도 하며 가독성이 떨어졌었습니다. 그래서 등장한 것이 Fetch API로 ES6(ES2015)에서 표준이 되었습니다.\r\nFetch는 반환값으로 Promise를 가집니다. 이 또한 ES6에 등장한 것으로 여기서는 이에 대해 자세히 설명하지 않고 기본적인 사용법을 기술합니다.\r\n\r\n```js\r\nfetch( resource, init )\r\n  .then( callback )\r\n  .catch( callback )\r\n```\r\n\r\n기본적으로 fetch는 이러한 구조를 가집니다.\r\n\r\nfetch의 파라미터\r\n- resource : 요청 주소, URL, 경로\r\n- init (optional) : 설정 객체\r\n\r\n아래는 설정 객체의 예\r\n```js\r\nconst init = {\r\n  method: \"POST\",\r\n\tbody: JSON.stringify(data),\r\n\theaders: {\r\n    \"Content-Type\": \"application/json\"\r\n  },\r\n\tcredentials : \"same-origin\"\r\n}\r\n```\r\n설정 객체의 요소들은 아래 링크에서 확인할 수 있습니다.\r\n[fetch() #parameters | MDN](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\r\n\r\n이제 간단한 예제를 살펴보겠습니다.\r\n\r\n```js\r\n// data.json : {name: \"Jhon\", age: 29}\r\n\r\nfetch('/src/data.json')\r\n  .then(response => {\r\n    // 첫번째 then\r\n    if(response.status === 200){\r\n      return response.json()\r\n    } else {\r\n      console.log(response.statusText);\r\n    }\r\n  })\r\n  .then(jsonData => {\r\n    // 두번째 then\r\n    console.log(jsonData); // Object {name: \"Jhon\", age: 29}\r\n  })\r\n  .catch(err => {\r\n    console.log(err)\r\n  })\r\n```\r\n\r\nfetch에 요청할 경로를 적고 필요의 경우 설정 객체 또한 전달합니다.\r\n그 결과로 Response 인스턴스가 반환됩니다. 첫번째 then에서 response가 그것입니다. Response 객체의 속성들을 살펴보면 상태를 나타내는 status(정수), statusText(문자)가 있고 요청에 대한 헤더 정보를 담고 있는 header, 그리고 응답 내용을 담고 있는 body가 있습니다.\r\n\r\n위의 코드를 살펴보면 fetch 요청 후,\r\n첫번째 then에서 상태 코드가 200일 경우 response.json()을 리턴하며, 상태 코드가 다를 경우에는 상태 문자를 출력합니다.\r\n두번째 then으로 넘겨지게 되면 이제 첫번째 then에서 넘겨받은 값을 출력하게 됩니다.\r\n\r\n조금 더 자세히 살펴보면\r\n첫번째 then에서 response.json()을 바로 출력하지 않고 다음 then으로 리턴하여 넘겨준 것은 response.json()은 기대하는 실제 값이 아닌 Promise를 가지고 있기 때문입니다. 이 과정을 살펴보면 아래와 같습니다.\r\n\r\nResponse 객체의 body 값을 추출해내기 위해서는 타입에 따라 아래와 같은 메소드를 사용해야 합니다.\r\n- arrayBuffer()\r\n- blob()\r\n- json()\r\n- text()\r\n- formData()\r\n\r\n위 메소드들은 모두 Promise를 반환합니다. 그리고 이 Promise가 resolve되어 다음 then에서는 실제 값을 다룰 수 있게 됩니다.\r\n\r\n여기까지가 기본적인 내용이며 실제 사용 할 때는 필요에 따라 심화로 init object, Header, Request에 대해서 알아보고 사용하는 것이 좋습니다.\r\n---- \r\nReferences\r\n- [Ajax 시작하기 - 웹 개발자 안내서 | MDN](https://developer.mozilla.org/ko/docs/Web/Guide/AJAX/Getting_Started)\r\n- [MDN - XMLHttpRequest](https://developer.mozilla.org/ko/docs/Web/API/XMLHttpRequest) \r\n- [WindowOrWorkerGlobalScope.fetch() - Web APIs | MDN](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch)\r\n- [정말 멋진 Fetch API! | Mozilla 웹 기술 블로그](http://hacks.mozilla.or.kr/2015/05/this-api-is-so-fetching/)\r\n","excerpt":"AJAX(AsynchronousJavaScriptAndXML)는 비동기 자바스크립트를 뜻하는 것으로, 이제는 비동기적 자바스크립트 동작을 하는 기술들을 통들어서도 AJAX라고 부릅니다. 최초로 Microsoft의 Internet Explorer…","fields":{"slug":"/ajax-xhr-fetch/"},"frontmatter":{"date":"May 14, 2019","title":"AJAX, XMLHttpRequest와 Fetch 살펴보기","tags":["javascript","ajax","ES6"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n**(macOS Mojave 환경에서의 포스팅입니다)**\r\n\r\npyenv는 nvm(Node Version Manager)과 비슷하게 필요에 따라 다양한 파이썬 버전으로 실행할 수 있는 환경을 제공하는 버전 매니저이다.\r\n\r\n프로젝트별 버전을 달리 사용하는 용도가 아니더라도 macOS에서 Python을 설치하고 디폴트 버전을 바꾸는 등 설정을 하는 과정보다 pyenv를 사용하는 것이 훨씬 간편하다.\r\n\r\n## pyenv 설치\r\n\r\n우선 pyenv를 설치하기 위해 패키지 관리자인 HomeBrew가 설치되어있어야 한다. HomeBrew가 설치되지 않았다면 터미널에서 아래 명령어를 통해 설치한다.\r\n\r\n```shell\r\n$ ruby -e \"$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)”\r\n```\r\n\r\nHomeBrew가 준비되었다면 아래 명령어로 pyenv를 설치한다.\r\n\r\n```shell\r\n$ brew install pyenv\r\n```\r\n\r\n## Python 설치\r\n\r\npyenv 설치 후 아래 명령어를 통해 pyenv를 통해 설치할 수 있는 리스트를 확인 할 수 있다.\r\n\r\n```shell\r\n$ pyenv install --list\r\n```\r\n\r\n확인된 리스트에서 원하는 버전을 선택해 설치한다. 예로 3.7.2 버전을 아래 명령어를 통해 설치한다.\r\n\r\n```shell\r\n$ pyenv install 3.7.2\r\n```\r\n\r\nmacOS 버전이 Mojave라면 인스톨 단계에서 에러가 발생할 수 있는데 에러가 발생했다면 아래 명령어를 실행 후 다시 인스톨하면 된다.\r\n\r\n```shell\r\n$ sudo installer -pkg /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg -target /\r\n```\r\n\r\n설치 후에는 아래 명령어를 통해 확인해 볼 수 있다. 아래 명령어는 pyenv를 통해 설치된 리스트를 확인 할 수 있다.\r\n\r\n```shell\r\n$ pyenv versions\r\n```\r\n\r\n이제 설치한 버전을 글로벌 환경에서 디폴트로 사용할 수 있도록 지정해준다.\r\n\r\n```shell\r\n$ pyenv global 3.7.2\r\n```\r\n\r\n지정 후에 적용하려면 아래 명령어가 필요하다.\r\n\r\n```shell\r\n$ eval \"$(pyenv init -)\"\r\n```\r\n\r\n차후에 이 명령어가 필요없도록 `.zshrc` 또는 `.bashrc` 에 해당 명령어를 추가하여 간단하게 터미널을 재시작하면 적용되도록 할 수 있다.\r\n\r\n```shell\r\n$ vi ~/.zshrc\r\n```\r\n\r\n위 명령어로 `.zshrc` 의 하단에 `eval \"$(pyenv init -)\"` 를 추가해주자.\r\n\r\n이제 터미널을 재실행하고 아래 명령어를 통해 원하는 버전이 적용된 것을 확인 할 수 있다.\r\n","excerpt":"(macOS Mojave 환경에서의 포스팅입니다) pyenv는 nvm(Node Version Manager…","fields":{"slug":"/install-python-use-pyenv/"},"frontmatter":{"date":"Feb 20, 2019","title":"pyenv를 이용해 Python 설치하기 (macOS)","tags":["python"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n## Tablo - Bookmark and manage tabs\r\n\r\n다운로드 링크 : [Chrome WebStore - Tablo](https://chrome.google.com/webstore/detail/tablo-bookmark-and-manage/aoccnljcdmmbihgabpoljghfcmbflkhc)\r\n\r\n우선 Tablo 앱을 만들게 된 것은 나만의 링크들을 담아두는 즐겨찾기를 만들고자 시작했고,\r\n\r\n그 방식은 현재 열려있는 탭들을 나만의 리스트에 옮겨 관리할 수 있게 되는 방식을 원했다.\r\n\r\n그래서 만들어진 것이 Tablo이고 아래는 기능에 대한 간략한 설명이다.\r\n\r\n### 열려있는 탭을 기준으로 나만의 북마크 리스트 만들기\r\n\r\n우측에 현재 열려있는 탭의 리스트가 있다,  \r\n\r\n좌측에는 'trello' 혹은 'Github projects'와 비슷한 인터페이스의 칸반 보드가 위치한다.\r\n\r\n우측의 열려있는 탭 리스트에서 링크를 드래그하여 좌측의 원하는 칸안에 드랍하면 된다.\r\n\r\n### 웹 서핑 중 페이지 링크를 담기\r\n\r\nCart 기능이라고 불린다. 웹 서핑중 이 페이지를 Tablo에 저장하고 싶다면,\r\n\r\n우측 상단에 크롬 확장 프로그램 툴바에 위치한 Tablo 아이콘을 클릭하면 '카트에 담기'가 보이게 되고 해당 기능을 이용하면\r\n\r\nTablo에서 우측에 Cart 부분에 담기게 된다. 이제 링크를 Cart에서 드래그하여 원하는 곳에 분류하면 된다.\r\n\r\n## 개발\r\n\r\n전반적인 개발 스택은 아래와 같다\r\n\r\n- React\r\n- Redux\r\n- Webpack\r\n- SASS(SCSS)\r\n- Chrome Extension\r\n\r\n우선 React + Webpack으로 개발을 시작했다. 개발을 시작하자마자 바로 문제점을 만났는데 크롬 확장프로그램을 개발 중 계속해서 빌드하고 새로고침하는 방법을 쓰기는 너무나도 불편했다. 해결점을 찾다가 한 레포지토리([link](https://github.com/samuelsimoes/chrome-extension-webpack-boilerplate))를 발견해서 개발 중에도 계속해서 build 폴더가 변경되면서 핫로더 기능이 작동할 수 있게 되었다. 이 레포지토리를 클론하고 이 프로젝트에 맞게 Webpack을 수정하고 개발하기 시작했다.\r\n\r\n여러 컴포넌트가 있고 각 컴포넌트간에 드래그 앤 드랍이 왔다갔다 하면서 데이터를 관리하기가 어렵다는 것을 느끼게 되어 Redux를 쓰기 시작했다. Redux를 기본만 익혀두고 안쓴지 오래되었기 때문에 다시 익히는데 시간이 조금 오래 걸렸다. 지금 reducer 코드도 정리 안 된 것이 많지만 일단은 나중에 리팩토링하기로 했다.\r\n\r\n기본적으로 Redux를 써서 데이터를 관리하지만 데스크탑, 노트북이든 어디서든 똑같은 데이터가 공유되기를 원했다. 로그인 기능을 활용하기엔 정적 사이트인 크롬 확장프로그램은 어려웠고 그래서 Chrome Extension의 기능을 가져다쓴 Sync Storage를 활용해 어디서든 크롬 브라우저에 로그인만 되어있다면 데이터가 공유 될 수 있도록 했다.\r\n\r\n드래그 앤 드랍 부분이 이 프로젝트에서 상당히 많은 부분을 차지하는데 일단 라이브러리 없이 개발하고 싶었다. 그렇게 개발하였고 지금은 동작 부분에서는 문제가 없지만 코드 측면에서 많아진 드래그 앤 드랍 관련 함수들을 어떻게 정리할지가 고민이다. 또한 브라우저에서 마우스를 따라오는 드래그하는 개채가 기본적으로 opacity가 정해져있어 그것을 어떻게 해결할지도 고민이다. 윈도우 환경에서는 특히나 더 심해 드래그하는 개체가 잘 보이지 않는다.\r\n\r\n주절주절 말이 많았지만 지금까지 개발 후 다음으로 해야할 것들을 정리해보면\r\n\r\n- Redux 스터디 및 Redux 코드 리팩토링\r\n- DnD 관련 함수 정리\r\n- 드래그 개체의 opacity 조절 방법 찾기\r\n- 추가적인 기능 구현\r\n  - 칸반 보드의 색상 커스터마이징이 가능\r\n\r\n개선할 것이 많긴하지만 일단 어느정도 원하는 기능이 다 담길만큼 개발했다.\r\n\r\n백로그없이 기존에 생각하고 있는 것대로 구현하고 개발을 어느정도 마쳤더니 정리가 안된 느낌이 있지만 일단 지금은 이 프로젝트에 계속해서 시간을 투자할 수 없어 여기까지하고 차후에 리팩토링을 통해 해결해야겠다.\r\n","excerpt":"Tablo - Bookmark and manage tabs 다운로드 링크 : Chrome WebStore - Tablo 우선 Tablo…","fields":{"slug":"/tablo-develop/"},"frontmatter":{"date":"Jan 08, 2019","title":"크롬 확장프로그램 \"Tablo\" 소개 및 개발기","tags":["undefined"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n2018년의 Javascript 통계를 나타낸 사이트를 발견하고 간단히 정리해보았다.\r\n\r\n약 2만명이 넘는 Javascript 개발자를 대상으로 설문조사를 한 결과이다.\r\n\r\n자세한 통계는 아래 자료 출처 사이트에서 참고할 수 있다.\r\n\r\n자료 출처 : [2018 State of JS](https://2018.stateofjs.com/)\r\n\r\n## Javascript Flavors\r\n\r\n1. **ES6**\r\n2. **TypeScript**\r\n3. Flow\r\n4. **Reason**\r\n5. Elm\r\n6. ClojureScript\r\n\r\n역시 계속해서 ES6와 TypeScript가 대세,  \r\n두개를 제외하고는 차이가 크게 하위권에 위치한다.\r\n\r\n하위권에서 Reason(페이스북이 개발)은 향후 전망이 좋을 것으로 예측했다.\r\n\r\n## Javascript Frameworks\r\n\r\n1. **React**\r\n2. **Vue.js**\r\n3. **Angular**\r\n4. Preact\r\n5. Ember\r\n6. Polymer\r\n\r\n계속해서 React, Angular, Vue의 삼자구도,  \r\nReact가 크게 상위권을 가져갔다.\r\n\r\n세개의 프레임 워크를 제외하곤 큰 차이로 하위권에 속한다.\r\n\r\n여기서 Angular는 현재 많은 사용을 보이고 있지만 만족도가 낮기에 전망이 좋다고만은 할 수 없다고 나타났다.\r\n\r\n## Data Layer\r\n\r\n1. **Redux**\r\n2. **GraphQL**\r\n3. **Apollo**\r\n4. MobX\r\n5. Relay Modern\r\n\r\n리덕스가 2위와 두배 차이로 크게 1위를 차지하고 있다.\r\n\r\n그 뒤로 GraphQL과 Apollo가 전망을 좋게 예상하고 있고,  \r\n특히나 GraphQL이 사용자 수에서 앞서면서 앞으로의 전망이 기대된다.\r\n\r\n## Backend Frameworks\r\n\r\n1. **Express**\r\n2. **Next.js**\r\n3. koa\r\n4. meteor\r\n5. sails\r\n6. FeathersJS\r\n\r\n압도적인 차이로 Express가 1위, \r\n\r\nNext.JS는 현재 사용자는 적지만 큰 만족도를 나타내며 향후 전망이 좋을 것으로 예측되었다.\r\n\r\n## Mobile & Desktop\r\n\r\n1. **Electron**\r\n2. **React Native**\r\n3. Native Apps\r\n4. Cordova\r\n5. Ionic\r\n6. NativeScript\r\n\r\nElectron과 React Native가 1,2위를 차지했고 앞으로 계속 상승세를 띌 것으로 보인다.\r\n\r\n또한 Cordova와 Ionic이 앞으로 사용하지 않겠다라는 응답이 많아 하향세가 눈에 띈다.\r\n\r\n## Other Tools\r\n\r\n### Other Language\r\n\r\n1. Python\r\n2. PHP\r\n3. Java\r\n4. C#\r\n5. .Net\r\n6. Ruby\r\n7. Go\r\n8. C/C++\r\n9. Swift\r\n10. Rust\r\n11. … 이하 생략\r\n\r\nJavasciprt 개발자가 사용하는 다른 언어의 순위이다.  \r\n순위마다 큰 격차가 벌어지는 경우 없이 순위가 내려갈수록 계단식으로 점차 줄어드는 그래프를 보였다.\r\n\r\n### Build Tools\r\n\r\n1. **Webpack**\r\n2. Gulp\r\n3. Grunt\r\n4. Browserify\r\n5. Rollup\r\n6. **Parcel**\r\n7. … 이하 생략\r\n\r\nWebpack이 압도적인 1위를 차지하고 있다.\r\n\r\n글쓴이가 올해들어 사용해본 Parcel이 눈에 띈다.\r\n\r\nParcel은 이 통계사이트에서 전망을 기대하는 부분에서 3위를 차지했다.  \r\n(1위 Reason, 2위 Svelte)\r\n\r\n## Utility Libraries\r\n\r\n1. lodash\r\n2. moment\r\n3. jQuery\r\n4. … 이하 생략\r\n\r\nlodash와 moment가 근소한 차이를 다투며 1,2위를 차지했고\r\n\r\n2위의 약 70퍼센트 수치로 jQuery가 그 뒤를 차지했다.\r\n\r\n## Text Editors\r\n\r\n1. VS Code\r\n2. Sublime Text\r\n3. Vim\r\n4. WebStorm\r\n5. Atom\r\n6. … 이하 생략\r\n\r\n압도적으로 1위를 VS Code가 차지했다.\r\n\r\n2~5위까지는 근소한 차이를 보이며 그 아래는 매우 큰 차이로 하위권들을 차지한다.\r\n\r\n## 정리하면...\r\n\r\n- ES6와 TypeScript가 대세였으며 앞으로 페이스북이 개발한 Reason이 주목받기 시작할 것이다.\r\n- React, Angular, Vue의 삼자구조는 무너지지 않았고 무너지지 않을 예정,  \r\n  하지만 Angular는 사용자의 만족도가 낮은 것을 보여 하향세를 나타낼 것으로 보임\r\n- 데이터 부분에서는 Redux가 크게 1위를 차지,  \r\n  GraphQL과 Apollo가 좋은 전망, 특히 GraphQL의 전망이 기대됨.\r\n- Backend에서는 Express가 독보적, 앞으로도 그럴 것.  \r\n  Next.JS는 많은 주목을 받으며 앞으로의 전망이 기대됨\r\n- Electron은 데스크탑 개발로서 독보적인 1위를 차지할 것으로 보이며,  \r\n  모바일 부분에서는 역시 React Native가 대세. Cordova, ionic은 하향세를 보이고 있다.\r\n- 빌드 부분에서는 Webpack이 독보적 1위, Parcel은 전망을 지켜볼만 하다.\r\n- 라이브러리 부분에서는 Lodash, Moment가 많이 쓰이고 jQuery가 그 뒤를 잇는다.\r\n- 에디터는 독보적으로 VS Code가 1위를 차지.\r\n\r\n(아래는 개인적으로 정리해본 결과)\r\n\r\n### 2018년 대세, 그리고 향후 좋은 전망을 가진 기술\r\n\r\n- ES6\r\n- TypeScript\r\n- React\r\n- Vue.js\r\n- Express\r\n- Electron\r\n- React Native\r\n- Webpack\r\n\r\n### 앞으로의 전망이 기대되는 기술\r\n\r\n- Reason\r\n- Next.JS\r\n- Parcel\r\n- GraphQL\r\n\r\n---\r\n\r\n### References\r\n\r\n- [2018 State of JS](https://2018.stateofjs.com/)\r\n- [Nomad Coders](https://youtu.be/lvgEdrDZUgY)\r\n","excerpt":"2018년의 Javascript 통계를 나타낸 사이트를 발견하고 간단히 정리해보았다. 약 2만명이 넘는 Javascript 개발자를 대상으로 설문조사를 한 결과이다. 자세한 통계는 아래 자료 출처 사이트에서 참고할 수 있다. 자료 출처 : 201…","fields":{"slug":"/javascript-2018/"},"frontmatter":{"date":"Dec 04, 2018","title":"2018년의 JavaScript 동향, 그리고 전망","tags":["javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n아직은 개발을 공부하는 입장으로 공부하는 프로젝트 위주이기에,  \r\n배포된 개발한 결과물이 많진 않지만 지금까지 개발한 결과물에 대한 이야기를 이야기 해보려 한다.\r\n\r\n연말을 맞아 기록해두면 좋을 것 같아서 작성해본다.\r\n\r\n---\r\n\r\n현재 **구글 애널리틱스**에는 두가지가 등록되어있다.\r\n\r\n1. 블로그\r\n2. Netflix AutoSkip\r\n\r\n현재 계속해서 유지보수하고 있는 것은 이 두가지라 볼 수 있다.\r\n이 블로그와 크롬 확장프로그램인 'NetFlix AutoSkip'이다.\r\n\r\n그리고 **구글 대시보드**에는 크롬 확장프로그램이 세가지 등록되어있다.\r\n\r\n1. Netflix AutoSkip\r\n2. Mojave Chrome Bug Fix\r\n3. Random Wallpaper for New Tab\r\n\r\n현재 2, 3은 미등록 상태로 전환하여 배포를 중단한 상황이다.\r\n\r\n2번은 맥 모하비 베타 시절 크롬 브라우저에서 input 개체들이 제대로 표시되지 않던 것을 고쳐주기 위한 확장프로그램이고 현재는 버그가 해결되어 필요가 없어진 상황.\r\n\r\n3번은 처음 크롬 확장프로그램을 개발해보고자 해본 프로젝트로 크롬 new tab 프로그램이다. react를 사용했고 unsplash의 API를 이용해 랜덤한 배경화면을 슬라이드로 보여주는 프로그램이고 장르별 설정이 가능하도록 개발했다. 하지만 예전에 개발한 만큼 부족한 점이 많아 미등록으로 전환 배포를 하지 않고 있다. 향후 비슷한 프로그램을 새롭게 만들어볼 의향이 있다.\r\n\r\n---\r\n\r\n### 블로그\r\n\r\n이제는 지금도 유지보수를 하고 있는 두가지에 대한 이야기이다.\r\n\r\n블로그는 기본에 Jekyll로 운영하면서 9월 이후에 Gatsby로 개편을 진행했다.\r\n\r\n테마를 사용하지 않고 새로 빈 프로젝트부터 개발해서 시간도 많이 걸렸지만 애착도 많이 생겼다.\r\n\r\n테마 형식으로 배포해보고자 개발했는데 현재는 정식으로 배포하긴 이르다고 생각되어 임시로 사용은 가능하도록 도큐먼트를 작성해뒀다.\r\n\r\n공사중에 방문자가 확 줄었고 현재 한달 방문자는 2천명을 살짝 넘는 수준이고 조금씩 증가 그래프를 보이고 있다.\r\n\r\n아무래도 개인적인 기록용으로 시작했다보니 포스트들이 남들이 보기에는 편리하지 않을 수 있다는 생각이 들어 앞으로는 제대로 작성해야겠다는 생각을 하고 있다.\r\n\r\n### Netflix AutoSkip\r\n\r\n넷플릭스의 인트로와 엔딩을 자동으로 스킵해주는 프로그램이다, 간단히 말하면 DOM에 특정 버튼이 나타나면 클릭 이벤트를 실행해주는 프로그램이다.\r\n\r\n처음에는 내가 필요해서 만든 프로그램이었다.\r\n\r\n그러다가 한번 배포해보자는 생각에 배포를 시작했고 현재는 전세계에서 1300명 정도가 사용하고 있다.\r\n\r\n많은 숫자는 아니지만 사용자에게 피드백을 받는 상황도 생기다보니 재미있었다.\r\n\r\n영어로 쓰여진 메일로 온 피드백은 버그에 관련된 것이었고 대부분의 사용자는 이상 없이 사용하지만 특정 소수 사용자에게 발생하는 것 같았다.\r\n\r\n전세계에서 넷플릭스를 사용하다보니 본인이 사용하는 환경(한국 넷플릭스)에서는 테스트가 어려운 부분이 있었고 크롬 확장 프로그램 특정상 테스트가 그리 쉽진 않아 현재도 해결하지 못하고 있다.\r\n\r\n버그 상황은 아니 그 상황이 나타나면 해결하는 코드를 짜보기도 했지만 소용이 없는 모양이다.\r\n\r\n일단은 기다려볼 생각이다 또 다른 피드백이 와서 정보가 더 생기길 기대할 수 밖에 없는 것 같다.\r\n\r\n간단한 기능일지라도 계속해서 리팩토링을 하며 개선해나갔고 지금은 특별한 이상이나 넷플릭스의 업데이트가 있지 않는 이상은 개선하지 않아도 될 것 같다.\r\n\r\n---\r\n\r\n현재는 공부에 치중하고 있어서 새로운 프로젝트를 실행하고 있지 않지만  \r\n하고싶은건 너무나도 많다. 어쩌다보니 올해는 정적 페이지로 개발한 것들만 있는데 내년엔 풀스텍 개발로 프로젝트를 해보고 싶다.\r\n","excerpt":"…","fields":{"slug":"/dev-reports-2018/"},"frontmatter":{"date":"Dec 03, 2018","title":"현재까지 개발한 결과물에 대한 이야기","tags":["undefined"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n처음 웹개발을 배울 때 웹표준을 배웠던 것 사실만 어렴풋이 기억난다.\r\n\r\n그 이후 개발을 해오면서는 거의 신경쓰지 않고 개발했던 것 같다.\r\n\r\n얼마 전, 이 블로그를 개발하면서 검색 엔진 노출을 위해 웹표준, SEO를 신경써 개발하다보니 다시 한번 살펴봐야겠다는 생각이 들었다.\r\n\r\n그래서 그 중에서 HTML head 부분을 채우는 meta 태그에 대해 가볍게 정리해보았다.\r\n\r\n아래는 포스트에서 살펴 볼 태그들의 목록를 나타낸 예제이다.\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"ko\">\r\n  <head>\r\n      <meta charset=\"UTF-8\">\r\n      <meta name=\"viewport\" content=\"\">\r\n      <meta name=\"keywords\" content=\"\">\r\n      <meta name=\"description\" content=\"\">\r\n      <meta name=\"author\" content=\"\">\r\n      <meta name=\"generator\" content=\"\">\r\n      <meta name=\"robots\" content=\"\">\r\n      <meta http-equiv=\"refresh\" content=\"\">\r\n      <meta property=\"og:type\" content=\"\">\r\n      <meta property=\"og:title\" content=\"\">\r\n      <meta property=\"og:description\" content=\"\">\r\n      <meta property=\"og:image\" content=\"\">\r\n      <meta property=\"og:url\" content=\"\">\r\n  </head>\r\n</html>\r\n\r\n```\r\n\r\n### `<html lang=\"ko\">`\r\n\r\n메타 태그 이전에 html 태그의 lang 속성에 대해 한번 알아보자.\r\n\r\nlang 속성을 지정해야 하는 이유\r\n\r\n- 스크린 리더(화면 낭독 프로그램)이 지정된 언어를 인지하여 읽기 위함\r\n\r\nlang 속성 값 'en-US', 'en-GB'의 차이점\r\n\r\n- 언어 뒤에 국가 코드를 붙인 형식으로, 만약 브라우저가 미국식 영어와 영국식 영어를 다르게 처리할 수 있는 환경이라면 서로 다르게 처리된다. 하지만 처리할 수 없을 경우에는 둘 중 가능한 것으로 처리되게 된다.\r\n\r\nlang 속성 개별 선언\r\n\r\n- 만약 html lang이 en이고 그 중간에 한글로 된 내용이 있다고 한다면 내부에서 `<span lang=\"ko\">한글</span>`의 형식으로 선언하면 해당 내용은 한글로 처리할 수 있게 된다.\r\n\r\n## meta Tag\r\n\r\n- 참고\r\n  - [구글이 반영하는 메타 태그][3]\r\n\r\n### meta charset :star:\r\n\r\n```html\r\n<meta charset=\"UTF-8\">\r\n```\r\n\r\nHTML5의 인코딩 지정 방법이다.\r\n\r\n보통 UTF-8(유니코드 형식의 하나로, 전세계 거의 모든 문자를 표현 할 수 있다.)를 값으로 준다.\r\n\r\nHTML이 아닌 곳에서의 인코딩 지정을 살펴보자.\r\n\r\n- Javascript : `<script src=\"a.js\" charset=\"UTF-8>\"` 해당 코드와 같이 외부에서 불러오는 파일일 경우 charset의 차이로 내용이 깨져보일 수 있다.\r\n- CSS : `@charset \"UTF-8\"` 표준에 따르면 CSS 문서 최상단에 해당 코드를 기술하도록 되어있다.\r\n\r\nHTML 문서가 아닌 곳에서 인코딩을 지정할 필요는 보통 없다. 인코딩 에러가 발생할 경우 이 내용을 참고하도록 하자.\r\n\r\n### meta viewport :star:\r\n\r\n반응형 웹 구현을 위해 필요한 메타 태그이다.\r\n\r\n```html\r\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n```\r\n\r\n뷰포트라 함은 화면에 보이는 영역을 뜻한다. 즉 스크롤해서 봐야하는 영역을 제외한 보이는 그대로의 크기만큼의 영역이다.\r\n\r\n위 예제 코드는 가장 흔히 쓰이는 코드로 너비는 보고있는 기기의 넓이이며 그에 맞춰 초기 화면 배율을 1로 지정\b한다는 의미이다.\r\n\r\n### meta keywords :star:\r\n\r\n```html\r\n<meta name=\"keywords\" content=\"a b\">\r\n```\r\n\r\n해당 컨텐츠 내용의 대표적인 키워드를 지정한다.\r\n\r\n검색 엔진의 검색 결과에 반영 될 수 있다.  \r\n구글에서는 검색 순위에 많은 메타 태그를 반영하지 않고 있지만 (keywords도 해당) 그래도 다른 검색 엔진에서도 반영하며 SEO에서는 중요한 메타 태그라고 할 수 있다.\r\n\r\n\r\n### meta description :star:\r\n\r\n```html\r\n<meta name=\"description\" content=\"개발 사이트 - About\">\r\n```\r\n\r\n해당 페이지의 설명을 적어 넣는다, 검색 시 페이지의 제목 아래 페이지 내용의 요약이 적혀있는 것을 볼 수 있는데 그 부분에 반영되는 항목이다.\r\n\r\n### meta author :star:\r\n\r\n```html\r\n<meta name=\"author\" content=\"junho\">\r\n```\r\n\r\n웹 페이지의 소유자(또는 회사)를 적는다.\r\n\r\n### meta generator :x:\r\n\r\n```html\r\n<meta name=\"generator\" content=\"\">\r\n```\r\n\r\n이 웹페이지를 무엇으로 만들었는지 기술하는 태그이다.\r\n\r\n다른 사람이 코드를 알아볼 때 참고할 수 있도록 하는 면이 있는데 요즘은 번들러를 통해 코드가 변환되는 경우가 있기 때문에 기술할 필요성이 떨어지며, 또 다른 경우는 코드를 자동 생성하면서 해당 메타 태그가 기술되어지는 경우가 있는데 이 경우 또한 흔한 경우가 아니며 웹표준이나 SEO 측면 모두 불필요한 메타 태그라고 볼 수 있다.\r\n\r\n### meta robots\r\n\r\n```html\r\n<meta name=\"robots\" content=\"noindex\">\r\n```\r\n\r\nrobots는 기본적으로 검색 엔진 크롤러의 허용, 불허 등을 제어한다.\r\n\r\n**robots 메타태그 보다는 robots.txt 파일로 제어하는게 일반적**이다.\r\n\r\nrobots.txt의 역할과 차이점이 무엇인지 혼용해서 쓸 수 있을지는 아래 링크를 참고하자.\r\n\r\n- [robots.txt 파일과 meta robots 태그의 차이점][4]\r\n\r\n### `<meta http-equiv=\"refresh\">` :x:\r\n\r\n```html\r\n<meta http-equiv=\"refresh\" content=\"0; url=https://example.com/\">\r\n```\r\n\r\n해당 메타 태그를 사용하면 지정한 시간 이후 이정한 URL으로 자동으로 페이지를 이동시킬 수 있다.\r\n\r\ncontent에 초 단위로 시간을 지정하고 0일 경우에는 즉시 이동한다.\r\n\r\n**해당 동작은 권장되지 않는다**. 자동으로 URL 리다이렉션은 최근 웹에서는 지양하고 있으며 피싱 등의 위험으로 간주 될 수 있다.  \r\n또한 5초로 리다이렉트를 지정해놓았는데 그 전에 사용자가 뒤로가기를 하는 경우에 뒤로가기를 했는데도 5초 후 지정한 URL로 이동될 수 있으니 사용하지 않는 것이 좋다.\r\n\r\n### OpenGraph\r\n\r\n오픈그래프는 웹페이지가 소셜 미디어 또는 오픈그래프를 활용한 사이트로 공유될때 사용되어지는 정보이다.\r\n\r\n제일 흔한 예로 페이스북에 링크를 붙여놓기, 카카오톡 링크 공유할 때 해당 게시물의 제목, 설명, 이미지가 간략하게 나타나는 경우가 오픈그래프가 활용된 경우이다.\r\n\r\n```html\r\n<head>\r\n    <meta property=\"og:type\" content=\"website\">\r\n    <meta property=\"og:title\" content=\"페이지 제목\">\r\n    <meta property=\"og:description\" content=\"페이지 설명\">\r\n    <meta property=\"og:image\" content=\"http://www.mysite.com/myimage.jpg\">\r\n    <meta property=\"og:url\" content=\"http://www.mysite.com\">\r\n</head>\r\n```\r\n\r\n- [오픈 그래프][5]\r\n- [네이버 웹 표준 HTML 마크업 가이드 | 오픈 그래프][6]\r\n\r\n<br/>\r\n<br/>\r\n<br/>\r\n\r\n---\r\n\r\n<br/>\r\n\r\n- References\r\n\r\n  - https://ko.wikipedia.org/wiki/%EC%9B%B9_%ED%91%9C%EC%A4%80 \"웹표준 Wiki\"\r\n  - http://www.wah.or.kr/Accessibility/define.asp \"웹 접근성 연구소\"\r\n  - https://support.google.com/webmasters/answer/79812?hl=ko \"Google에서 이해할 수 있는 메타태그\"\r\n  - http://www.seo-korea.com/robots-txt-%ED%8C%8C%EC%9D%BC%EA%B3%BC-meta-robots-%ED%83%9C%EA%B7%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/ \"robots.txt 파일과 meta robots 태그의 차이점\"\r\n  - http://ogp.me/ \"오픈 그래프\"\r\n  - https://webmastertool.naver.com/guide/basic_markup.naver#chapter2.3 \"네이버 웹표준 가이드\"\r\n  - https://ko.wikipedia.org/wiki/%EA%B2%80%EC%83%89_%EC%97%94%EC%A7%84_%EC%B5%9C%EC%A0%81%ED%99%94 \"SEO wiki\"\r\n  - http://mygumi.tistory.com/52\r\n  - http://www.seo-korea.com/robots-txt-%ED%8C%8C%EC%9D%BC%EA%B3%BC-meta-robots-%ED%83%9C%EA%B7%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/\r\n\r\n\r\n\r\n\r\n\r\n[1]: https://ko.wikipedia.org/wiki/%EC%9B%B9_%ED%91%9C%EC%A4%80 \"웹표준 Wiki\"\r\n[2]: http://www.wah.or.kr/Accessibility/define.asp \"웹 접근성 연구소\"\r\n[3]: https://support.google.com/webmasters/answer/79812?hl=ko \"Google에서 이해할 수 있는 메타태그\"\r\n[4]: http://www.seo-korea.com/robots-txt-%ED%8C%8C%EC%9D%BC%EA%B3%BC-meta-robots-%ED%83%9C%EA%B7%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/ \"robots.txt 파일과 meta robots 태그의 차이점\"\r\n[5]: http://ogp.me/ \"오픈 그래프\"\r\n[6]: https://webmastertool.naver.com/guide/basic_markup.naver#chapter2.3 \"네이버 웹표준 가이드\"\r\n[7]: https://ko.wikipedia.org/wiki/%EA%B2%80%EC%83%89_%EC%97%94%EC%A7%84_%EC%B5%9C%EC%A0%81%ED%99%94 \"SEO wiki\"\r\n","excerpt":"처음 웹개발을 배울 때 웹표준을 배웠던 것 사실만 어렴풋이 기억난다. 그 이후 개발을 해오면서는 거의 신경쓰지 않고 개발했던 것 같다. 얼마 전, 이 블로그를 개발하면서 검색 엔진 노출을 위해 웹표준, SEO…","fields":{"slug":"/meta-tag/"},"frontmatter":{"date":"Nov 15, 2018","title":"meta 태그를 알아보자 (웹표준과 SEO)","tags":["SEO","html"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n## 서론...\r\n\r\n일단 Gatsby는 Jekyll과 같은 **정적 페이지 생성 프레임워크**이다.\r\n\r\n(본인이 생각하는) 장점은 React + Webpack 으로 되어있다는 점.\r\n\r\nJekyll은 익숙치 않아 테마를 사용하고 개인화하는데 불편함이 있었는데 익숙한 React로 되어있어 제작하는데 어렵지 않게 할 수 있었다.  \r\n\r\n또한 Gatsby가 제공하는 유용한 plugin(Webpack)들이 많아 쉽게 만들 수 있는 점도 있다.\r\n\r\nJekyll과 비교해 단점이라면 번들링 과정을 한번 거쳐서 배포가 된다는 점 (어떤 면에선 장점)  \r\n그리고 Jekyll에 비해서는 사용자가 부족해 정보나 테마 등이 부족하다는 점이 있다.\r\n\r\n저번 Jekyll 블로그를 운영할 때는 테마를 받아 조금의 수정을 거쳐 사용했었는데 지금은 완전 처음부터 제작을 하였다.  \r\n지금 보고 있는 이 블로그이다. 아직 추가할 기능이 많지만 필요한 기능은 구현을 마쳤고 추가는 천천히 할 생각이다.\r\n\r\n아래는 Github Page에 Gatsby 블로그를 시작하는 두가지 방법을 기술한다.  \r\n원하는 방법으로 시작하면 된다.\r\n\r\n1. Gatsby Starter로 Jekyll의 테마를 이용하듯 다른사람이 제작한 블로그 형식으로 시작하는 방법\r\n2. 지금 보고있는 블로그를 자신의 것으로 개인화하여 사용하기\r\n\r\n## 1. Gatsby Starter를 이용해 시작하기\r\n\r\n우선 `gatsby-cli`를 글로벌 설치해준다.\r\n\r\n```shell\r\n$ npm install --global gatsby-cli\r\n```\r\n\r\n이제 `create-react-app`을 사용하듯 비슷한 사용법으로 사용이 가능하다.\r\n\r\n`$ gatsby new [SITE_DIRECTORY]` 의 명령으로 빈 프로젝트로 시작할 수 있다.\r\n\r\n하지만 여기서는 스타터를 이용하여 시작하는 방법을 소개하니 위 명령어가 아닌 아래 명령어를 이용하자\r\n\r\n```\r\n$ gatsby new [SITE_DIRECTORY] [URL_OF_STARTER_GITHUB_REPO]\r\n```\r\n\r\n위 명령에서 `[SITE_DIRECTORY]`에는 자신의 프로젝트 이름(폴더명)을 입력하고 `[URL_OF_STARTER_GITHUB_REPO]`에는 사용할 스타터의 Github 리포지토리 주소를 적으면 된다.\r\n\r\n어떤 스타터를 할 것인지는 아래에서 찾아서 확인해보자\r\n\r\n1. [Gatsby Starters (Official)][2]\r\n2. [Gatsby Starters][1]\r\n\r\n1번의 오피셜 스타터보다는 2번의 다른 사람이 제작한 것을 사용하는 것을 추천한다.\r\n\r\n로컬 개발 서버는 `$ gatsby develop` 를 통해 열 수 있다.\r\n\r\nGithub Page를 이용해 배포하는데는 여러가지 방법이 있고 스타터마다 권장하는 방식이 다를 수 있으니 해당 스타터 깃헙 페이지의 사용법을 확인하자.\r\n\r\n## 2. 현재 보고있는 블로그로 시작하기\r\n\r\n**블로그가 새로 업데이트 되었습니다. 아래 글은 이전 블로그 기준으로 작성된 글입니다**\r\n\r\n~~지금~~ 보고있는 이 블로그는 다른 사용자들이 사용할 수 있도록 개인화가 가능하도록 테마 형식으로 제작되어 쉽게 커스터마이징하여 사용할 수 있다.\r\n\r\n간단히 블로그에 대해 설명하면,\r\n\r\n지금은 홈, 태그, 검색의 세가지 메뉴로 구성되어있으며 포스트를 태그로 관리하는 형식이다. 차후 카테고리 방식도 업데이트 예정이다.\r\n\r\n아래와 같은 기술 스택으로 제작되었으며 웹표준, 검색 최적화(SEO)를 준수하고 있고 Google Analytics를 사용할 수 있다.\r\n\r\n- Gatsby\r\n- React\r\n- Webpack\r\n- SASS (SCSS)\r\n- typography.js, Google Fonts\r\n- Google Analytics\r\n\r\n또한 Github Page 배포를 위해서 `gh-pages` 모듈을 이용 master 브랜치에 배포되도록 설정하였다.  \r\n작업은 기본적으로 'develop' 브랜치에서 이루어지고 master 브랜치는 배포되는 파일만 위치하게 된다.  \r\n그래서 해당 프로젝트를 clone 할 때도 develop 브랜치를 클론하게 된다.\r\n\r\n---\r\n\r\n우선 아래 명령어로 clone을 하자.  \r\n[SITE_DIRECTORY]에는 자신의 프로젝트 이름을 적는다.\r\n\r\n```shell\r\n$ git clone -b develop https://github.com/junhobaik/junhobaik.github.io.git [SITE_DIRECTORY]\r\n$ npm install\r\n```\r\n\r\n여기까지 했다면 개인화 과정을 하기 전에 한번 `$ npm start`를 통해 제대로 실행되는지 'localhost:8000'에 들어가 확인해본다.\r\n\r\n다음으로 아래 두가지를 알아두고 시작하면 된다.\r\n\r\n1. 개인화 방법\r\n2. 포스트(마크다운) 작성법\r\n3. 배포 방법\r\n\r\n위 두가지와 자세한 가이드는 Documents에서 확인해 볼 수 있다.\r\n\r\n먼저 Get Started를 확인하고 documents를 참고하는 것을 추천한다.\r\n\r\n- [Get Started 바로가기][4]\r\n- [Documents 바로가기][3]\r\n\r\n\r\n[1]: https://www.gatsbyjs.org/starters/?v=2 \"gatsby starter\" \r\n[2]: https://www.gatsbyjs.org/docs/starters/#starters \"gatsby starter official\"\r\n[3]: https://github.com/junhobaik/junhobaik.github.io/wiki/Documents \"documents\"\r\n[4]: https://github.com/junhobaik/junhobaik.github.io#get-started \"get started\"\r\n","excerpt":"서론... 일단 Gatsby는 Jekyll과 같은 정적 페이지 생성 프레임워크이다. (본인이 생각하는) 장점은 React + Webpack 으로 되어있다는 점. Jekyll은 익숙치 않아 테마를 사용하고 개인화하는데 불편함이 있었는데 익숙한 React…","fields":{"slug":"/create-gatsby-blog/"},"frontmatter":{"date":"Nov 14, 2018","title":"Gatsby로 블로그 만들기","tags":["gatsby","blog"],"update":null}}},{"node":{"rawMarkdownBody":"\r\ngit에서 특정한 파일만 merge 하고 싶을 때가 있다.\r\n\r\nB 브랜치를 A 브랜치에 merge 하려하는데 특정 파일(./a.js)만 병합하고 싶을 상황일 때 쓸 수 있는 방법이다.\r\n\r\n정확히는 merge 키워드를 사용하지 않지만 아래 방법으로 위의 케이스를 해결할 수 있다.\r\n\r\nA 브랜치로 체크아웃한 상태에서 아래 명령을 입력한다.\r\n\r\n```shell\r\n$ git checkout -p B a.js\r\n```\r\n\r\n위 명령으로 작업을 완료 할 수 있고 아래는 이에 대한 설명이다.\r\n\r\n---\r\n\r\n`checkout -p` 여기서 p 플래그는 `-p|--patch`으로 patch 옵션을 나타낸다.\r\n\r\n```shell\r\n$ git checkout -p B a.js\r\n```\r\n명령을 통해서 패치하겠다는 명령을 주면,  \r\n변경 내용 출력과 함께 하단에 지금 작업에 반영하겠냐는 질문이 뜨는데 y를 입력해주면 된다.  \r\n여러번 질문이 나올 수 있는데 a를 입력하면 모든 질문에 y를 입력하는 행동을 할 수 있다.\r\n\r\n아래는 그 예시이다.\r\n\r\n```shell\r\n$ git checkout -p B a.js\r\n\r\ndiff --git b/a.js a/a.js\r\nindex 5f133a1..31d30c1 100644\r\n--- b/a.js\r\n+++ a/a.js\r\n@@ -2,6 +2,7 @@ const _ = require('lodash');\r\n const Promise = require('bluebird');\r\n const path = require('path');\r\n+const config = require('./config');\r\n\r\n exports.createPages = ({ graphql, actions }) => {\r\n   const { createPage } = actions;\r\nApply this hunk to index and worktree [y,n,q,a,d,j,J,g,/,e,?]? y\r\n```\r\n\r\n참고로 여기서 `[y,n,q,a,d,j,J,g,/,e,?]`의 의미는 아래와 같다.\r\n\r\n```\r\ny - stage this hunk\r\nn - do not stage this hunk\r\nq - quit; do not stage this hunk nor any of the remaining ones\r\na - stage this hunk and all later hunks in the file\r\nd - do not stage this hunk nor any of the later hunks in the file\r\ng - select a hunk to go to\r\n/ - search for a hunk matching the given regex\r\nj - leave this hunk undecided, see next undecided hunk\r\nJ - leave this hunk undecided, see next hunk\r\nk - leave this hunk undecided, see previous undecided hunk\r\nK - leave this hunk undecided, see previous hunk\r\ns - split the current hunk into smaller hunks\r\ne - manually edit the current hunk\r\n? - print help\r\n```\r\n","excerpt":"git에서 특정한 파일만 merge 하고 싶을 때가 있다. B 브랜치를 A 브랜치에 merge 하려하는데 특정 파일(./a.js)만 병합하고 싶을 상황일 때 쓸 수 있는 방법이다. 정확히는 merge…","fields":{"slug":"/git-specific-files-merge/"},"frontmatter":{"date":"Nov 06, 2018","title":"git 특정한 파일 병합(merge) 하기","tags":["git"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n\r\n\r\n어떠한 이유로 컴포넌트의 업데이트를 하고 싶지 않을 때 사용 할 수 있다.\r\n\r\n이전에는 `setState(null)`을 하더라도 컴포넌트가 업데이트 되었으나 React 16 부터는 업데이트가 되지 않는다.\r\n\r\n\r\n\r\n간단한 코드를 살펴보자\r\n\r\n\r\n\r\n```javascript\r\nconst MAX_CNT = 5;\r\n\r\nconst cntInrease = (state, props) => {\r\n  const { cnt } = state;\r\n  if (cnt < MAX_CNT) {\r\n    return {\r\n      cnt: cnt + 1\r\n    };\r\n  } else {\r\n    return null;\r\n  }\r\n};\r\n```\r\n\r\n위의 코드는 state를 변경해가며 카운트가 하나씩 증가하는 코드이고, `MAX_CNT`에 해당하는 값까지만 증가하도록 해놓았다.  \r\n`MAX_CNT` 이상은 `null`을 리턴한다.\r\n\r\n```javascript\r\nclass App extends Component {\r\n  state = {\r\n    cnt: 0\r\n  };\r\n\r\n  componentDidUpdate(){\r\n    console.log('componentDidUpdate');\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"App\">\r\n        <button onClick={() => this.setState(cntInrease)}>{this.state.cnt}</button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n```\r\n\r\n위의 코드를 살펴보면,  \r\n`componentDidUpdate` 라이프사이클 메소드를 이용하여 업데이트가 되는지를 확인하도록 콘솔로그를 작성했고,  \r\n버튼의 onClick 이벤트에 `setState`의 인자로 위에서 작성한 `cntIncreate` 함수를 넣었다.\r\n\r\n이제 작동을 확인해보면 `MAX_CNT` 값까지는 state가 변경되며 컴포넌트 또한 업데이트 되는 로그를 확인 할 수 있다.  \r\n`MAX_CNT`에 도달하면 이제 null이 리턴되면서 더 이상 업데이트가 되지 않는다.\r\n\r\n여기서 중요한 점은 setState(null)로 인해서 업데이트가 되지 않는 다는 점,  \r\n컴포넌트의 업데이트를 제어할 방법이 하나 추가되었다는 점이다.\r\n\r\n---\r\n\r\n## Reference\r\n\r\n- [React Blog](https://reactjs.org/blog/2017/09/26/react-v16.0.html#breaking-changes)\r\n- [Nomad Coders](academy.nomadcoders.co) - React 16 마스터하기\r\n","excerpt":"어떠한 이유로 컴포넌트의 업데이트를 하고 싶지 않을 때 사용 할 수 있다. 이전에는 을 하더라도 컴포넌트가 업데이트 되었으나 React 16 부터는 업데이트가 되지 않는다. 간단한 코드를 살펴보자 위의 코드는 state…","fields":{"slug":"/react-16-setstate-null/"},"frontmatter":{"date":"Nov 01, 2018","title":"React 16, Returning null from setState","tags":["react"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n\r\n\r\n리액트 16 에서는 LifeCycle에 많은 변화가 있었고 17에서는 더 많은 변화가 있을 것이라고 예고했다.\r\n\r\n이번에 새로 등장한 `componentDidCatch(error, info)` 라이프사이클 메소드를 이용해 에러를 관리하는 방법을 살펴보자.\r\n\r\n\r\n\r\n## 기본적인 사용법\r\n\r\n```javascript\r\nclass BoundaryError extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      hasError: false\r\n    };\r\n  }\r\n\r\n  componentDidCatch(error, info) {\r\n    this.setState({ hasError: true });\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) return <h1>ERROR!</h1>;\r\n    else return this.props.children;\r\n  }\r\n}\r\n```\r\n\r\n```javascript\r\n<BoundaryError>\r\n    <Component1 />\r\n</BoundaryError>\r\n```\r\n\r\n위의 코드를 살펴보면 `componentDidCatch`에서 에러를 잡아 `setState`로 `hasError`값을 바꿔 에러 상태값을 관리하고  \r\n그 상태값에 따라 리턴을 달리해 에러시에는 에러 문구로 에러가 난 컴포넌트를 대신하게 된다.\r\n\r\n이렇게 하면 에러가 발생함에 따라 리액트 페이지 전체가 먹통이 되는 현상을 방지 할 수 있다.\r\n\r\n\r\n\r\n## HOC와 함께 사용하기\r\n\r\nHOC는 Higher-Order Components로 간단히 설명하면 컴포넌트를 감싸는 컴포넌트라고 할 수 있다.\r\n\r\nHOC에 대한 자세한 설명은 생략하고 Error Handling을 하는데 어떻게 사용하는지를 살펴보겠다.\r\n\r\n```javascript\r\nconst withErrorBoundary = WrappedComponent =>\r\n  class extends Component {\r\n    state = {\r\n      hasError: false\r\n    };\r\n    componentDidCatch(error) {\r\n      this.setState({ hasError: true });\r\n    }\r\n    render() {\r\n      if (this.state.hasError) return \"Sorry...\";\r\n      else return <WrappedComponent />;\r\n    }\r\n  };\r\n```\r\n\r\n위와 같이 클래스를 만드는 함수로 `withErrorBoundary`를 작성했다.\r\n\r\n```javascript\r\nconst Component1WithErrorBoundary = withErrorBoundary(Component1);\r\nconst Component2WithErrorBoundary = withErrorBoundary(Component2);\r\nconst Component3WithErrorBoundary = withErrorBoundary(Component3);\r\n```\r\n\r\n```javascript\r\nrender(){\r\n    return (\r\n    \t<>\r\n        \t<Component1WithErrorBoundary />\r\n    \t    <Component2WithErrorBoundary />\r\n\t        <Component3WithErrorBoundary />\r\n        </>\r\n    )\r\n}\r\n```\r\n\r\n이제 위와 같이 사용할 수 있는데 이렇게 되면 에러가 난 컴포넌트만 해당 컴포넌트가 아닌 'Sorry…' 문구가 출력되게 될 것이며, 에러로 인해 리액트 페이지 전체가 먹통이 되는 현상을 방지 할 수 있다.\r\n\r\n---\r\n\r\n## Reference\r\n\r\n- [React Documents](https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html)\r\n- [Nomad Coders](academy.nomadcoders.co) - React 16 마스터하기\r\n","excerpt":"리액트 16 에서는 LifeCycle에 많은 변화가 있었고 1…","fields":{"slug":"/react-16-error-handling/"},"frontmatter":{"date":"Oct 31, 2018","title":"react 16, Error handling with HOC","tags":["react"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nPortals은 루트 리액트 컴포넌트가 아닌 외부의 DOM에 접근하여 변경할 수 있게 해준다.\r\n\r\n쉽게 말하면 react는 기본적으로 아래와 같이 `index.html`에 하나의 엘리먼트를 대상으로 마운트되어 그 곳에서만 변경이 가능하다. 그 외부의 엘리먼트를 대상으로 변경할 수 있게 해주는 것이 Portals이다.\r\n\r\n## Portals 기본 사용법\r\n\r\n```html\r\n<!-- index.html -->\r\n\r\n<div id=\"root\"/>\r\n```\r\n\r\n```javascript\r\n// index.js\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"))\r\n```\r\n\r\n여기서 portals를 이용하면 `index.html`의 `div#root`이외에 접근하여 변경 할 수 있다.\r\n\r\n```html\r\n<!-- index.html -->\r\n<h1 id=\"title\"></h1>\r\n<div id=\"root\"/>\r\n```\r\n\r\nReact Scope안에 위치하지 않는 `h1#title` 엘리먼트를 만들어두고\r\n\r\n아래와 같이 리액트 코드를 작성한다.\r\n\r\n```javascript\r\n// App.js\r\n\r\nimport { createPortal } from 'react-dom'\r\n\r\nclass Portals extends Component {\r\n    render(){\r\n        return createPortal(\r\n            'Hello World!',\r\n            document.querySelector('h1.title')\r\n        );\r\n    }\r\n}\r\n\r\nclass App extends Component {\r\n    render(){\r\n        return (\r\n\t\t\t<>\r\n\t\t\t\t<Portals />\r\n            </>\r\n        )\r\n    }\r\n}\r\n```\r\n\r\n위를 보면 `react-dom`의 `createPortal` 메소드를 사용했다.\r\n\r\n```javascript react\r\nReactDOM.createPortal(child, container)\r\n```\r\n\r\n첫번째 인자는 렌더링 가능한 리액트 하위 요소가 되고,  \r\n두번째 인자는 타겟이 될 DOM 엘리먼트이다.\r\n\r\n그리고 해당 portals 컴포넌트를 App 컴포넌트 리턴에 포함시켜 주었다.\r\n\r\nProtals는 Modal 구현같은 곳에 유용하게 쓰일 수 있을 것 같다.\r\n\r\n---\r\n\r\n## Reference\r\n\r\n- [React Documents](https://reactjs.org/docs/portals.html)\r\n- [Nomad Coders](academy.nomadcoders.co) - React 16 마스터하기\r\n","excerpt":"Portals은 루트 리액트 컴포넌트가 아닌 외부의 DOM에 접근하여 변경할 수 있게 해준다. 쉽게 말하면 react…","fields":{"slug":"/react-16-portals/"},"frontmatter":{"date":"Oct 31, 2018","title":"react 16, Portals","tags":["react"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n\r\n\r\nReact 16 이전에서는 return 시 하나의 컴포넌트 또는 null만 가능했다.  \r\n그래서 wrapper를 쓰는 방식으로 div로 감싸던가 아니면 span을 이용하던지, 그것도 아니면 array를 쓰는 등 여러 불편한 방법을 사용했었다.\r\n\r\n하지만 16 부터는 fragment를 활용하여 여러 엘리먼트를 return 할 수 있다.\r\n\r\n```javascript\r\nclass ReturnStringType extends Component {\r\n    render(){\r\n        return 'Hello World'\r\n    }\r\n}\r\n\r\nclass Index extends Component {\r\n    render(){\r\n        return (\r\n\t\t\t<React.Fragment>\r\n            \t<Comp1 />\r\n\t\t\t\t<ReturnStringType />\r\n            </React.Fragment>\r\n        )\r\n    }\r\n}\r\n```\r\n\r\n위처럼 Fragment로 컴포넌트 엘리먼트와 String 타입 엘리먼트를 감싸보았다.\r\n\r\n이것을 브라우저 상에서 확인하면 Fragment는 확인이 되지 않고 두개의 엘리먼트만이 보이게 된다.\r\n\r\nShort Syntax로 `<> </>`와 같이 사용할 수도 있지만,  \r\nkey, attribute를 사용할 수 없고 호환성 이슈로 리액트 문서에서는 아직 권장하지는 않는다.\r\n\r\n---\r\n\r\n## Reference\r\n\r\n- [React Documents](https://reactjs.org/docs/fragments.html)\r\n- [Nomad Coders](academy.nomadcoders.co) - React 16 마스터하기\r\n","excerpt":"React 16 이전에서는 return 시 하나의 컴포넌트 또는 null만 가능했다. 그래서 wrapper를 쓰는 방식으로 div로 감싸던가 아니면 span을 이용하던지, 그것도 아니면 array를 쓰는 등 여러 불편한 방법을 사용했었다. 하지만 1…","fields":{"slug":"/react-16-fragments/"},"frontmatter":{"date":"Oct 31, 2018","title":"React 16, Fragments","tags":["react"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n## 설치\r\n\r\n우선 Homebrew 를 통해 gpg 패키지를 설치한다,\r\n\r\n```shell\r\n$ brew install gpg\r\n```\r\n\r\n추가로 gpg 키 관리 프로그램인 GPG-SUITE를 설치한다.\r\n\r\n```shell\r\n$ brew cask install gpg-suite\r\n```\r\n\r\n## key 생성\r\n\r\n키 생성 방법은 두가지가 있다.\r\n\r\n1. gpg-suite를 통한 설치\r\n2. 터미널내에서 설치\r\n\r\n1번의 경우 시스템 환경설정에서 확인 할 수 있는 GPG KeyChain을 통해 생성하는 방법이다.  \r\n본 글에서는 터미널에서 생성하는 방법을 소개하고 있기 때문에 1번의 방법은 [링크](https://medium.com/@star_zero/github%E3%81%AEgpg-key%E3%82%92%E8%A8%AD%E5%AE%9A%E3%81%99%E3%82%8B-70e22874e533)를 확인해 보시기를 바란다.\r\n\r\n아래는 터미널에서 키를 생성하는 과정이다.\r\n\r\n우선 아래 명령어를 이용 키 생성 과정에 들어간다.\r\n\r\n```shell\r\n$ gpg --full-generate-key\r\n```\r\n\r\n아래 자세한 생성하는 과정이 나와있고, 간단히 요약하면 이러하다.\r\n\r\n- 암호화 방식 선택 (권장: 1)\r\n- 암호화 키 크기 선택 (권장: 4096)\r\n- 키 유효기간 설정 (권장: 0) // Enter 입력하여 패스\r\n- 이름, 이메일, 코멘트(공란 가능) 입력\r\n- 이후 보안 암호 문구 작성 창에서 암호 입력 (이후 첫 commit시 입력하는 암호로 쓰인다)\r\n\r\n```shell\r\nPlease select what kind of key you want:\r\n   (1) RSA and RSA (default)\r\n   (2) DSA and Elgamal\r\n   (3) DSA (sign only)\r\n   (4) RSA (sign only)\r\nYour selection? 1\r\n\r\n\r\nRSA keys may be between 1024 and 4096 bits long.\r\nWhat keysize do you want? (2048) 4096\r\n\r\n\r\nPlease specify how long the key should be valid.\r\n         0 = key does not expire\r\n      <n>  = key expires in n days\r\n      <n>w = key expires in n weeks\r\n      <n>m = key expires in n months\r\n      <n>y = key expires in n years\r\nKey is valid for? (0)\r\n\r\n\r\nGnuPG needs to construct a user ID to identify your key.\r\n\r\nReal name: Junho Baik\r\nEmail address: junhobaik@gmail.com\r\nComment:\r\nYou selected this USER-ID:\r\n    \"Junho Baik <junhobaik@gmail.com>\"\r\n\r\nChange (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O\r\n```\r\n\r\n위의 과정을 마치고 나면 키가 생성되었고,\r\n\r\n이제 아래 명령어(`gpg --list-secret-keys --keyid-format LONG`)를 이용하여 생성한 키를 확인한다.\r\n\r\n```shell\r\n$ gpg --list-secret-keys --keyid-format LONG\r\n\r\n-----------------------------------\r\nsec   rsa4096/ABCDE12345678900 2018-10-24 [SC]\r\n      AFWAEGWEGWAEDVADKAWGJIWRGLWJRGAIWALGRHRG\r\nuid                 [ultimate] Junho Baik <junhobaik@gmail.com>\r\nssb   rsa4096/AGRJIWGJWRGJIRWG 2018-10-24 [E]\r\n```\r\n\r\n위의 예제에서 `ABCDE12345678900`에 해당하는 부분을 복사하고 아래 명령어에 넣는다.\r\n\r\n```shell\r\n$ gpg --armor --export ABCDE12345678900\r\n```\r\n\r\n위 명령어를 입력한 후 출력되는 키를 복사한다,  \r\n`-----BEGIN PGP PUBLIC KEY BLOCK-----`부터 `-----END PGP PUBLIC KEY BLOCK——.`를 포함해서 모두 복사하여야 한다.\r\n\r\n## GitHub 에 GPG Key 등록\r\n\r\nGitHub - Settings - [SSH and GPG keys](https://github.com/settings/keys)\r\n\r\n위의 메뉴로 진입하여 GPG Keys 부분의 new GPG key 버튼을 클릭하고 복사한 키를 등록한다.\r\n\r\n## Git 에 GPG Key 등록\r\n\r\n아래 명령어를 통해 `~/.gitconfig`에 gpg 정보를 입력한다.\r\n\r\n여기서 `ABCDE12345678900`에 해당하는 것은 위에서 확인한 Key 부분이며, 본인의 것을 입력한다.\r\n\r\n```shell\r\n$ git config --global user.signingkey ABCDE12345678900\r\n$ git config --global gpg.program $(which gpg)\r\n```\r\n\r\n이제 등록이 되었고, 이후 commit 부터는 `-S` 플래그를 넣음으로 서명을 적용한 Commit 을 보낼 수 있다.\r\n\r\n```shell\r\n$ git commit -S\r\n```\r\n\r\n아래 명령어를 이용하면 `-S` 플래그를 번번히 넣지 않아도 항상 서명이 적용한 Commit 을 보내게 된다.\r\n\r\n```shell\r\n$ git config --global commit.gpgsign true\r\n```\r\n\r\n추가로 commit 시 오류가 발생한다면, 아래 내용을 `~/.zshrc` 또는 `~/.bashrc`에 추가해준다.\r\n\r\n```\r\nexport GPG_TTY=$(tty)\r\n```\r\n\r\n추가로 가끔씩 물어보는 GPG 패스워드를 묻지 않길 원하면 `~/.gnupg/gpg-agent.conf` 파일을 수정한다.\r\n\r\n```\r\ndefault-cache-ttl 31536000\r\nmaximum-cache-ttl 31536000\r\n```\r\n\r\nGPG2.1 이후에서는 `maximum-cache-ttl`이 `max-cache-ttl`로 바뀌었으니 버전에 따라 다르게 입력해주어야 한다.  \r\n보통 처음 gpg-agent.conf 파일을 열었을때 두 값이 있으므로 어떤 값으로 써야할 지 알 수 있다. 하지만 알 수 없을 경우 버전을 확인하여 올바른 값을 입력해야한다.  \r\n31536000는 1년에 해당하는 초(sec)값이다.\r\n\r\n---\r\n\r\n### References\r\n\r\n- [Generating a new GPG key](https://help.github.com/articles/generating-a-new-gpg-key/)\r\n- [KenjiAbe|GitHub の GPG Key を設定する](https://medium.com/@star_zero/github%E3%81%AEgpg-key%E3%82%92%E8%A8%AD%E5%AE%9A%E3%81%99%E3%82%8B-70e22874e533)\r\n- [Keep GnuPG credentials cached for entire user session](https://superuser.com/questions/624343/keep-gnupg-credentials-cached-for-entire-user-session)\r\n","excerpt":"설치 우선 Homebrew 를 통해 gpg 패키지를 설치한다, 추가로 gpg 키 관리 프로그램인 GPG-SUITE를 설치한다. key 생성 키 생성 방법은 두가지가 있다. gpg-suite를 통한 설치 터미널내에서 설치…","fields":{"slug":"/github-gpg-key/"},"frontmatter":{"date":"Oct 24, 2018","title":"GitHub에 GPG 서명 등록하기 (macOS)","tags":["github"],"update":"Jan 31, 2020"}}},{"node":{"rawMarkdownBody":"\r\n몇시간 전부터(현재 181023 04:41) github 가 이상하다,  \r\n5시간 전에는 로그인 부분이 이상이 있었다, 지금은 이부분은 해결되고 github page 를 업데이트해도 반영이 되지 않고 있다.  \r\n올해들어 세번정도 github 시스템 이상을 체험했던 것 같다...\r\n\r\n그럴 때 마다 들어가는 사이트가 있는데 github 에서 제공하는 github system status 페이지이다.  \r\n날자별 시스템 상태들이 어땠는지 확인 할 수 있고, 이상이 있을때는 어떻게 되어가는지 상황을 계속해서 업데이트해준다.\r\n\r\n--- \r\n\r\nGithub 의 시스템 상태는 아래 링크에서 확인 할 수 있다.\r\n\r\n[GitHub System Status](https://status.github.com/)\r\n","excerpt":"몇시간 전부터(현재 181023 04:41) github 가 이상하다, 5시간 전에는 로그인 부분이 이상이 있었다, 지금은 이부분은 해결되고 github page 를 업데이트해도 반영이 되지 않고 있다. 올해들어 세번정도 github…","fields":{"slug":"/github-system-status/"},"frontmatter":{"date":"Oct 23, 2018","title":"GitHub 서버 오류, 시스템 이상할 때 상태를 확인하기","tags":["git","github"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n## 라디오 버튼의 스타일 바꾸기\r\n\r\n검색을 통해 쉽게 얻을 수 있는 라디오 버튼의 스타일 바꾸는 것은 대부분 :after, :before 를 사용하는데,  \r\n그렇게 되면 원하는대로 바꾸기가 쉽지 않고 원래의 개체가 노출되어 위치 조절을 해야하는 등 어려움이 있는데 아래 방법으로는 깔끔하고 원하는대로 가능하다.\r\ncss `appearence: none`을 시작으로 라디오 버튼을 수정하는 방법이다.\r\n\r\n### HTML\r\n\r\n```html\r\n<div class=\"radio-wrap\">\r\n  <input type=\"radio\" name=\"a\" id=\"a\"/>\r\n  <label for=\"a\">A</label>\r\n</div>\r\n\r\n<div class=\"radio-wrap\">\r\n  <input type=\"radio\" name=\"a\" id=\"a\"/>\r\n  <label for=\"a\">A</label>\r\n</div>\r\n```\r\n\r\n### CSS\r\n\r\n```css\r\ndiv.radio-wrap {\r\n  display: inline-flex;\r\n  align-items: center;\r\n}\r\n\r\ninput[type='radio'],\r\ninput[type='radio']:checked {\r\n  appearance: none;\r\n  width: 0.9rem;\r\n  height: 0.9rem;\r\n  border-radius: 100%;\r\n  margin-right: 0.1rem;\r\n}\r\n\r\ninput[type='radio'] {\r\n  background-color: $white-color;\r\n  border: 2px solid $font-color-3;\r\n}\r\ninput[type='radio']:checked {\r\n  background-color: $font-color-2;\r\n}\r\n```\r\n\r\n### 정리\r\n\r\n`input[type='radio']`, `input[type='radio']:checked`에  \r\n`appearance: none`을 함으로 모든 스타일이 제거된다.\r\n\r\n그렇게 되면 세로를 기준으로 가운데 정렬되어 텍스트와 나란히 있던 것이 무너지게 된다.  \r\n이를 해결하기 위해 div로 감싸고 해당 div에 스타일을 추가한다.  \r\n위 css 코드의 `div.radio-wrap{...}` Flex Diplay 스타일 적용으로 가운데 정렬을 할 수 있다.\r\n\r\n`input[type='radio']`, `input[type='radio']:checked`에  \r\n라디오 버튼의 크기 및 `border-radius` 등 주고싶은 공통 스타일을 주고 이제 각각의 `input[type='radio']`, `input[type='radio']:checked`에 원하는 색상, 테두리 등의 스타일을 적용해주면 된다.\r\n","excerpt":"라디오 버튼의 스타일 바꾸기 검색을 통해 쉽게 얻을 수 있는 라디오 버튼의 스타일 바꾸는 것은 대부분 :after, :before…","fields":{"slug":"/radio-style-change/"},"frontmatter":{"date":"Oct 19, 2018","title":"Radio Button의 색상 등 css를 바꾸기","tags":["css"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n## 블로그 개편, use Gatsby\r\n\r\n기존 Jekyll을 이용 다른 사람의 테마를 사용하여 블로그를 운영해오고 있었습니다만  \r\nJekyll로 제작된 블로그를 마음대로 수정하기에는 루비라던가 익숙하지 않은 것이 많아 고민이었는데 마침 Gatsby라는 정적 사이트 제작 프레임워크를 찾았고 개편을 마음 먹었습니다.\r\n\r\nGatsby는 **React**와 **Webpack**을 베이스로 제작되어서 그 점이 가장 마음에 들었고 편리하게 사이트를 구축하기 위한 Plugin도 많이 제공되고 있었습니다.  \r\n비록 테마나 구글링을 통해 얻을 수 있는 정보는 Jekyll보다 많이 부족하지만 애초에 테마가 아닌 처음부터 직접 구현하고 싶었기에 큰 문제는 아니었습니다.\r\n\r\n일단 시작은 Gatsby에서 제공하는 기본 starter인 [gatsby-starter-default](http://gatsbyjs.github.io/gatsby-starter-default/)\r\n를 clone하여 비어있는 화면 부터 시작했고 천천히 개발하기 시작하여 지금 이러한 블로그로 개발하였습니다.\r\n\r\n\r\n### Built With:\r\n\r\n개발에 사용된 기술은 크게 아래와 같습니다.\r\n\r\n- Gatsby.js\r\n- React\r\n- Webpack\r\n- GraphQL\r\n- SASS(SCSS)\r\n- typography\r\n\r\n### 후기\r\n\r\n`GraphQL`  \r\n지금까지 개발면서 일단 처음에 GraphQL을 접하면서 모르는 것이기도 했고 인터넷에 정보도 부족해 시작이 어려웠습니다. 끼워맞추듯 개발하며 이해하다보니 지금도 모르는 상태라고 할 수 있지만 조만간 제대로 한번 배워볼 예정입니다.\r\n\r\n`Theme?`  \r\n혼자 사용하는 것이 아닌 모두 사용할 수 있게 테마 형식으로 제작해 보려 합니다. 아직은 디테일한 기능들을 구현할게 남았고 그 이후에 코드 최적화를 하면서 개인화하여 쓸 수 있도록 수정할 예정입니다.\r\n\r\n`반응형 웹사이트`\r\n기존에도 항상 반응형으로 제작을 하긴 했지만 이번엔 여러모로 테스트를 하다 보니 쉽지 않다는 것을 다시금 느꼈습니다. 쉽게 orientation으로만 하려고 했더니 안드로이드에서는 가상 키보드가 나오면서 키보드가 차지한 부분이 감소되며 세로 비율이었던 orientation이 가로로 바뀌게 되어 모바일에 최적화된 화면에서 데스크탑 최적화된 화면이 출력되게 되는 문제를 겪기도 했습니다.\r\n\r\n`SEO, 웹표준`  \r\n기존의 Jekyll은 테마를 받아 사용하다보니 검색최적화나 Google Analytics가 다 적용된 상태였습니다만 이번에 처음부터 개발하다보니 웹표준과 SEO에 대해서도 신경쓰면서 하게 되었습니다.  \r\n\r\n- 웹사이트 점수 측정 100/100 [확인하기](https://website.grader.com/results/junhobaik.github.io)\r\n- NAVER 웹마스터 사이트 최적화 '최고에요' 등급\r\n\r\n웹표준에 관해서는 아직 부족한 게 많은 것 같으니 공부하고 수정해야 할 것 같고, SEO부분에 대해서는 구현을 마쳤고 이번에 많이 알게되었습니다.\r\n\r\n### Github\r\n\r\n[Github Repository](https://github.com/junhobaik/junhobaik.github.io)\r\n","excerpt":"블로그 개편, use Gatsby 기존 Jekyll을 이용 다른 사람의 테마를 사용하여 블로그를 운영해오고 있었습니다만 Jekyll로 제작된 블로그를 마음대로 수정하기에는 루비라던가 익숙하지 않은 것이 많아 고민이었는데 마침 Gatsby…","fields":{"slug":"/new-blog-notice/"},"frontmatter":{"date":"Sep 21, 2018","title":"블로그 개편 (Jekyll -> Gatsby)","tags":["gatsby","blog"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n## ₩ -> `\r\n코드를 작성하거나 마크다운 문서를 작성할때 한글키 입력 상태일때 키보드의 (~`)키를 누르면 ₩가 입력되는 것이 별거 아닌 것 같지만 상당히 불편한 요소로 작용합니다.\r\n\r\n생각보다 원화(₩) 문자를 쓸 일이 없으므로 아예 백쿼트(`) 문자가 입력되도록 바꿔보도록하겠습니다.\r\n\r\n방법은 아래 블로그를 참고하였습니다.\r\n\r\n[A2 Devlog](https://ani2life.com/wp/?p=1753)\r\n","excerpt":"…","fields":{"slug":"/mac-keybind-won-bq/"},"frontmatter":{"date":"Jul 02, 2018","title":"mac의 한글키에서 원화(₩)가 아닌 백쿼트(`)가 입력되도록 하기","tags":["mac"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nAngular 개발을 시작하기 전, 개발에 앞서 개발 환경 구성과 간단한 사용을 먼저 해보자.\r\n\r\n\r\n## TypeScript\r\n\r\nAugular를 본격적으로 하기 전 TypeScript를 설치하기로 하자.\r\n\r\n타입스크립트는 동적 타입 언어인 자바스크립트에 명시적으로 타입 선언이 가능하도록 정적 타입 언어의 장점을 가지게 된 언어이다.  \r\n\r\nAngular(!= AngularJS)는 TypeScript를 베이스로 만들어졌고,  \r\n왜 앵귤러에 타입스크립트인지는 아래 링크의 글을 읽어보면 좋을 것이다.\r\n\r\n[Angular: Why TypeScript](https://github.com/not-for-me/til/blob/master/angular2/translations/writing_angular2_in_typescript.md)\r\n\r\n### 설치\r\n\r\n아래 명령어를 사용하여 타입스크립트를 설치하자.\r\n\r\n```shell\r\n$ npm install -g typescript\r\n```\r\n\r\n글로벌 설치를 선호하지 않는다면 프로젝트내 설치하는 방법도 물론 괜찮다.\r\n\r\n글로버 설치를 했다면 이제 `tsc test.ts`와 같이 명령어로 타입스크립트를 컴파일 할 수 있다.\r\n\r\n만약 프로젝트 내 설치를 했다면 npm script에서 `\"tsc test.ts\"` 와 같이 스크립트를 추가하거나, \r\n콘솔 환경에서 `node_modules/.bin/tsc test.ts`와 같이 컴파일이 가능하다.\r\n\r\n아래 기술하는 내용들은 글로벌 설치를 전제로 설명하게 된다.\r\n\r\n### 설정\r\n\r\n```shell\r\n$ tsc --init\r\n```\r\n\r\n이제 프로젝트 내에서 위 명령어로 설정 파일(`tsconfig.json`)을 생성할 수 있다.\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es5\",\r\n    \"module\": \"commonjs\",\r\n      ...\r\n```\r\n\r\n어떤 자바스크립트 버전으로 컴파일 할건지 등 설정 파일 안에는 다양한 설정이 가능한데 앵귤러 개발 환경 구성 포스팅이므로 자세한 설정 방법은 생략하겠다.\r\n\r\n### TSLint\r\n\r\n추가적으로 TSLint를 사용하여 Lint 기능을 사용하는 것도 좋은 방법이다.\r\n\r\nnpm으로 설치하거나, Visual Studio Code와 같이 타입스크립트와 호환이 좋은 에디터에서 TSLint를 사용하면 좀 더 판하게 개발 할 수 있다.\r\n\r\n### 간단한 사용\r\n\r\n자바스크립트를 쓰는 것과의 차이점을 위해서 매우 간단한 예제를 살펴보자.\r\n\r\n```javascript\r\nconst n = 1;\r\nconst s = '1';\r\n\r\nconsole.log(n == s);\r\n```\r\n숫자 1과 문자 1을 비교하는 (Strict 비교 아님) 코드가 있고\r\n\r\n만약 이것이 자바스크립트 파일(.js)라고 가정하면 결과는 **true**가 될 것이다.  \r\n그리고 이것이 타입스크립트 파일(.ts)라고 가정하면 아래와 같은 결과를 얻을 수 있다.  \r\n\r\n우선 TSLint가 `==`가 아닌 `===`를 사용하라고 알려줄 것이고,  \r\n그리고 무시하고 컴파일을 진행한다면 아래와 같은 에러가 발생한다.\r\n\r\n```shell\r\nerror TS2365: Operator '==' cannot be applied to types '1' and '\"1\"'.\r\n```\r\n\r\n숫자와 문자열을 비교할 수 없다는 의미이다.\r\n\r\n클래스 등 좀 더 다양한 예제는 아래 링크에서 확인하면 좋다.\r\n\r\n[TypeScript PlayGround](http://www.typescriptlang.org/play/)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Angular CLI\r\n\r\n### 설치 및 프로젝트 생성\r\n\r\nAngular CLI를 이용해 앵귤러 개발을 시작하는 방법이다.\r\n\r\n```shell\r\n$ npm install @angular/cli -g\r\n$ ng --version\r\n```\r\n\r\n`ng new` 명령어를 통해 기본적인 코드와 설정이 되어있는 앵귤러 프로젝트를 생성할 수 있다.\r\n\r\n```shell\r\n$ ng new auglar-start-cli\r\n$ cd angular-start-cli\r\n```\r\n\r\n### 개발 서버\r\n\r\n이제 이렇게 생성된 프로젝트에서 아래 명령어를 통해 로컬 개발 서버를 켤 수 있다.\r\n\r\n```shell\r\n$ ng serve\r\n** Angular Live Development Server is listening on localhost: 4200, open your browser on http://localhost:4200/ **\r\n```\r\n\r\n그리고 출력된 주소로 가서 정상적으로 출력이 되고 있는지 확인해보자.\r\n\r\n### 기타 명령어\r\n\r\n생성된 프로젝트에서 컴포넌트 및 서비스를 생성한다면 직접 하는 방법도 있지만,  \r\nAngular CLI의 기본 구조대로 뷰, 컴포넌트(or Service), 스타일, 테스트 파일을 생성해주는 명령어가 있다.\r\n\r\n```shell\r\n# 컴포넌트 생성\r\n$ ng generate component COMPONENT_NAME\r\n# 서비스 생성\r\n$ ng g service SERVICE_NAME\r\n# generate는 g로 줄여 사용할 수 있다.\r\n```\r\n\r\n예로 이렇게 생성된 컴포넌트는 아래와 같은 구조를 가진다\r\n```javascript\r\n- home\r\n  - home.component.html // View\r\n  - home.component.ts // Component\r\n  - home.component.spec.ts // Test\r\n  - home.component.css // Style\r\n```\r\n\r\n---\r\n\r\n## References\r\n- 서적 '앵귤러 첫걸음' 한빛소프트\r\n- [Angular official](https://angular.io/guide/quickstart)\r\n","excerpt":"Angular 개발을 시작하기 전, 개발에 앞서 개발 환경 구성과 간단한 사용을 먼저 해보자. TypeScript Augular를 본격적으로 하기 전 TypeScript…","fields":{"slug":"/angular-setup/"},"frontmatter":{"date":"May 08, 2018","title":"Angular 시작하기 (개발 환경 구성)","tags":["angular"],"update":null}}},{"node":{"rawMarkdownBody":"\r\ncolors 모듈은 우리가 흔히 사용하는 `console.log`의 출력문에 색상을 입힐 수 있다.\r\n\r\n## 설치\r\n\r\n```shell\r\nnpm install --save colors\r\n```\r\n\r\n## 사용하기\r\n\r\n```javascript\r\nconst colors = require(\"colors\");\r\n```\r\n\r\n기본적인 사용.\r\n\r\n```javascript\r\nconsole.log(\"hello world\".red); // 빨간색 글씨\r\nconsole.log(\"hello world\".underline); // 밑줄\r\nconsole.log(\"hello world\".underline.blue); // 밑줄있는 파란색 글씨\r\nconsole.log(\"hello world\".inverse.yellow); // 배경이 노란색인 검정 글씨\r\nconsole.log(\"hello world\".rainbow); // 무지개색 글씨\r\nconsole.log(\"hello world\".trap); // 알아보기 힘든 모양의 글씨 (ƕɘĹĹʘ ШǾ®Ĺԁ)\r\n```\r\n\r\n아래와 같은 사용도 가능하다.\r\n\r\n```javascript\r\nconsole.log(colors.green(\"hello world\")); // 초록색 글씨\r\n```\r\n\r\n아래와 같은 방식으로 커스텀 테마를 지정해 사용할 수도 있다.\r\n\r\n```javascript\r\ncolors.setTheme({\r\n  error: 'red',\r\n  warn: 'yellow',\r\n});\r\n\r\nconsole.log('ERROR!'.error); // 빨간색 글씨\r\nconsole.log('Warning.'.warn); // 노랜색 글씨\r\n```\r\n\r\n```javascript\r\ncolors.setTheme({\r\n  test: ['blue', 'inverse']\r\n});\r\n\r\nconsole.log('testing'.test); // 파란색 배경의 검정 글씨\r\n```\r\n","excerpt":"colors 모듈은 우리가 흔히 사용하는 의 출력문에 색상을 입힐 수 있다. 설치 사용하기 기본적인 사용. 아래와 같은 사용도 가능하다. 아래와 같은 방식으로 커스텀 테마를 지정해 사용할 수도 있다.","fields":{"slug":"/colors-module/"},"frontmatter":{"date":"May 06, 2018","title":"콘솔에 색상을 입혀주는 'Colors' 모듈 사용해보기","tags":["undefined"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n처음 html, javascript를 공부 할 때는 script 태그는 head 태그에 위치하게끔 하는 코드나,  \r\n또는 body 태그의 어디에 위치하건 그 위치에 대해 별 의미를 두지 않는 코드들이 많았다.\r\n\r\n하지만 지금은 항상 스크립트는 body태그의 최하단에 넣는 것이 습관화되었고 그 이유도 알고 있다.  \r\n그런데 이제와서 이 글을 쓰는 이유는 **script 태그의 async / defer**를 공부하게 되면서 새로 정리해보고자 쓰게 되었다.\r\n\r\n## 브라우저의 동작과 script 위치의 2가지 이유\r\n\r\nHTML에서 script 태그가 body 태그 안의 최하단에 위치해야 하는 이유는 브라우저의 동작 방식과 연관이 있다.\r\n\r\n1. HTML을 읽기 시작한다.\r\n2. HTML을 파싱한다 (parsing: 컴퓨터가 읽을 수 있는 코드로 바꾸는 작업)\r\n3. DOM 트리 생성.\r\n4. Render 트리가 생성 (DOM tree + CSS의 CSSOM 트리 결합)\r\n5. Display(브라우저)에 표시된다.\r\n\r\n여기서 중요하게 봐야할 구간은 1~2의 과정이다.\r\n\r\nHTML을 읽어 내려가는 과정에서 script 요소를 만나면 파싱을 중단,  \r\n중단 된 상태에서 자바스크립트 코드(파일)을 로드 후 자바스크립트 코드를 파싱한다.  \r\n그리고 다시 HTML 파싱이 계속된다.\r\n\r\n결론적으로 HTML을 읽는 과정에서 자바스크립트 로드와 파싱을 위해서 중단되는 시점이 생기고,\r\n그에 따라 그 만큼 Display에 표시되는 것이 지연된다.\r\n\r\n또 다른 이유로 **HTML 파싱이 끝나고 DOM 트리가 생기기 전**에 자바스크립트가 실행되어 DOM 조작을 할 경우 에러가 발생할 수 있다는 점이다. 아래 예제를 보자.\r\n\r\n```javascript\r\nconst appEl = document.querySelector(.app);\r\n```\r\n\r\n우리는 위와 같이 DOM에 관한 조작을 무수히 할 것인데 DOM 트리가 렌더링 되기 전이라면 `appEl`은 `undefined`이다. 이러한 오류점이 발생한 이유를 모르거나, 디버깅을 못한다면 이를 해결하는데 꽤나 애먹을 것이다.\r\n\r\n이로 알 수 있는 script 태그가 body 태그 최하단에 위치해야하는 2가지 이유\r\n- HTML을 읽는 과정에서 중간에 스크립트를 만나면 스크립트 로드와 실행을 위해서 중단되는 시점이 생기고, 그에 따라 그 만큼 Display에 표시되는 것이 지연되게 된다.\r\n- HTML 파싱이 끝나고 DOM 트리가 생기기 전 자바스크립트가 실행되어 DOM 조작을 할 경우 에러가 발생할 수 있다.\r\n\r\n이렇게 body 태그 최하단에 위치해야하는 이유를 알아봤고,  \r\n다음으로는 body태그 최하단에 위치하지 않고도 이러한 이유를 방지하기 위해서 사용하는 **script 태그의 async / defer 속성**을 알아보자.\r\n\r\n## script 태그의 async / defer 속성\r\n\r\n기본적으로 script 태그는 위에서 작성한 브라우저의 동작 방식대로 불러진다.  \r\n하지만 async / defer 속성을 사용함으로 다르게 script 태그를 불러올 수 있게 된다.\r\n\r\n```html\r\n<script async src=\"index.js\"></script>\r\n<script defer src=\"index.js\"></script>\r\n```\r\n\r\nasync 또는 defer 속성을 사용하면 공통적으로 **HTML 파싱과 동시에 스크립트 로드**가 이루어진다.\r\n\r\n그 후에,  \r\n**async**의 경우에는 **HTML 파싱이 끝나지 않더라도 스크립트 로드가 완료되는 즉시 스크립트가 실행**된다.  \r\n**defer**의 경우에는 **HTML 파싱이 모두 끝난 뒤 스크립트가 실행**된다.\r\n\r\n추가적으로 async의 경우에는 비동기적으로 여러 스크립트를 로드, 실행하기 때문에 스크립트의 순서에 상관없이 실행될 수 있다. 따라서 실행 순서가 서로 영향이 있는 스크립트들을 사용할 때에는 주의해서 사용해야 한다. (동기적인 실행을 위해서는 `async=false`로 설정하여 순서대로 실행할 수 있다.) defer의 경우에는 실행은 순서대로 실행된다.\r\n\r\n결론적으로,  \r\n\r\nscript 태그가 body 태그의 최하단에 위치한다면 async와 defer가 필요없다고 할 수 있다.  \r\n하지만 그렇지 않을 경우 async와 defer를 활용해서 볼 수 있는 효과와 주의해야할 점을 정리해보면 아래와 같다.\r\n\r\n**async** 또는 **defer** 중 어느것을 사용하더라도 **HTML 파싱**과 **스크립트 로드**가 동시에 진행되므로 **HTML 파싱이 완료되는 시간을 줄일 수 있다**  \r\n\r\n**async**는 HTML 파싱과 동시에 스크립트 로드를 하지만 스크립트 실행은 HTML 파싱이 중지된 상태에서 되기 때문에 중간에 HTML 파싱이 멈추는 시점이 생길 수 있다. 다만 실행 순서를 감안해야 한다.\r\n\r\n**defer**는 HTML 파싱과 동시에 스크립트를 로드하고 HTML 파싱이 완료 된 후 스크립트가 실행된다. 위에서 설명한 script 태그가 body 태그의 최하단에 위치해야하는 이유에 모두 적합하다.\r\n\r\n---\r\n\r\n## References\r\n- [PoiemaWeb](http://poiemaweb.com/js-syntax-basics)\r\n- [MDN|<script>](https://developer.mozilla.org/ko/docs/Web/HTML/Element/script)\r\n","excerpt":"처음 html, javascript를 공부 할 때는 script 태그는 head 태그에 위치하게끔 하는 코드나, 또는 body 태그의 어디에 위치하건 그 위치에 대해 별 의미를 두지 않는 코드들이 많았다. 하지만 지금은 항상 스크립트는 body…","fields":{"slug":"/js-script-position/"},"frontmatter":{"date":"May 02, 2018","title":"HTML에서 script태그는 어디에 위치해야 할까?","tags":["javascript","html"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n\r\n기존 Jekyll을 이용한 블로그는 현재(2018.09) Gatsby를 이용한 블로그로 개편되었습니다.  \r\nJekyll의 minimal-mistakes테마를 이용한 블로그를 만들고 싶다면 아래 게시물은 아직 유효합니다.\r\n\r\n---\r\n\r\n[Jekyll 블로그 테마 적용하기 (minimal-mistakes)](https://junhobaik.github.io/jekyll-apply-theme/)  \r\n위 포스트를 먼저보시기를 추천드립니다.  \r\n위 포스트를 보고 어려움을 느끼거나 더 쉽게 적용하고 싶은 분들을 위한 방법을 적은 포스팅입니다.\r\n\r\n---\r\n\r\n~~이제 지금 보고 계시는 블로그가 맘에 들고 그대로 사용하시고 싶다,~~  \r\n~~이 블로그를 그대로 가져와 편집해 사용하고 싶다,~~  \r\n또는 기존의 테마 적용 포스트가 너무 어렵다.\r\n\r\n이러한 분들이 사용 할 수 있도록\r\n지금의 블로그에서 포스트들을 제거하고 개인 설정을 초기화 한 것을 준비해두었고\r\n그것을 받아서 개인 설정만 채워주면 사용 할 수 있는 방법을 소개합니다.  \r\n(지금 보고 있는 블로그와 차이가 있을 수 있습니다,\r\n2018.04 시점의 블로그를 기준으로 합니다.)\r\n\r\n일단 jekyll가 설치 되어있고 Github 계정이 필요하며,\r\n여기에 대한 것은 생략하고 테마 적용 부분에 대해서만 기술하습니다.  \r\n참고 : [Jekyll 블로그 시작하기 (MacOS, GitHub Page)](https://junhobaik.github.io/start-jekyll-blog/)\r\n\r\n\r\n## 적용하기\r\n\r\n[junhobaik/junhobaik.github.io](https://github.com/junhobaik/junhobaik.github.io)\r\n\r\n우선 위의 링크로 들어가 우측 상단의 Fork 버튼을 눌러 Fork 합니다.\r\n\r\n그렇다면 자신의 계정에 `junhobaik.github.io` 리포지토리가 생기게 되고,  \r\n리포지토리 페이지에서 `clone or download`에서 링크를 확인합니다 (ex. https://github.com/username/junhobaik.github.io.git)\r\n\r\n이제 terminal을 열고 clone 과 동시에 필요한 작업을 합니다.\r\n\r\n```shell\r\n# 아래 링크는 위에 clone or download에서 확인한 링크를 넣는다.\r\n$ git clone https://github.com/username/junhobaik.github.io.git blog\r\n$ cd blog\r\n$ git reset origin/dev --hard\r\n$ npm install\r\n# bundle 명령어 수행 시 sudo 권한으로 컴퓨터 비밀번호를 요구 할 수 있습니다.\r\n$ bundle\r\n$ git push -f\r\n```\r\n\r\n이제 다시 해당 리포지토리 페이지에 들어가서 Settings으로 들어갑니다.\r\n\r\nRepository name을 username.github.io로 변경합니다.  \r\n(여기서 username은 자신의 github username을 입력합니다.)\r\n\r\n리포지토리 이름이 변경된 것을 확인하시고,\r\n다시 설정 페이지에서 'GitHub Pages'란을 확인합니다.\r\n여기에 `Your site is published at https://username.github.io/` 라는 초록색 배경의 문구가 나왔다면 정상적으로 적용 된 것입니다. \r\n\r\n이제 해당 주소로 블로그를 볼 수 있습니다.  \r\n해당 주소에서 에러 페이지를 만난다면 약간의 시간이 필요할 수 있으니 조금만 기다려보세요.\r\n\r\n여기까지 하셨다면 [Jekyll 블로그 테마 적용하기 (minimal-mistakes)](https://junhobaik.github.io/jekyll-apply-theme/) 해당 포스트에서 **테마 설정하기**에서 **테마 스킨**부터 **댓글 설정**까지 개인 설정을 적용해주면 이제 포스트를 작성하고 블로그를 시작하면 됩니다.\r\n","excerpt":"기존 Jekyll을 이용한 블로그는 현재(2018.09) Gatsby를 이용한 블로그로 개편되었습니다. Jekyll의 minimal-mistakes테마를 이용한 블로그를 만들고 싶다면 아래 게시물은 아직 유효합니다. Jekyll…","fields":{"slug":"/jekyll-apply-theme-simple/"},"frontmatter":{"date":"Apr 28, 2018","title":"Jekyll 블로그 테마 '쉽게' 적용하기 (minimal-mistakes)","tags":["blog","jekyll"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nJavascript Hoisting에 대해 다시 살펴보던 도중, 예전에 공부할땐 var를 대상으로 공부했으니 깨닫지 못했는데 이번에 let, const를 가지고 해보니...  \r\n호이스팅이 되지 않았다. (정확히 말하면 호이스팅이 되지 않는 것은 아니다.)\r\n\r\n그래서 이제 어떻게 된건지 알아보자. (Hoisting의 개념과 Block-Scope 개념을 기본적으로 알고 있어야 이해가 가능하다.)\r\n\r\n## 기존의 Hoisting\r\n\r\n```javascript\r\nconsole.log(a);\r\nvar a = 10;\r\n```\r\n\r\n호이스팅 후 =>\r\n\r\n```javascript\r\nvar a;\r\nconsole.log(a); // undefinded\r\na = 10;\r\n```\r\n\r\n호이스팅이 적용된 코드는 위와 같고 따라서 undefinded가 출력된다.\r\n\r\n## let, const의 Hoisting\r\n\r\n```javascript\r\nconsole.log(a);\r\nlet a = 10;\r\n```\r\n\r\n이렇게 let으로 바꾼다면 결과는\r\n\r\n```shell\r\nUncaught ReferenceError: a is not defined\r\n```\r\n\r\n위와 같은 a가 정의되지 않았다는 레퍼런스 에러가 발생한다,  \r\n결국 a 변수 선언이 위로 호이스팅되지 않았다는 이야기가 된다.\r\n\r\n하지만 그렇지 않다.\r\n아래 예제를 보면 호이스팅이 안되는게 아니라는 것을 알 수 있다.\r\n\r\n```javascript\r\nlet a = 10;\r\n\r\n{\r\n  console.log(a);\r\n}\r\n```\r\n\r\n위 예제는 당연하게도 `10`이 출력된다.\r\n이제 아래 예제를 보자\r\n\r\n```javascript\r\nlet a = 10;\r\n{\r\n  console.log(a);\r\n  let a = 20;\r\n}\r\n```\r\n\r\n호이스팅이 되지 않는다면 위 코드 그대로 실행되어 10이 출력되는 것이 정상일 것이다.  \r\n그러나 여기서는 아래와 같이 에러가 출력된다.\r\n\r\n```shell\r\nUncaught ReferenceError: a is not defined\r\n```\r\n\r\n결국 let, const와 같이 ES6 선언도 호이스팅의 대상이기 때문에 위에서는 두번째 let의 블록 스코프안에서 호이스팅이 이뤄서 console.log에서 에러가 발생하게 된 것이다.\r\n\r\n그렇다면 이러한 에러가 발생하는 이유는 무엇일까,\r\n\r\n우선 var 키워드의 경우를 살펴보자,  \r\n```javascript\r\nvar a = 10;\r\n```\r\nvar로 선언된 변수는  \r\n[선언 - 초기화 - 할당] 의 단계 중  \r\n[선언 - 초기화]가 한번에 이루어지고 다음에 [할당]이 되게 된다.\r\n\r\n1. [선언 - 초기화]\r\n2. [할당]\r\n\r\n그에 반해 let/const 키워드는 다르게 실행된다.  \r\n선언, 초기화, 할당이 따로 이루어지고 **TDZ(Temporal Dead Zone)**라는 것이 개입한다.\r\n\r\n과정은 아래와 같다.\r\n\r\n1. [선언]\r\n2. [TDZ]\r\n3. [초기화]\r\n4. [할당]\r\n\r\n초기화(변수가 메모리에 할당되며 undefined로 초기화되는 과정)가 되기 전에 변수에 접근하려 한다면 **TDZ**에 의해서 에러가 발생하게 된다.\r\n\r\n```javascript\r\nvar a;\r\nconsole.log(a);\r\na = 10;\r\n```\r\n```javascript\r\nlet a;\r\nconsole.log(a);\r\na = 10;\r\n```\r\n\r\n위처럼 호이스팅 된 코드를 보면 변수에 접근하는 데 있어  \r\n기존 var 키워드는 선언과 초기화가 함께 되었으므로 접근하여도 정상적으로 undefined가 출력된다.  \r\n하지만 let/const 키워드는 선언만 호이스팅 되고 그것은 초기화 이전이므로 접근하려 한다면 TDZ에 의해서 에러가 발생하는 것이라고 볼 수 있다.\r\n\r\n여기까지 let/const의 관점에서의 Hoisting에 대해 포스팅해보았다.  \r\nlet/const를 사용하면서 조금 더 엄격한 자바스크립트를 작성할 수 있게 되었고 그로 인해 예기치 않은 오류를 작성하는 상황을 줄일 수 있게 된 것 같다.\r\n\r\n---\r\n\r\n## References\r\n\r\n- [let, const와 블록 레벨 스코프](http://poiemaweb.com/es6-block-scope)\r\n- [let과 const는 호이스팅 될까?](https://medium.com/korbit-engineering/let%EA%B3%BC-const%EB%8A%94-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EB%90%A0%EA%B9%8C-72fcf2fac365)\r\n","excerpt":"Javascript Hoisting에 대해 다시 살펴보던 도중, 예전에 공부할땐 var를 대상으로 공부했으니 깨닫지 못했는데 이번에 let, const…","fields":{"slug":"/js-let-cont-hoisting/"},"frontmatter":{"date":"Apr 26, 2018","title":"ES6, Hoisting으로 다시 보는 let, const","tags":["ES6","javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n[**Netflix AutoSkip**][1]\r\n\r\n넷플릭스 인트로, 줄거리 자동 스킵  \r\n다음 에피소드 재생 대기 시간 없이 바로 재생\r\n\r\n---\r\n\r\n넷플릭스를 런칭때부터 쭈욱 쓰던 입장으로 항상 불편했던 것이 있는데,  \r\n인트로 영상이 자동으로 스킵되지 않는다는 것이다. 스킵 버튼이 있긴하지만 수동으로 눌러줘야 한다.  \r\n그리고 정주행을 하면서 한 에피소드가 끝나고 다음 에피소드 재생까지는 대기 시간 5초 또는 15초가 있는데 정주행에선 그 것 조차 기다리기 싫을때가 있다.\r\n\r\n얼마 전 부터는 영상의 맨 처음이 줄거리나 인트로인 경우엔 그 다음 부터 재생이 되는 경우도 있지만  \r\n대부분이 에피소드가 시작하고 얼마 후에 인트로가 나오는 형식이기에 인트로가 긴 경우에는 멀리서 시청할 경우 컴퓨터 앞까지 가서 스킵 버튼을 누르곤 했다.\r\n\r\n그 불편함을 없애기 위해 간단한 프로그램을 하나 만들었다.\r\n\r\n---\r\n\r\n기능은 간단하다.\r\n\r\n- 인트로, 줄거리 스킵 버튼을 자동으로 눌러지게 한다.\r\n- 다음 에피소드 재생 버튼을 자동으로 눌러지게 한다.\r\n\r\n설정을 통해 각 스킵 설정들을 온오프할 수 있다.\r\n\r\n---\r\n\r\n다운로드는 아래 링크를 통해 가능하다.\r\n\r\n[Netflix AutoSkip 크롬 웹스토어 바로가기][1]\r\n\r\n\r\n[1]: https://chrome.google.com/webstore/detail/pfcombngcgnehkbdoafkhdcfdmklboai\r\n","excerpt":"Netflix AutoSkip…","fields":{"slug":"/netflix-autoskip/"},"frontmatter":{"date":"Apr 06, 2018","title":"넷플릭스 정주행을 위한 인트로 자동 스킵 크롬 확장 프로그램 (Netflix AutoSkip)","tags":["netflix"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n주로 CRA(create-react-app)을 이용한 리액트 개발을 주로 해왔고 그로 인해 웹팩(Webpack) 번들러를 통해 간단한 설정 변경 등을 해왔는데 이번에 새로운 번들러인 파셀(Parcel)을 알게되었다.\r\n\r\n공식 홈페이지의 헤드라인부터 **불꽃 튀게 빠르고 설정이 필요 없는 웹 애플리케이션 번들러**이다.  \r\n사용해보고나니 비교적 무거운 웹팩보다는 빠르다는게 느껴졌고 복잡했던 설정법보다는 쉽게 설정이 가능한 번들러였다. minify, hot module replacement와 같이 기본적으로 필요한 기능은 거의 포함되어있고 가벼우니 개인 소규모 프로젝트에는 좋을 것 같다는 생각이 들었다.\r\n\r\n\r\n\r\n## Parcel 시작하기\r\n\r\n[공식 홈페이지](https://parceljs.org/)\r\n\r\n일단 파셀을 사용하기 위해 글로벌 설치해보자\r\n```shell\r\n$ npm install -g parcel-bundler\r\n```\r\n\r\n다음으로 우선 git과 npm을 init하자\r\n```shell\r\n$ git init\r\n$ npm init\r\n```\r\n\r\n`index.html`, `index.js` 파일을 준비하고\r\n```html\r\n<!-- index.html -->\r\n<body>\r\n  <div id=\"root\"></div>\r\n  <script src=\"./index.js\"></script>\r\n</body>\r\n```\r\n위와 같이 js파일을 연결해준다.  \r\ndiv#root는 후에 React를 사용하기 위한 것이다.\r\n\r\n그리고 파셀 명령어로 개발 서버를 켜주면 파셀을 사용할 준비가 된 것이다.\r\n\r\n```shell\r\n$ parcel index.html\r\n\r\nServer running at http://localhost:1234\r\nBuilt in 9ms.\r\n```\r\n\r\nNPM Script에도 추가해두면 편리하게 사용이 가능하다.\r\n```json\r\n// package.json\r\n  \"scripts\": {\r\n    \"start\": \"parcel index.html\"\r\n  }\r\n```\r\n\r\n\r\n\r\n## React 사용하기\r\n\r\nReact 사용은 Parcel이라고 다르지 않으므로 간단히 다루겠다.\r\n\r\n```\r\n$ npm install --save react react-dom\r\n```\r\n\r\n이제 리액트 컴포넌트와 css파일을 만들고 index.js를 수정해보자\r\n\r\n`./src/App.js`\r\n```javascript\r\nimport React from 'react';\r\nimport './style.css';\r\n\r\nclass App extends React.Component {\r\n  render(){\r\n    return(\r\n      <div id=\"App\">\r\n        Hello World\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default App;\r\n```\r\n\r\n`./src/style.css`\r\n```css\r\nbody {\r\n  color: red;\r\n}\r\n```\r\n\r\n`./index.js`\r\n```javascript\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './src/App.js';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n```\r\n\r\n여기까지 리액트를 사용하기 위한 되었다.  \r\n허나 아직은 에러와 함께 작동하지 않을 것인데, 여기서 Babel이 필요하다.\r\n\r\n\r\n\r\n## Babel 사용하기\r\n\r\nBabel env, react preset을 설치한다.\r\n\r\n```shell\r\n$ npm install --save-dev babel-preset-env babel-preset-react\r\n```\r\n\r\n`./.babelrc` 파일을 생성, 설정을 등록한다.\r\n```json\r\n{\r\n  \"presets\": [\"env\", \"react\"]\r\n}\r\n```\r\n\r\n여기까지 했다면 작성했던 코드가 정상적으로 출력되는 것을 볼 수 있다.\r\n\r\n\r\n\r\n## SASS(SCSS) 사용하기\r\n\r\n정상적인 설치 방법은 우선 node-sass 모듈을 설치하는 과정을 거쳐야 하나 parcel을 사용하면 더 간편하게 사용할 수 있다.\r\n\r\n현재 css 파일을 scss 확장자로 바꾸고\r\ncss 파일을 import 했던 부분을 scss로 바꿔주면\r\n\r\nParcel이 자동으로 node-sass를 설치하며 적용된다.\r\n\r\n\r\n\r\n## Build\r\n\r\n[공식 문서 - production](https://parceljs.org/production.html)\r\n\r\n바로 npm script를 추가해 빌드를 해보자\r\n```json\r\n\"build\": \"parcel build index.html -d build --public-url ./\"\r\n```\r\n\r\n`-d build`는 `./build`폴더에 빌드한다는 뜻이며,  \r\n\r\n여기서 하나 알아두면 좋은 것은 `--public-url ./` 부분이다.  \r\n`--public-url ./` 옵션을 주게 되면 빌드 후 아래와 같은 결과가 나온다.\r\n\r\n```html\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"1a2b3c4d.css\">\r\nor\r\n<script src=\"e5f6g7h8.js\"></script>\r\n```\r\n\r\nGithub Page와 같은 정적 페이지 서비스를 사용할 경우에는 아래와 같이 할 수 있다.\r\n```shell\r\n$ parcel build index.html -d build --public-url https://username.github.io\r\n```\r\n\r\n그러면 결과가 아래와 같이 된다.\r\n```html\r\n<link rel=\"stylesheet\" type=\"text/css\" href=\"https://username.github.io/1a2b3c4d.css\">\r\nor\r\n<script src=\"https://username.github.io/e5f6g7h8.js\"></script>\r\n```\r\n\r\n이렇게 빌드를 하고나면 minify된 빌드 결과물을 얻을 수 있다.\r\n\r\n\r\n---\r\n\r\n여기까지 정말 간단하게만 Parcel로 작은 리액트 프로젝트를 사용하기 위한 준비를 해보았다. \r\n\r\nCRA(Create-react-app)과 프로젝트를 시작하는 단계에서 비교해보면 babel 설정과 같은 부분은 Parcel이 설정해줘야하는 것이 하나 더 있다는 점이 있지만 SASS 사용 등 복잡한 Webpack config를 뒤지고 수정하는 면에서는 Parcel이 더 간편하게 사용할 수 있는 것 같다.  \r\n\r\n---\r\n\r\n- References\r\n  - [Parcel documents](https://parceljs.org/getting_started.html)\r\n","excerpt":"주로 CRA(create-react-app)을 이용한 리액트 개발을 주로 해왔고 그로 인해 웹팩(Webpack) 번들러를 통해 간단한 설정 변경 등을 해왔는데 이번에 새로운 번들러인 파셀(Parcel…","fields":{"slug":"/parcel-start/"},"frontmatter":{"date":"Mar 23, 2018","title":"웹팩 대신 파셀(Parcel) 사용해보기 with React, Babel, SASS","tags":["parcel","react","sass","babel"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n## Vue.JS 설치\r\n\r\n\r\n\r\n### CDN으로 설치하기\r\n\r\n```html\r\n<script src=\"https://unpkg.com/vue\"></script>\r\n```\r\n\r\n간단히 index.html 내에 위 코드를 추가하는 것만으로 vue를 간단하게 사용할 수 있다.  \r\n다만 CDN을 기반으로 Vue를 개발하려면 .vue 확장자를 이용하는 개발은 할 수 없어 싱글 파일 컴포넌트 개발이 불가능하고 개발에 제약이 따른다.  \r\n제대로 된 vue 개발을 위해서는 아래의 방법을 시도하자.\r\n\r\n### NPM으로 설치하기\r\n\r\n```shell\r\n# 최신 stable 버전\r\n$ npm install vue\r\n```\r\n\r\n프로젝트 내에 vue를 설치하여 사용할 수 있다. Webpack 등 각종 번들러와도 잘 작동한다.  \r\n허나 더 편리하게 초기 세팅을 하고 싶다면 아래의 Vue CLI를 사용하는 방법이 최선일 것이다.\r\n\r\n\r\n## 개발 도구 설치\r\n\r\n\r\n### Vue CLI\r\n\r\n```shell\r\n# vue-cli 설치\r\n$ npm install --global vue-cli\r\n\r\n# vue init <template-name> <project-name>\r\n# \"webpack\" 템플릿을 이용해서 새 프로젝트 생성\r\n$ vue init webpack my-project\r\n\r\n$ cd my-project\r\n# 의존성 설치\r\n$ npm install\r\n# 개발 서버 실행\r\n$ npm run dev\r\n```\r\n\r\n이렇게 하면 react의 create-react-app과 같이 webpack 환경의 프로젝트 구조가 자동 생성되며 이제 이것을 기본으로 개발을 시작하면 된다.\r\n\r\n\r\n### Vue DevTools\r\n\r\nReact와 유사하게 크롬 개발 도구에서 사용할 수 있는 개발툴을 지원한다.\r\n\r\n[크롬 확장 프로그램 설치](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)\r\n\r\n---\r\n\r\n## References\r\n- https://kr.vuejs.org\r\n","excerpt":"Vue.JS 설치 CDN으로 설치하기 간단히 index.html 내에 위 코드를 추가하는 것만으로 vue를 간단하게 사용할 수 있다. 다만 CDN을 기반으로 Vue를 개발하려면 .vue…","fields":{"slug":"/vuejs-install/"},"frontmatter":{"date":"Feb 21, 2018","title":"Vue.JS 및 Vue 개발 도구 설치하기","tags":["vue","javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n## Symbolic Link?\r\n개발을 하던 중 한 파일이 여러 곳에서 필요한 경우가 있다.  \r\n물론 모듈을 써서 사용하겠지만 개발 공부할 때는 종종 있는 일이다.\r\n\r\n그래서 복사 붙여놓기 보다는 나은 방법이 심볼릭 링크인 것 같아 방법을 소개한다.  \r\n개발 외에서도 활용하고 있는 심볼릭 링크도 소개해보겠다.\r\n\r\n```shell\r\n- ONE\r\n  - index.html\r\n  - style.css\r\n- TWO\r\n- THREE\r\n```\r\n<br/>\r\n위와 같은 폴더 구조에서 ONE 폴더에 위치한 style.css 파일이 TWO 폴더안에 필요하다고 해보자.\r\n```shell\r\n# 작업 위치를 TWO 폴더로 이동\r\n$ cd TWO/\r\n# 심볼릭 링크\r\n$ ln -s ../ONE/style.css style.css\r\n```\r\n<br/>\r\n다른 경우로 THREE 폴더에서 ONE폴더가 필요하다고 해보자.  \r\n그리고 THREE 폴더의 링크된 ONE폴더의 이름은 _ONE 이라 해보자.\r\n```shell\r\n# 작업 위치를 THREE 폴더로 이동\r\n$ cd THREE/\r\n# 심볼릭 링크\r\n$ ln -s ../ONE _ONE\r\n```\r\n이렇게 간단하게 사용할 수 있다, 어떻게 보면 복사 붙여놓기보다 간단하게 사용할 수 있다.\r\n\r\n<br/>\r\n이렇게 심볼링 링크된 것을 GitHub 웹페이지에서 확인해보면 어떨까?  \r\nTWO 폴더의 링크된 style.css 파일을 GitHub 웹페이지에서 확인해보면 아래와 같다.\r\n\r\n```\r\nSymbolic link |  1 lines (1 sloc) | 25 Bytes\r\n--------------------------------------------\r\n1 | ../ONE/style.css\r\n```\r\n\r\n---\r\n\r\n## 클라우드에 활용하기\r\n\r\n현재 NAS에 아래에서 소개할 방법으로 심볼릭 링크를 활용하고 있다, 여기서는 구글 드라이브로 예를 들어보겠다.\r\n\r\n구글 드라이브와 같은 클라우드에 폴더를 동기화할때도 요긴하게 쓰일 수 있는데,  \r\n컴퓨터에 설치하여 사용하는 설치형 구글 드라이브를 예로 들어보겠다.\r\n\r\nA 폴더를 구글 드라이브에서 사용하기 위해서 구글 드라이브로 복사한다면,  \r\n컴퓨터 저장 공간에 A폴더 용량, 그리고 구글 드라이브의 A폴더 용량.  \r\n이렇게 중복되어 많은 용량을 차지하게 된다.\r\n\r\n그러나 A 폴더를 심볼릭 링크로 구글 드라이브에 링크를 해놓으면 해결된다.  \r\n컴퓨터 내에서 구글 드라이브에 위치한 A폴더 심볼링 링크는 사실상 바로가기라고 보면 된다.\r\n그리고 구글 드라이브는 바로가기라고 해서 바로가기를 동기화해가는 것이 아닌 A폴더 자체를 동기화 하게 된다.  \r\n이렇게 하면 용량도 절약하며 링크가 되어있으므로 A폴더를 수정해도 구글 드라이브에 반영되게 된다.\r\n","excerpt":"Symbolic Link…","fields":{"slug":"/mac-symbolic-link/"},"frontmatter":{"date":"Feb 20, 2018","title":"MacOS, 심볼릭 링크 사용하기","tags":["undefined"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n코딩용 폰트는 여러가지가 있다.  \r\nJAVA 사용자가 많이들 선호하는 Consolas나 요즘 뜨고 있는 fira code라던가 말이다.  \r\n많은 폰트를 써봤지만 현재는 _Hack_ 폰트를 사용하고 있다. 본인 생각에 튀는 부분 없이 심플하고 가독성이 좋은 것 같아 사용하고 있다.\r\n\r\n## Hack\r\n\r\n- [글꼴 샘플](https://source-foundry.github.io/Hack/font-specimen.html)\r\n- [글꼴 써보기](https://sourcefoundry.org/hack/playground.html)\r\n- [글꼴 다운로드](https://sourcefoundry.org/hack/#download)\r\n\r\n이름에서도 알 수 있듯이 오로지 개발을 위해 만들어진 글꼴이다. \r\n\r\n개발자를 위한 글꼴의 조건에는 여러개가 있다, 아래는 대표적인 조건이다.\r\n\r\n**햇갈릴 수 있는 글자의 구분**\r\n: 예) i l I / 0 O / ; :\r\n\r\n**고정폭일 것**\r\n: 일반적인 글꼴은 가변폭이 많다. 대표적으로 윈도우의 '굴림'이나 '돋움'이 해당한다.  \r\n코딩할 땐 공백과 글자 수에 따른 일정한 넓이와 그에 따른 여러 라인을 비교할 수 있도록 고정폭 글꼴의 사용이 필요하다.\r\n\r\nHack은 이러한 조건들을 만족하는 글꼴이다.\r\n\r\n## 글꼴 설정하기\r\n\r\n### Mac\r\n\r\n'서체 관리자' 앱을 실행하여 다운받은 글꼴을 추가한다.  \r\n앱을 못찾겠으면 Spotlight 검색을 통해 쉽게 찾을 수 있다.\r\n\r\n### Visual Studio Code\r\n\r\n**'Code - 기본 설정 - 설정'**에 진입한다.\r\n\r\n최신 버전의 VSCode에서는 GUI 방식 설정창이 뜨게 된다.\r\n\r\n여기서 `Editor: Font Family` 항목을 찾아 입력칸의 첫번째에 Hack을 추가해주면 된다.\r\n\r\n`Hack, Menlo, Monaco, 'Courier New', monospace`와 같이 말이다.\r\n\r\n위와 같이 글꼴을 여러개 나열 할 경우,  \r\n만약 첫번째로 설정한 글꼴가 어떠한 이유로 적용되지 않는 경우 그 다음 글꼴이 적용된다.\r\n\r\n혹시나 GUI 방식의 설정창이 뜨지 않고 `settings.json` 파일이 뜨거나 설정창에서 우측 상단의 `{}` 버튼을 누를 경우 진입한 설정 파일에서는 아래와 같이 설정을 추가하거나 수정해주면 된다.\r\n\r\n```json\r\n{\r\n  \"editor.fontFamily\": \"Hack, Menlo, Monaco, 'Courier New', monospace\"\r\n}\r\n```\r\n","excerpt":"코딩용 폰트는 여러가지가 있다. JAVA 사용자가 많이들 선호하는 Consolas나 요즘 뜨고 있는 fira code라던가 말이다. 많은 폰트를 써봤지만 현재는 Hack…","fields":{"slug":"/dev-font-vsc/"},"frontmatter":{"date":"Feb 13, 2018","title":"개발자 글꼴 Hack, 그리고 VSCode 글꼴 설정하기","tags":["VSCode"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nHTML 태그안에 데이터 속성(**data-**)을 두어 그 데이터를 JS나 CSS에서 불러 쓸 수 있다.\r\n\r\n\r\n\r\n## HTML\r\n\r\n```html\r\n<tag id=\"a\" data-test-keyword=\"ABC\"></tag>\r\n```\r\n\r\n`data-` 뒤에 데이터 속성의 이름을 입력한다.\r\n\r\n`-`, `.`, `:`, `_` 와 영문 소문자가 입력 가능하다. (대문자는 불가능)\r\n\r\n위의 예제에서는 **test-keyword**이다.\r\n\r\n\r\n\r\n## JavaScript\r\n\r\n```javascript\r\nconst el = document.querySelector('#a');\r\n\r\nconsole.log(el.dataset.testKeyword); // \"ABC\"\r\n```\r\n\r\nJavaScript에서의 접근법으로는 `dataset` 을 이용하여 불러올 수 있다.\r\n\r\n데이터 속성 이름에서`data-`를 뺀 뒤 camelCase로 변환되어있다.\r\n\r\n따라서 위에서 지정한 `data-test-keyword`가 `testKeyword`가 되었다.\r\n\r\n\r\n\r\n## CSS\r\n\r\n```css\r\n#a[data-test-keyword=\"ABC\"] {\r\n    display: none;\r\n}\r\n```\r\n\r\nCSS에서는 HTML의 데이터 속성 이름 그대로를 사용해 접근 할 수 있다.\r\n\r\n\r\n\r\n---\r\n\r\n### References\r\n[https://developer.mozilla.org/ko/docs/Web/API/HTMLElement/dataset](https://developer.mozilla.org/ko/docs/Web/API/HTMLElement/dataset)\r\n","excerpt":"HTML 태그안에 데이터 속성(data-)을 두어 그 데이터를 JS나 CSS에서 불러 쓸 수 있다. HTML  뒤에 데이터 속성의 이름을 입력한다. , , ,  와 영문 소문자가 입력 가능하다. (대문자는 불가능) 위의 예제에서는 test…","fields":{"slug":"/html-dataset/"},"frontmatter":{"date":"Feb 10, 2018","title":"HTML 데이터 속성 사용하기 (data-, dataset)","tags":["html","javascript","css"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nVisual Studio Code를 쓰기 시작하면서 데스크탑과 랩탑간 설정 동기화가 필요해 방법을 찾다가  \r\n확장 플러그인 **Settings Sync**를 사용하여 하는 방법을 발견했다.\r\n\r\n---\r\n\r\n## 1. 확장 플러그인 'Settings Sync' 설치\r\n\r\nhttps://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync\r\n\r\n\r\n## 2. GitHub account token 발급받기\r\n\r\n'Settings Sync'는 Github의 gist 토큰을 사용하여 설정 업로드, 다운로드가 이뤄진다.\r\n\r\n토큰을 발급받기 위해 Github에서 하단의 메뉴로 진입한다.\r\n\r\n**Settings > Developer settings > Personal access tokens > Generate New Token**\r\n\r\n나타나는 메뉴에서 **gist**에 체크 후 토큰을 생성한다.  \r\n생성 후 화면에 보이는 토큰 문자열을 이용하여 설정 업로드, 다운로드가 이뤄진다.\r\n\r\n## 3. 설정 업로드 / 다운로드\r\n\r\n단축키는 아래와 같다.\r\n1. Upload Key : Shift + Alt + U\r\n2. Download Key : Shift + Alt + D\r\n\r\n단축키를 통해 나타나는 입력칸에 토큰을 입력하면 설정 업로드, 다운로드가 이뤄지게 된다.\r\n한번 입력과정을 거치면 다음부터는 단축키 한번으로 업로드 다운로드가 가능하다.\r\n","excerpt":"Visual Studio Code를 쓰기 시작하면서 데스크탑과 랩탑간 설정 동기화가 필요해 방법을 찾다가 확장 플러그인 Settings Sync를 사용하여 하는 방법을 발견했다. 1. 확장 플러그인 'Settings Sync' 설치 https…","fields":{"slug":"/vsc-settings-sync/"},"frontmatter":{"date":"Feb 08, 2018","title":"Visual Studio Code 설정 기기 간 동기화하기","tags":["VSCode"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nWebStorm을 쓰다가 Visual Studio Code를 사용하니 React를 쓰기에 불편함이 한두가지가 아니다.\r\n\r\n제일 처음 맞은 불편함이 JSX에서 emmet 자동완성이 작동 안되는 것인데,    \r\n해결 방법으로 여러 방법이 있었지만 제일 간단한 방법은 아래와 같다.\r\n\r\n기본 설정에서 아래 코드를 추가해준다.\r\n\r\n```json\r\n{\r\n    \"files.associations\": {\r\n        \"*.js\": \"javascriptreact\"\r\n    }\r\n}\r\n```\r\n\r\n---\r\nReferences\r\n: [Change language to JSX in Visual Studio Code\r\n](https://stackoverflow.com/questions/32832264/change-language-to-jsx-in-visual-studio-code)\r\n","excerpt":"WebStorm을 쓰다가 Visual Studio Code를 사용하니 React를 쓰기에 불편함이 한두가지가 아니다. 제일 처음 맞은 불편함이 JSX에서 emmet…","fields":{"slug":"/vsc-react-syntax/"},"frontmatter":{"date":"Feb 07, 2018","title":"VSCode(Visual Studio Code)에서 React JSX 자동완성 기능 활성화하기","tags":["VSCode"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nMacOS 재설치 후 기본적인 설정을 하면서 **간단히** 정리해본 MySQL 설치 과정\r\n\r\n\r\n## MySQL 설치\r\n```\r\n$ brew install mysql\r\n```\r\n\r\nbrew 명령어를 위한 HomeBrew 패키지 관리자 미설치시 아래 명령어를 통해 설치 필요  \r\n`$ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"`\r\n\r\n\r\n## MySQL 설정\r\n\r\n아래 명령어로 mysql을 시작합니다.\r\n\r\n```\r\n$ mysql.server start\r\n```\r\n\r\n아래 명령어로 기본 설정을 시작합니다.\r\n```\r\n$ mysql_secure_installation\r\n```\r\n이제 여러 질문들이 출력됩니다.  \r\n출력에 대한 답은 본인이 한 방법으로만 간단하게 기술하겠습니다.\r\n\r\n우선 아래의 과정에 앞서 정리해보자면 아래와 같습니다.\r\n1. 비밀번호 복잡도 검사 과정 (n)\r\n2. 비밀번호 입력 & 확인\r\n3. 익명 사용자 삭제 (y)\r\n4. 원격 접속 허용 (n)\r\n5. test DB 삭제 (n)\r\n6. previlege 테이블을 다시 로드할 것인지 (y or n)\r\n\r\n아래는 위에 나타낸 과정의 자세한 내용입니다.\r\n\r\n```\r\nSecuring the MySQL server deployment.\r\n\r\nConnecting to MySQL using a blank password.\r\n\r\nVALIDATE PASSWORD PLUGIN can be used to test passwords\r\nand improve security. It checks the strength of password\r\nand allows the users to set only those passwords which are\r\nsecure enough. Would you like to setup VALIDATE PASSWORD plugin?\r\n\r\nPress y|Y for Yes, any other key for No:\r\n```\r\n위의 과정은 복잡한 비밀번호 설정을 위한 과정을 거치겠냐고 묻는 과정이며,  \r\n**No**로 스킵하였습니다.\r\n\r\n```\r\nPlease set the password for root here.\r\n\r\nNew password:\r\n\r\nRe-enter new password:\r\n```\r\n위의 과정은 루트 비밀번호를 입력하는 과정입니다.  \r\n비밀번호와 비밀번호 확인란을 입력하게 됩니다.\r\n\r\n```\r\nBy default, a MySQL installation has an anonymous user,\r\nallowing anyone to log into MySQL without having to have\r\na user account created for them. This is intended only for\r\ntesting, and to make the installation go a bit smoother.\r\nYou should remove them before moving into a production\r\nenvironment.\r\n\r\nRemove anonymous users? (Press y|Y for Yes, any other key for No) : y\r\n```\r\n익명 사용자를 삭제할 것인지 묻습니다.  \r\n**y**를 입력하였습니다.\r\n\r\n```\r\nNormally, root should only be allowed to connect from\r\n'localhost'. This ensures that someone cannot guess at\r\nthe root password from the network.\r\n\r\nDisallow root login remotely? (Press y|Y for Yes, any other key for No) : y\r\n```\r\n원격 접속을 허용할 것인지 묻습니다,  \r\n로컬에서만 개발 예정이기에 **y**를 입력했습니다.\r\n\r\n```\r\nBy default, MySQL comes with a database named 'test' that\r\nanyone can access. This is also intended only for testing,\r\nand should be removed before moving into a production\r\nenvironment.\r\n\r\nRemove test database and access to it? (Press y|Y for Yes, any other key for No) :\r\n```\r\ntest 데이터베이스 삭제를 묻고 있습니다.  \r\n**No**를 입력하였습니다.\r\n\r\n```\r\nReload privilege tables now? (Press y|Y for Yes, any other key for No) :\r\n```\r\nprevilege 테이블을 다시 로드할 것인지 묻습니다.\r\n\r\n**yes**를 입력, 과정을 마칩니다.\r\n\r\n```\r\nAll done!\r\n```\r\n위의 메세지와 함께 설정이 종료됩니다.\r\n\r\n추가적으로 mysql server가 재부팅과 상관없이 켜져있을 수 있도록 brew services를 이용하여 서버를 켜두겠습니다.\r\n\r\n```\r\n$ brew services start mysql\r\n```\r\n\r\n## MySQL 사용\r\n```\r\n$ mysql -u root -p\r\n```\r\n위 명령어 입력 후 루트 비밀번호를 입력하여 mysql을 사용할 수 있게 됩니다.\r\n","excerpt":"MacOS 재설치 후 기본적인 설정을 하면서 간단히 정리해본 MySQL 설치 과정 MySQL 설치 brew 명령어를 위한 HomeBrew 패키지 관리자 미설치시 아래 명령어를 통해 설치 필요  MySQL 설정 아래 명령어로 mysql…","fields":{"slug":"/mac-install-mysql/"},"frontmatter":{"date":"Jan 29, 2018","title":"간단하게 MySQL 설치하기 (Mac, HomeBrew)","tags":["mysql"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nMacOS 재설치 후 기본적인 설정을 하면서 **간단히** 정리해본 Node.js, npm, yarn 설치 과정\r\n\r\n## Node, NPM 설치\r\nNode를 설치하기에 가장 간단하고 좋은 방법이라 생각하는 HomeBrew를 통한 설치를 해보겠습니다.  \r\n좋은 방법이라는 이유는 업데이트, 제거가 다른 설치 방법에 비해 비교적 쉽기 때문입니다.\r\n\r\n아래 명령어를 통해 설치를 진행합니다.\r\n```\r\n$ brew install node\r\n```\r\n\r\nbrew 명령어를 위한 HomeBrew 패키지 관리자 미설치시 아래 명령어를 통해 설치 필요  \r\n(brew가 설치되어 명령어가 정상작동했다면 아래 명령어는 불필요합니다.)\r\n```\r\n$ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\r\n```\r\n\r\n설치 확인 & 버전 확인\r\n```\r\n$ node -v\r\n$ npm -v\r\n```\r\n\r\n## yarn 설치\r\nyarn 설치시 위에서 Node는 설치하였으니 node를 빼고 설치하도록 합니다.\r\n```\r\n$ brew install yarn --without-node\r\n```\r\n\r\n설치 확인 & 버전 확인\r\n```\r\n$ yarn -v\r\n```\r\n## 업데이트 & 언인스톨 방법\r\n\r\n차후 업데이트 또는 언인스톨이 필요할 때 아래와 같은 방법으로 가능합니다.\r\n\r\n### 업데이트\r\n```\r\n  우선 HomeBrew를 최신버전으로 업데이트 합니다.\r\n$ brew update\r\n\r\n  원하는 업데이트를 수행합니다.\r\n$ brew upgrade node\r\n$ brew upgrade yarn\r\n```\r\n\r\n### 언인스톨\r\n```\r\n$ brew uninstall node\r\n$ brew uninstall yarn\r\n```\r\n","excerpt":"MacOS 재설치 후 기본적인 설정을 하면서 간단히 정리해본 Node.js, npm, yarn 설치 과정 Node, NPM 설치 Node를 설치하기에 가장 간단하고 좋은 방법이라 생각하는 HomeBrew…","fields":{"slug":"/install-node-yarn/"},"frontmatter":{"date":"Jan 29, 2018","title":"간단하게 Node.js, npm, yarn 설치하기","tags":["node","npm","yarn"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n\r\n새로운 포스트로 업데이트 되었습니다. 아래 링크를 통해 확인할 수 있습니다.  \r\n> [mac 터미널 환경 구성하기 (zsh, oh my zsh, zplug, hyper)](https://junhobaik.github.io/mac-terminal-setting/)\r\n\r\n----\r\n\r\nMacOS 재설치 후 기본적인 설정을 하면서 **간단히** 정리해본 Mac 터미널 세팅 과정\r\n\r\n\r\n## zsh 설치\r\n\r\n1. zsh 현재 버전 확인\r\n\r\n  ```\r\n$ zsh --version\r\n  ```\r\n\r\n2. zsh 최신 버전 설치\r\n\r\n  ```\r\n$ brew install zsh\r\n  ```\r\n\r\n  ```\r\n  # brew 명령어를 위한 HomeBrew 패키지 관리자 미설치시 아래 명령어를 통해 설치 필요\r\n  # 위 명령어가 이상없이 작동한다면 아래 명령어는 불필요합니다.\r\n  $ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\r\n  ```\r\n\r\n3. Terminal 재실행 후 zsh 현재 버전 확인\r\n\r\n  ```\r\n$ zsh --version\r\n  ```\r\n\r\n## Oh My Zsh 설치\r\n\r\n```\r\n$ sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\r\n```\r\n\r\n## zsh Plugins\r\n\r\n플러그인은 `zsh-syntax-highlighting` `zsh-autosuggestion` `autojump` 이 세가지 플러그인을 추천합니다.  \r\n여기서는 설치하지 않지만, alias에 익숙하지 않으신 분이라면 [alias-tips](https://github.com/djui/alias-tips)도 추천합니다.\r\n\r\nbrew를 통해 설치해줍니다.\r\n\r\n```\r\n$ brew install zsh-syntax-highlighting zsh-autosuggestion autojump\r\n```\r\n\r\n.zshrc 파일을 수정합니다.\r\n\r\n```\r\n$ vi ~/.zshrc\r\n```\r\n\r\n```\r\nplugins=(git zsh-syntax-highlighting zsh-autosuggestion autojump)\r\n```\r\n\r\n## 터미널 App 추천\r\n\r\n대표적인 터미널 앱으로는 iTerm2가 가장 유명하고 많이 쓰입니다.  \r\n본인은 기존 iTerm2를 쓰다가 지금은 Hyper를 사용하고 있습니다.\r\n\r\n### iTerm\r\n\r\n[iTerm Official Site](https://www.iterm2.com/)\r\n\r\n[다운로드 페이지](https://www.iterm2.com/downloads.html)\r\n\r\n또는 brew를 이용해 설치할 수 있습니다. (cask 설치 필요)\r\n\r\n`brew cask install iterm2`\r\n\r\n### Hyper\r\n\r\n[Hyper Official Site](https://hyper.is)\r\n\r\n[다운로드 페이지](https://hyper.is/#installation)\r\n\r\n또는 brew를 이용해 설치할 수 있습니다. (cask 설치 필요)\r\n\r\n`brew cask install hyper`\r\n","excerpt":"새로운 포스트로 업데이트 되었습니다. 아래 링크를 통해 확인할 수 있습니다.   mac 터미널 환경 구성하기 (zsh, oh my zsh, zplug, hyper) MacOS 재설치 후 기본적인 설정을 하면서 간단히 정리해본 Mac…","fields":{"slug":"/mac-terminal/"},"frontmatter":{"date":"Jan 29, 2018","title":"Mac Terminal 설정 (zsh, oh my zsh, plugin)","tags":["undefined"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nVisual Studio Code 에서 사용중인 확장을 정리해둔 글입니다.\r\n\r\nFront-End 개발 환경에 맞게 되어있습니다.\r\n\r\n:star: 는 강력 추천!\r\n\r\n## VSCode 기본 플러그인 및 테마\r\n\r\n- [Korean Language Pack for Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-ko)  \r\n  비주얼 스튜디오 코드의 언어(UI 언어 등)를 한국어로 만들어줍니다.\r\n\r\n- [Dracula Official](https://marketplace.visualstudio.com/items?itemName=dracula-theme.theme-dracula)  \r\n  색 테마\r\n\r\n- [Material Icon Theme](https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme)  \r\n  아이콘 테마\r\n\r\n## A\r\n\r\n- [Active File In StatusBar](https://marketplace.visualstudio.com/items?itemName=RoscoP.ActiveFileInStatusBar)  \r\n  VSCode 최하단 상태바에 작업중인 파일의 경로가 나타납니다.\r\n\r\n- [Auto Rename Tag](https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag) :star:  \r\n  `<tag>` `</tag>` 하나의 태그를 수정하면 짝이되는 태그도 동시에 함께 수정됩니다.\r\n\r\n## B\r\n\r\n- [Blank Line at the End of File](https://marketplace.visualstudio.com/items?itemName=riccardoNovaglia.missinglineendoffile)  \r\n  파일 저장시 맨 하단에 빈줄 하나를 추가해 저장해준다.  \r\n  Prettier 확장을 이용해 자동으로 저장 시 정렬을 활성화 해 두었다면 해당 확장은 필요 없을 것입니다.\r\n\r\n- [Bracket Pair Colorizer](https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer) :star:  \r\n  `{((({})))}` 브라켓의 단계에 따라 색상을 다르게 해주고, 들여쓰기 단계를 쉽게 구분할 수 있게 하는 가이드 라인이 추가된다.  \r\n  버전2가 개발중이고 사용 가능하나, 아직은 이슈가 많아 해당 버전1을 사용하는 것이 좋다.\r\n\r\n- [Bookmarks](https://marketplace.visualstudio.com/items?itemName=alefragnani.Bookmarks) :star:  \r\n  코드 북마커 기능.\r\n\r\n## C\r\n\r\n- [Color Highlight](https://marketplace.visualstudio.com/items?itemName=naumovs.color-highlight) :star:  \r\n  `#fff` `rgb(0,0,0)`과 같은 컬러 코드의 텍스트 배경색을 해당 색상으로 보여준다.\r\n\r\n- [Color Info](https://marketplace.visualstudio.com/items?itemName=bierner.color-info)  \r\n  색상 코드에 마우스를 올리면 해당 색상의 다른 타입 값들을 보여준다. 예로 rgb 컬러의 hex 컬러 값은 어떤 것인지 아는 용도로 활용이 가능하다.\r\n\r\n## D\r\n\r\n- [debugger-for-chrome](https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome) :star:  \r\n  크롬 개발자 도구에서 디버깅하던 것을 VSCode 에서 할 수 있게 된다. VSCode 에서 브레이킹 포인트를 걸고 또 크롬의 개발자 도구에서는 엘리먼트를 확인하는 등의 방법이 가능하기도 하고 여러 도움이 된다.\r\n\r\n- [DotENV](https://marketplace.visualstudio.com/items?itemName=mikestead.dotenv)  \r\n  .env 파일의 syntax highlighting 기능을 한다.\r\n\r\n## E\r\n\r\n- [ES7 React/Redux/GraphQL/React-Native snippets](https://marketplace.visualstudio.com/items?itemName=dsznajder.es7-react-js-snippets)  \r\n  React Snippets\r\n\r\n- [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)  \r\n  설명이 필요없는 필수 Linter.\r\n\r\n## G\r\n\r\n- [gitignore](https://marketplace.visualstudio.com/items?itemName=codezombiech.gitignore)  \r\n  `.gitignore` 파일을 프로젝트 환경에 맞게 자동으로 생성해준다. 또한 작업중인 파일을 바로 `.gitignore`에 추가할 수 있다.\r\n\r\n- ~~[Git History](https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory)~~  \r\n  현재는 따로 GitKraken App을 사용하고 있기에 해당 앱은 사용중이지 않다.  \r\n  ~~Git 로그를 시각적으로 보기 좋은 확장이다. 로그 보기뿐만 아니라 다양한 기능을 제공한다. 주로 로그를 보기 위해 사용하고 Git 에 관한 다양한 기능은 아래에서 소개할 GitLens 에서 주로 사용한다. 팁으로 본인의 경우 메뉴바에 GitLens 와 Git History 의 아이콘이 비슷한게 있어 햇갈려 Git History 의 설정에서 메뉴바 아이콘을 숨기고 명령 팔레트를 통해서만 사용한다.~~\r\n\r\n- [GitLens](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens) :star:  \r\n  Git 을 사용함에 있어서 시각적이고 고급화된 기능을 제공한다. 워낙 다양한 기능을 제공하기에 위 링크에서 확인해보길 바란다.\r\n\r\n## I\r\n\r\n- [IntelliSense for CSS class names in HTML](https://marketplace.visualstudio.com/items?itemName=Zignd.html-css-class-completion)  \r\n  현재 작업중인 HTML 파일 또는 연결된 파일에서 class 를 참조하여 자동으로 css class 자동완성을 추천해준다.\r\n\r\n- [indent-rainbow](https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow)  \r\n  코드 들여쓰기 단계에 따라서 들여쓰기 공간 색을 다르게 하여 한결 코드 읽기를 좋게 해준다.\r\n\r\n- [Import Cost](https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost)  \r\n  import/require 대상 패키지의 용량이 코드 옆에 표시된다.\r\n\r\n## N\r\n\r\n- [npm](https://marketplace.visualstudio.com/items?itemName=eg2.vscode-npm-script)  \r\n  `package.json`파일을 확인하여 설치된 패키지들의 유효성 검사를 해준다. 파일 내에 종속성이 선언되어있지만 설치되어있지 않다던가 선언되었는데 사용되어지지 않는 등의 확인을 해준다.\r\n\r\n- [npm intellisense](https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense) :star:  \r\n  npm module 을 import 코드를 작성할 때 설치된 모듈을 기준으로 자동완성을 제공해준다.\r\n\r\n## P\r\n\r\n- [Path Intellisense](https://gist.github.com/junhobaik/439c68e2f969c86b06bf8a030172e300) :star:  \r\n  코드 작성시 Path 를 작성할 때 현재 경로를 인식하고 자동완성을 추천해준다. 예를들면 `./`까지 타이핑하면 현재 폴더내의 파일 및 폴더를 자동완성해준다.\r\n\r\n- [PostCSS Sorting](https://marketplace.visualstudio.com/items?itemName=mrmlnc.vscode-postcss-sorting)  \r\n  CSS 속성 순서 정렬 기능. CSS/PostCSS/Less/SCSS 를 지원하며 우선되는 순서를 지정할 수도 있다.\r\n\r\n- [Prettier - Code formatter](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode) :star:\r\n  코드 포맷터\r\n\r\n## R\r\n\r\n- [Relative Path](https://marketplace.visualstudio.com/items?itemName=jakob101.RelativePath)  \r\n  프로젝트의 전체 파일 중 원하는 파일을 검색해 선택하면 작업중인 파일에서 상대 경로로 입력해준다.\r\n\r\n## S\r\n\r\n- [Settings Sync](https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync)  \r\n  VSCode 설정(확장 플러그인 포함) 동기화 도구\r\n\r\n## T\r\n\r\n- [TODO Highlight](https://marketplace.visualstudio.com/items?itemName=wayou.vscode-todo-highlight)  \r\n  주석으로 TODO: FIXME: 구문을 작성시 하이라이트해준다.\r\n\r\n## W\r\n\r\n- [WakaTime](https://marketplace.visualstudio.com/items?itemName=WakaTime.vscode-wakatime)  \r\n  VSCode 에서 어느 프로젝트를 얼마나 작업했는지, 어느 언어로 작성했는지, 그에 대한 비율 시간을 측정해준다.  \r\n  따로 [App 설치](https://wakatime.com/)가 필요하며 VSCode 플러그인에 API key 를 입력해 연동한다. VSCode 말고도 다양한 곳에 연동이 가능하다.\r\n\r\n## 관심있는, 앞으로 설치할 예정인 확장 목록\r\n\r\n- [Vetur](https://marketplace.visualstudio.com/items?itemName=octref.vetur)\r\n- [htmltagwrap](https://marketplace.visualstudio.com/items?itemName=bradgashler.htmltagwrap)\r\n- [REST Client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client)\r\n- [Visual Studio Live Share](https://visualstudio.microsoft.com/ko/services/live-share/)\r\n- [LintLens — ESLint rules made easier](https://marketplace.visualstudio.com/items?itemName=ghmcadams.lintlens)\r\n- [Quokka.js](https://marketplace.visualstudio.com/items?itemName=WallabyJs.quokka-vscode)\r\n- [Visual Studio IntelliCode - Preview](https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode)\r\n\r\n<br/><br/>\r\n\r\n---\r\n\r\n**추가로 VSCode 사용에 도움이 될 만한 자료들**  \r\n\\- [VS Code Tips and Tricks](https://github.com/Microsoft/vscode-tips-and-tricks?wt.mc_id=DX_881390#extension-recommendations)\r\n","excerpt":"Visual Studio Code 에서 사용중인 확장을 정리해둔 글입니다. Front-End 개발 환경에 맞게 되어있습니다.  는 강력 추천! VSCode 기본 플러그인 및 테마 Korean Language Pack for Visual Studio…","fields":{"slug":"/vsc-plugin-list/"},"frontmatter":{"date":"Jan 19, 2018","title":"사용중인 VSCode(Visual Studio Code) 확장 플러그인 목록","tags":["VSCode"],"update":"Jan 30, 2020"}}},{"node":{"rawMarkdownBody":"\r\n기존 Jekyll을 이용한 블로그는 현재(2018.09) Gatsby를 이용한 블로그로 개편되었습니다.  \r\n\r\n**[\"Gatsby를 이용한 블로그 만들기\"](https://junhobaik.github.io/create-gatsby-blog/) 바로가기**\r\n\r\nJekyll의 minimal-mistakes테마를 이용한 블로그를 만들고 싶다면 아래 게시물은 아직 유효합니다.\r\n\r\n---\r\n\r\njekyll 블로그를 시작하기 위한 준비를 저번 포스트에서 끝냈다.  \r\n이제 테마를 적용하고자 여러 테마를 찾던중 정말 괜찮은 테마를 발견했고 그것을 적용하는 과정을 포스팅하려고 한다.\r\n\r\n테마의 이름은 'Minimal Mistakes'로 github star와 fork를 보아 인기있는 테마인듯 싶다.  \r\n심플한 디자인과 가독성이 맘에 들었고 무엇보다 문서가 너무나 잘 정리되있다는 점에 있어서 선택하게 되었다.\r\n\r\n### Minimal Mistakes\r\n- [Official & Demo Page](https://mmistakes.github.io/minimal-mistakes)\r\n- [Github](https://github.com/mmistakes/minimal-mistakes)\r\n\r\n\r\n## 테마 적용하기\r\n우선 기존 포스트에서 jekyll 설치를 다뤘는데, 그로인해 기본 테마로 적용이 되어있는 상태이다.  \r\n여기서 테마를 적용하는 방법으로는 여러가지가 있다. \r\n\r\n가장 쉬운방법은 테마의 github에서 fork를 하고 리포지토리 이름을 `username.github.io`로 바꾸는 방법이다.\r\n\r\n만약 기존에 해둔 리포지토리를 파괴하지 않는 선에서 테마를 적용하고 싶다면 테마를 다운받아 기존 리포지토리 폴더에 덮어쓰기 하는 방법도 있다.\r\n\r\n여기서는 깔끔하게 비어있는 리포지토리에서 테마를 적용하는 방법을 기술하겠다.\r\n\r\n만약 지금 보고있는 블로그가 맘에 들고 아래 방법보다 더 쉽게 테마 적용하고 싶다면 지금 이 블로그의 GitHub 리포지토리를 Fork해 사용할 수 있도록 방법을 만들어놨으니 포스팅을 참고하면 된다.  \r\n[Jekyll 블로그 테마 ‘쉽게’ 적용하기 (minimal-mistakes)](https://junhobaik.github.io/jekyll-apply-theme-simple)\r\n{: .notice--warning}\r\n\r\n### 테마 다운받아 적용하기\r\n\r\n테마를 다운받으려면 보통 리포지토리를 clone하거나 zip파일로 다운받는 방법이 보통이다.  \r\n아니면 jekyll theme 페이지에서 다운받는 방법이 있다.  \r\n\r\nminimal mistakes 테마를 다운받으려 github 리포지토리를 zip으로 다운받아 시도하였다.  \r\n허나 사이드바 표시등 자잘한 문제가 보여 정식 릴리즈된 파일을 찾아 다운받았다.\r\n\r\n[https://github.com/mmistakes/minimal-mistakes/releases](https://github.com/mmistakes/minimal-mistakes/releases)\r\n\r\n다운받은 폴더의 내용을 프로젝트 폴더(username.github.io)에 옮긴다.  \r\n이 과정에서 아래를 참조해 불필요한 파일을 삭제하도록 한다.\r\n\r\n### 불필요한 파일 삭제\r\n불필요한 파일은 아래와 같다.  \r\n- .editorconfig\r\n- .gitattributes\r\n- .github\r\n- /docs\r\n- /test\r\n- CHANGELOG.md\r\n- minimal-mistakes-jekyll.gemspec\r\n- README.md\r\n- screenshot-layouts.png\r\n- screenshot.png\r\n\r\n### _posts, _draft 폴더 생성\r\n그리고 _posts와 _draft 폴더가 없다면 생성하도록 한다. (최상위 경로)\r\n- _drafts : 포스트 초안이 담기는 곳이다. 배포되지 않고 테스트 환경에서 보기가 가능하다.\r\n- _posts : 배포될 포스트들이 담기는 곳.\r\n\r\n### .gitignore 생성\r\n\r\n다음으로 최상위 경로에 .gitignore 파일이 없다면 생성하고 있다면 아래 내용을 보충하자.  \r\n[Jeklly gitignore list](https://gist.github.com/bradonomics/cf5984b6799da7fdfafd)\r\n\r\n### Gemfile 수정\r\nGemfile을 아래 내용으로 수정한다.\r\n\r\n```yml\r\nsource \"https://rubygems.org\"\r\n\r\ngem \"jekyll\", \"~> 3.5\"\r\ngem \"minimal-mistakes-jekyll\"\r\n```\r\n\r\n아래 명령어를 수행한다.\r\n```\r\n$ bundle\r\n```\r\n\r\n### 테스트, 배포\r\n이제 기본적으로 테마 적용이 완료되었다. 다음으로 개인에 맞춰 커스터마이징 하면 된다.  \r\n그 전에 한번 테스트와 배포를 해보자.\r\n\r\n```\r\njekyll serve\r\n```\r\n위 명령어로 `localhost:4000`에서 로컬로 띄워볼 수 있다.\r\n\r\n이 명령어 뒤에 붙는 옵션으로 유용한 것은\r\n- `--draft` 초안을 같이 표시한다.\r\n- `--livereload` 수정마다 새로고침된다.\r\n\r\n중요한 것은 `_config.yml` 파일을 수정하는 것은 반영되지 않아 다시 명령어를 수행해야 반영 된다.\r\n\r\n다음으로 git comit, push 를 통해 자신의 github page에 올린다.\r\n\r\n예)\r\n```\r\n$ git add .\r\n$ git commit -m 'Apply theme, minimal mistakes'\r\n$ git push\r\n```\r\n\r\n`username.github.io`에 접속해 제대로 반영 되었는지 확인한다.\r\n\r\n## 테마 설정하기\r\n이제 개인에 맞춰 커스터마이징 할 차례이다.  \r\n구체적인 것은 생략하고 기본적으로 수정이 필요한 내용들만 다루겠다.  \r\n\r\n`_config.yml`을 수정하자.\r\n\r\n설정을 수정할때는 `jekyll serve`가 실시간 반영되지 않으니 다시 명령어를 수행해야하는 점을 유의하자.\r\n\r\n### 테마 스킨\r\n```yml\r\nminimal_mistakes_skin : \"defalut\"\r\n```\r\n테마의 전체적인 색상 스킨을 정할 수 있다.   \r\n스킨은 아래 링크에서 확인 할 수 있다.  \r\n[Skin list](https://mmistakes.github.io/minimal-mistakes/docs/configuration/#skin)\r\n\r\n### Site Settings\r\n\r\n```yml\r\nlocale                   : \"ko\" # 타깃 국가 설정\r\ntitle                    : \"블로그 제목\" # 블로그 좌측상단의 제목\r\nname                     : \"블로그 이름\"\r\ndescription              : \"블로그 설명\"\r\nurl                      : \"https://username.github.io\" # 블로그 주소\r\nrepository               : \"username/username.github.io\" # 블로그 github 리포지토리\r\nsearch                   : true # 사이트 우측 상단 검색 활성화\r\nsearch_full_content      : # 제목이 아닌 내용까지도 검색할 것인지에 대한 설정 기본 false\r\n```\r\n\r\n### Site Author\r\n사이트 운영자에 대한 정보를 적는다.  \r\n사이드바에 표시되는 사항들이다.\r\n\r\n```yml\r\nauthor:\r\n  name             : \"이름\"\r\n  avatar           : \"/assets/images/bio-photo.jpg\" # 프로필 사진\r\n  bio              : \"이름 아래 나타날 자신의 설명\"\r\n  location         : \"Seoul,Korea\"\r\n  email            : \"a@b.c\"\r\n  uri              : # 웹사이트, 보통 지금 블로그 말고 링크해두고 싶은 사이트를 적는다.\r\n  # 이 아래 쇼셜 리스트에 해당되는 것에 아이디를 적는다\r\n  github : \"username\" # 주소 전체를 적는 것이 아닌 자신의 정보만 적는다.\r\n```\r\n\r\n### Defaults\r\n```yml\r\n# Defaults\r\ndefaults:\r\n  # _posts\r\n  - scope:\r\n      path: \"\"\r\n      type: posts\r\n    values:\r\n      layout: single\r\n      author_profile: true\r\n      read_time: false # 해당 포스트를 읽은 시간이 표시되는데 기본값은 true이다.\r\n      comments: # true\r\n      share: true # 포스트 공유 기능을 활성화 할 것인지 정한다. 기본값은 true이다.\r\n      related: true\r\n```\r\n### 댓글 설정\r\ndisqus를 적용해 보기 위해 우선 disqus에서 사이트를 하나 추가하고 `short-name`을 알아둔다\r\n\r\n아래 코드를 보고 `_config.yml`의 설정을 수정한다\r\n\r\n```yml\r\ncomments:\r\n  provider               : \"disqus\"\r\n  disqus:\r\n    shortname            : dev-hundred-blog # Short-name\r\n\r\ndefaults:\r\n  # _posts\r\n  - scope:\r\n      path: \"\"\r\n      type: posts\r\n    values:\r\n      layout: single\r\n      author_profile: true\r\n      read_time: false\r\n      comments: true # 댓글 활성화\r\n      share: true\r\n      related: true\r\n```\r\n\r\n\r\n## Navigation 설정\r\n헤더 부분에 표시될 네비게이션 메뉴 설정을 하겠다.  \r\n주로 많이 사용하는 메뉴들로 기본 설정을 해보겠다.  \r\n- Archive\r\n- Tag\r\n- Category\r\n\r\n기본적으로 `_data/navigation.yml`에서 네비게이션 설정을 할 수 있다.  \r\n예로 Archive라는 메뉴 하나가 네비게이션에 있다고 하면 아래와 같다.\r\n\r\n```yml\r\nmain:\r\n  - title: \"Archive\"\r\n    url: /year-archive/\r\n```\r\n\r\nurl은 `_pages`폴더안에 있는 페이지의 permalink와 연결된다.\r\n\r\n`_pages/year-archive.html`\r\n```yml\r\n---\r\nlayout: archive\r\npermalink: /year-archive/\r\ntitle: \"Posts by Year\"\r\nauthor_profile: true\r\n---\r\n# ... Code Here ...\r\n```\r\n\r\n이제 실제로 적용을 해보도록 하자.\r\n기본적인 양식은 [minimal mistakes의 github의 예제](https://github.com/mmistakes/minimal-mistakes/tree/master/docs) 양식을 가져왔다.\r\n\r\n`_data/navigation.yml`\r\n```yml\r\nmain:\r\n  - title: \"Archive\"\r\n    url: /year-archive/\r\n  - title: \"tag\"\r\n    url: /tags/\r\n  - title: \"Category\"\r\n    url: /categories/\r\n```\r\n\r\n`_pages/year-archive.html`\r\n\r\n```liquid\r\n---\r\nlayout: archive\r\npermalink: /year-archive/\r\ntitle: \"Posts by Year\"\r\nauthor_profile: true\r\n---\r\n{% assign postsByYear = site.posts | group_by_exp:\"post\", \"post.date | date: '%Y'\"  %}\r\n{% for year in postsByYear %}\r\n  <h2 id=\"{{ year.name | slugify }}\" class=\"archive__subtitle\">{{ year.name }}</h2>\r\n  {% for post in year.items %}\r\n    {% include archive-single.html %}\r\n  {% endfor %}\r\n{% endfor %}\r\n```\r\n\r\n\r\n`_pages/tag-archive.html`  \r\n\r\n태그 부분은 기본 양식에서 살짝 수정했다.\r\n\r\n```liquid\r\n---\r\nlayout: archive\r\npermalink: /tags/\r\ntitle: \"Posts by Tag\"\r\nauthor_profile: true\r\n---\r\n{% include group-by-array collection=site.posts field=\"tags\" %}\r\n<ul>\r\n  {% for tag in site.tags %}\r\n    <span>\r\n      <a href=\"#{{ tag | first }}\">\r\n        {{ tag | first }}\r\n      </a> &nbsp;&nbsp;&nbsp;\r\n    </span>\r\n  {% endfor %}\r\n</ul>\r\n<br/>\r\n<br/>\r\n{% for tag in group_names %}\r\n  {% assign posts = group_items[forloop.index0] %}\r\n  <h2 id=\"{{ tag | slugify }}\" class=\"archive__subtitle\">{{ tag }}</h2>\r\n  {% for post in posts %}\r\n    {% include archive-single.html %}\r\n  {% endfor %}\r\n{% endfor %}\r\n```\r\n\r\n`_pages/category-archive.html`\r\n\r\n```liquid\r\n---\r\nlayout: archive\r\npermalink: /categories/\r\ntitle: \"Posts by Category\"\r\nauthor_profile: true\r\n---\r\n{% include group-by-array collection=site.posts field=\"categories\" %}\r\n{% for category in group_names %}\r\n  {% assign posts = group_items[forloop.index0] %}\r\n  <h2 id=\"{{ category | slugify }}\" class=\"archive__subtitle\">{{ category }}</h2>\r\n  {% for post in posts %}\r\n    {% include archive-single.html %}\r\n  {% endfor %}\r\n{% endfor %}\r\n```\r\n\r\n---\r\n\r\n이제 어느정도 블로그를 운영할 수 있게 된 것 같다.  \r\n허나 아직 세부적으로 코드 수정을 통해 커스터마이징 할 것들이 보인다.  \r\n\r\n이번 포스팅은 여기까지 하고 차후에 SEO 관련 포스팅을 할 생각이다.\r\n\r\n---\r\n\r\n### References\r\n- [Minimal Mistakes Quick-Start Guide](https://mmistakes.github.io/minimal-mistakes/docs/quick-start-guide/)\r\n","excerpt":"기존 Jekyll을 이용한 블로그는 현재(2018.09) Gatsby를 이용한 블로그로 개편되었습니다.   \"Gatsby를 이용한 블로그 만들기\" 바로가기 Jekyll의 minimal-mistakes…","fields":{"slug":"/jekyll-apply-theme/"},"frontmatter":{"date":"Jan 14, 2018","title":"Jekyll 블로그 테마 적용하기 (minimal-mistakes)","tags":["blog","jekyll"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n참고: 지금 계신 블로그는 기존 Jekyll을 이용한 블로그에서 현재(2018.09) Gatsby를 이용한 블로그로 개편되었습니다.  \r\n\r\n---\r\n\r\n원래는 Hexo 블로그 프레임워크를 사용하여 블로그를 시작하려했었다.  \r\nHexo를 사용하려던 이유는 Node.js 기반의 코드로 아는 분야이므로 코드 수정에 있어 이점이 있을거라고 생각한 이유가 컸다. 하지만 여러 테마를 둘러보고 커스터마이징 함에 있어 중국어라는 난관에 부딪쳤다. 제작사가 대만쪽이며 테마 제작자들도 대부분이 중국어권이라 문서를 보는데 큰 어려움이 있었다.\r\n\r\n차선책으로 jekyll 블로그 프레임워크를 사용해보기로 했다.  \r\n기본적으로 GitHub에서 지원하기 때문에 신뢰성이 높았고 Hexo보다는 대중적이라 생각되어 선택하였다.\r\n\r\n아래는 jekyll 블로그를 시작하기위해 고군분투(?)한 내용이다.\r\n\r\n## Ruby 설정\r\n\r\nRuby 설정 전에 `$ sudo gem install jekyll bundler` 명령어로 jekyll 설치가 정상적으로 진행되었다면 Ruby 설정은 넘어가도 된다\r\n{: .notice--info}\r\n\r\n우선 사용해보지 않은 Ruby를 사용하기 위해 설정에 들어갔다.\r\n\r\nMacOS에서는 기본적으로 Ruby를 지원하지만, 그냥 사용하여 Jeklly를 설치하려했더니 권한 문제등 에러가 많아 Ruby 버전 매니저인 RVM을 통해 새로운 Ruby 설치 및 설정을 해보았다.\r\n\r\n해야할 과정들을 요약하면 아래와 같다  \r\n1. RVM 설치   \r\n`$ \\curl -sSL https://get.rvm.io | bash -s stable` \r\n2. Ruby 설치  \r\n`$ rvm install 2.5.0` \r\n3. 설치된 버전 기본 사용 설정  \r\n`$ rvm --default use 2.5.0`\r\n\r\n하지만 이 과정 중 생각보다 오류가 많이 발생했다.  \r\n이 아래는 오류를 겪는 과정과 해결 과정이다.\r\n\r\n### RVM, Ruby 설치\r\n\r\n```\r\n$ \\curl -sSL https://get.rvm.io | bash -s stable\r\n```\r\n\r\n위 명령어를 통해 RVM을 설치하였다.  \r\n다음으로는 rvm을 통해 버전 2.5.0의 Ruby 설치를 시도하였다.\r\n\r\n```\r\n$ rvm install 2.5.0\r\n```\r\n\r\n허나 `command not found: rvm` 오류 발생, rvm이 설치가 잘못된 것일까\r\n구글링을 통해 해결 방법을 알아내었고 아래와 같다.\r\n\r\n```\r\n$ source ~/.rvm/scripts/rvm\r\n$ type rvm | head -n 1\r\n\"rvm ~ function ~\" 이와 비슷한 출력시 완료\r\n```\r\n\r\n이제 다시 다시 루비 설치를 시도하였다.\r\n\r\n```\r\n$ rvm install 2.5.0\r\n```\r\n\r\n그러나 아래와 같은 오류 발생, 일단 위의 오류는 해결한 것이고 다른 오류가 발생한 것이다.\r\n\r\n```\r\nError running 'requirements_osx_brew_libs_install autoconf automake libtool pkg-config coreutils libksba openssl@1.1',\r\nplease read /Users/junhobaik/.rvm/log/1515943113_ruby-2.5.0/package_install_autoconf_automake_libtool_pkg-config_coreutils_libksba_openssl@1.1.log\r\nRequirements installation failed with status: 1.\r\n```\r\n해결을 위해 아래 명령어 입력\r\n\r\n```\r\n$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\r\n```\r\n\r\n위 명령어의 설치 작업으로 다소 시간이 소요되었고 다시 루비 설치를 시도하였다.\r\n\r\n```\r\n$ rvm install 2.5.0\r\n```\r\n\r\n드디어 설치 성공, 그리고 아래 명령어를 통해 설치된 버전을 기본 사용 설정을 해둔다.\r\n\r\n```\r\n$ rvm --default use 2.5.0\r\n```\r\n\r\n<br/>\r\n\r\n## Jekyll 설치\r\n\r\n`$ sudo gem install jekyll bundler`\r\n\r\n위의 명령어를 통해 `jekyll`와 `bundler`를 설치한다.\r\n\r\n이로써 설치 작업은 끝났다.\r\n\r\n\r\n## Github Page와 연동\r\n\r\n우선 Github Page를 사용하여 배포하기 위해 미리 `username.github.io` 리포지토리를 준비해두었고, 빈 리포지토리를 로컬에 git clone 해두었다.\r\n\r\n```\r\n$ jekyll new username.github.io\r\n```\r\n\r\n위 명령어를 통해 jekyll init이 되었고 이제 블로그를 시작할 수 있는 상태가 되었다.\r\n\r\n또한 아래 명령어를 통해 로컬에서 테스트가 가능하다.\r\n\r\n```\r\njekyll serve\r\n```\r\n\r\n다음 포스트에서는 테마 적용을 해보려 한다.\r\n","excerpt":"참고: 지금 계신 블로그는 기존 Jekyll을 이용한 블로그에서 현재(2018.09) Gatsby를 이용한 블로그로 개편되었습니다.   원래는 Hexo 블로그 프레임워크를 사용하여 블로그를 시작하려했었다. Hexo를 사용하려던 이유는 Node.js…","fields":{"slug":"/start-jekyll-blog/"},"frontmatter":{"date":"Jan 14, 2018","title":"Jekyll 블로그 시작하기 (MacOS, GitHub Page)","tags":["jekyll","blog","ruby"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n자바스크립트에서 함수선언문과 함수표현식의 차이점을 인식해두는 것은 중요한 점이다.\r\n큰 차이점이라 하면 호이스팅(Hoisting)이라고 할 수 있다.\r\n\r\n우선 함수선언문과 같은 경우를 살펴보자.\r\n\r\n```javascript\r\nfunctionDeclaration();\r\nfunction functionDeclaration(){\r\n  return 'functionDeclaration';\r\n}\r\n```\r\n\r\n```javascript\r\n'functionDeclaration'\r\n```\r\n\r\n함수 선언문의 경우에는 호이스팅에 의해 함수 전체가 호이스팅의 대상이 된다.\r\n따라서 작성한 코드에서 함수 선언문 보다 위에 함수 호출이 있더라도 정상적으로 호출이 된다.\r\n\r\n다음으로 함수표현식의 경우를 살펴보자\r\n\r\n```javascript\r\nunnamedFunctionExpression();\r\nvar unnamedFunctionExpression = function(){\r\n  return 'unnamedFunctionExpression';\r\n}\r\n```\r\n\r\n```\r\nUncaught TypeError: unnamedFunctionExpression is not a function\r\n```\r\n\r\n결과는 unnamedFunctionExpression 변수가 함수가 아니라는 오류가 뜨게 된다.\r\n변수 선언 자체는 호이스팅되었지만 할당은 호이스팅의 대상이 아니므로 할당된 값이 없는 변수를 함수라 여기고 함수 호출을 한 샘이니 이러한 오류가 발생한 것이다.\r\n\r\n즉, 함수 선언문과 함수 표현식의 차이는 호이스팅 여부를 가름짓는 **할당**에 있다고 할 수 있다.\r\n\r\n함수선언문을 사용해서 나타날 수 있는 문제점을 아래 코드에 나타냈다.\r\n\r\n```javascript\r\nfunction a(){\r\n  return 'a';\r\n}\r\na();\r\nfunction a(){\r\n  return 'A';\r\n}\r\na();\r\n```\r\n\r\n위의 코드는 a A 를 원하지만 A A가 나오게 된 문제가 생긴 코드 라인이 방대한 프로젝트의 경우 위와같은 커뮤니케이션 오류에 따라 원하는 함수의 결과를 얻지 못할 수 있다.\r\n\r\n이러한 점들을 종합해 함수선언문의 사용보다는 함수표현식의 사용이 권장된다.  \r\n유명한 더글라스 크락포드 그리고 Airbnb의 Code Convension에서도 함수표현식을 권장하고 있다.\r\n\r\n## Reference\r\n\r\n- [KENDRICK'S BLOG](http://blog.sonim1.com/142)\r\n- [CAPTAIN PANGYO](https://joshua1988.github.io/web-development/javascript/function-expressions-vs-declarations/#%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8%EC%8B%9D---function-declarations)\r\n","excerpt":"자바스크립트에서 함수선언문과 함수표현식의 차이점을 인식해두는 것은 중요한 점이다.\n큰 차이점이라 하면 호이스팅(Hoisting…","fields":{"slug":"/js-functions/"},"frontmatter":{"date":"Jan 02, 2018","title":"Javascript 함수선언문과 함수표현식","tags":["javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nHoist는 \"끌어올리다\"라는 뜻을 가지고 있다.  \r\n자바스크립트 엔진은 코드를 실행하기 전에 코드 전체를 살펴본다.  \r\n이 과정에서 선언된 내용이 있는지 '선언'을 살펴본다.  \r\n그리고 그 '선언'된 내용들을 모두 호이스팅. 즉, 끌어올리게 된다.  \r\n\r\n아래 코드를 보자.\r\n\r\n\r\n```javascript\r\nconsole.log(a());\r\nconsole.log(b);\r\nconsole.log(c());\r\nfunction a() {\r\n  return 'a';\r\n}\r\nvar b = 'b';\r\nvar c = function(){\r\n  return 'c';\r\n}\r\n```\r\n\r\n일반적인 생각으로 코드가 라인 순서대로 실행된다면, \r\n1번 라인에서부터 함수 a가 선언되기 전이므로 a가 없어 오류가 발생해야한다.\r\n하지만 위에서 설명한 호이스팅에 따라서 결론적으로 실행되는 코드는 아래와 같게 된다.\r\n\r\n```javascript\r\nfunction a() {\r\n  return 'a';\r\n}\r\nvar b;\r\nvar c;\r\nconsole.log(a());\r\nconsole.log(b);\r\nconsole.log(c());\r\nb = 'b';\r\nc = function(){\r\n  return 'c';\r\n}\r\n```\r\n\r\n**함수 선언문 a는 통째로 끌어올려졌다.**\r\n기본 값이 담긴 변수 b와 함수 표현식 c는 선언만 끌어올려졌다.\r\n할당은 호이스팅의 해당 사항이 아니다.\r\nb와 c는 선언과 할당이 동시에 이루어진 것으로 분리되어 선언만 호이스팅 된 것이다.\r\n\r\n따라서 위의 코드에서는 에러가 하나 발생하게 된다.\r\n\r\n```javascript\r\na\r\nundefined\r\nUncaught TypeError: c is not a function\r\n```\r\n\r\n`console.log(a())`는 정상적으로 출력되어 'a'가 출력되었고,\r\n`console.log(b)`는 `var b`의 선언만이 호이스팅 되었으므로 undefined가 출력,\r\n`console.log(c())`는 `var c`의 선언만이 있고 함수 호출을 하였으므로 함수가 아니라는 오류가 발생하게 된다.","excerpt":"Hoist…","fields":{"slug":"/js-hoisting/"},"frontmatter":{"date":"Dec 30, 2017","title":"자바스크립트 호이스팅(Hoisting)","tags":["javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n`git log --oneline --graph` 처럼 명령어를 입력하면 Log를 보기 좋게 출력할 수 있는데,  \r\n매번 이 명령어를 치기도 곤혹이다. \r\n\r\nLinux의 alias를 이용하여 특정 명령어를 별도의 키워드로 지정하여 간단하게 사용할 수 있는다.\r\n\r\n```\r\n$ git config --global alias.[키워드] [명령어]\r\n```\r\n\r\n\r\n\r\n예로 `git log --oneline --graph`를 `git logs`로 간단히 사용하려면 아래와 같은 명령어를 사용한다.\r\n\r\n```\r\n$ git config --global alias.logs 'log --oneline --graph'\r\n```\r\n\r\n그 결과 아래와 같이 되었다.\r\n\r\n```\r\n$ git logs\r\n*   73a81d6 Merge branch 'dev'\r\n|\\\r\n| * 6f75a02 Add memo features\r\n| * b4de8c5 Modify bookmark localstorage name\r\n| * 7fa5424 Modify styles\r\n| * 86a5634 Add memo.js, add mvc layout\r\n| * 3688670 Add memo script\r\n| * 76e1478 Modify namespace name\r\n| * bd6dbdd Add bookmark title\r\n| * 4fbe5fb Add memo layout\r\n* | 78addaa Update README.md\r\n|/\r\n* 328f641 Fix bookmark add bug\r\n*   eb32dbc Merge branch 'dev'\r\n|\\\r\n| * 84b0d77 Modify bookmark modal style\r\n| * 4fc5a5c Modify bookmark bug fix\r\n| * 5ac2c33 Modify bookmark modal message\r\n| * 0a08125 Modify bookmark modal style\r\n| * 9d88539 Modify bookmark.js, Remove Unused property\r\n| * 34a6dd1 Refactoring bookmark.js\r\n| * 57cdfc5 Add .gitignore\r\n| * 1d1145b Modify bookmark, add drag sorting feature\r\n| * 2b13a6a Add jQuery-ui\r\n| * ebc5f98 Modify bookmark.js\r\n| * a58d2ff Modift bookmark, add modify function\r\n| * f0c1224 Modify Styles\r\n| * 4cf5a2a Modify index.html, cdn -> local\r\n| * c7d3110 Add Bootstrap local file\r\n```\r\n","excerpt":"처럼 명령어를 입력하면 Log를 보기 좋게 출력할 수 있는데, 매번 이 명령어를 치기도 곤혹이다.  Linux의 alias…","fields":{"slug":"/git-alias/"},"frontmatter":{"date":"Dec 30, 2017","title":"Git, Alias(별칭)를 이용하여 편리하게 명령어 사용하기","tags":["git"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n## 환경\r\n\r\n- Create-react-app (CRA)\r\n- SCSS 로 적용\r\n\r\n\r\n\r\n\r\n## 적용법\r\n\r\n### react 설정 eject & sass 패키지 설치\r\n\r\n1. `$ npm run eject` 를 실행한다.\r\n   해당 명령어는 `node_modules/react-scripts`에 위치하던 환경설정을 프로젝트 루트 경로로 이동시켜 상세한 환경설정이 가능하도록 한다.\r\n2. `npm install --save node-sass sass-loader`  두개의 패키지를 설치한다.\r\n   - node-sass : sass 코드를 css 코드로 변환\r\n   - sass-loader : webpack에서 sass 파일을 읽는 역할.\r\n\r\n\r\n### 코드 수정\r\n\r\n#### `config/webpack.config.dev.js` \r\n\r\nfile-loader 키워드를 찾아 아래 코드에서 exclude 배열에 ` /\\.scss$/`를 추가해준다.\r\n\r\n```javascript\r\n{\r\n  // exclude: [/\\.js$/, /\\.html$/, /\\.json$/] \r\n  exclude: [/\\.js$/, /\\.html$/, /\\.json$/, /\\.scss$/],\r\n    loader: require.resolve('file-loader'),\r\n      options: {\r\n        name: 'static/media/[name].[hash:8].[ext]',\r\n      },\r\n},\r\n```\r\n\r\n`test: /\\.css$/` 키워드를 찾아 아래 코드를 수정한다.\r\n\r\n- `test: /\\.css$/`를 `test: /\\.scss$/`로 수정한다.\r\n- postcss-loader 로더 아래 sass-loader 로더 코드를 추가한다\r\n\r\n\r\n```javascript\r\nmodule : {\r\n  //...\r\n    {\r\n      // test: /\\.css$/,\r\n      test: /\\.scss$/,\r\n        use: [\r\n          require.resolve('style-loader'),\r\n          {\r\n            loader: require.resolve('css-loader'),\r\n            options: {\r\n              importLoaders: 1,\r\n            },\r\n          },\r\n          {\r\n            loader: require.resolve('postcss-loader'),\r\n            options: {\r\n              ident: 'postcss',\r\n              plugins: () => [\r\n                require('postcss-flexbugs-fixes'),\r\n                autoprefixer({\r\n                  browsers: [\r\n                    '>1%',\r\n                    'last 4 versions',\r\n                    'Firefox ESR',\r\n                    'not ie < 9',\r\n                  ],\r\n                  flexbox: 'no-2009',\r\n                }),\r\n              ],\r\n            },\r\n          },\r\n          // 아래 4줄 코드 추가\r\n          {\r\n            loader: require.resolve('sass-loader'),\r\n            options: {}\r\n          }\r\n          // \r\n        ],\r\n    },\r\n    /...\r\n}\r\n```\r\n\r\n\r\n\r\n#### `config/webpack.config.prod.js` \r\n\r\n위 dev 설정 파일과 비슷하게 수정한다.\r\n\r\n- file-loader 키워드를 찾아 아래 코드에서 exclude 배열에 ` /\\.scss$/`를 추가해준다.\r\n- `test: /\\.css$/` 키워드를 찾아 코드를 수정한다.\r\n  - `test: /\\.css$/`를 `test: /\\.scss$/`로 수정한다.\r\n  - postcss-loader 로더 아래 sass-loader 로더 코드를 추가한다\r\n\r\n\r\n\r\n## 사용\r\n\r\n기존의 css 파일을 scss로 확장자 변경하여 사용할 수 있다.\r\n\r\n또한 설정 변경 전 `npm start`가 실행중이었다면 새로 시작해주어야한다.\r\n\r\n\r\n\r\n[SASS Documentation (Ko)](https://sass-guidelin.es/ko/)\r\n\r\n[SASS Official Site](http://sass-lang.com/)\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n## Reference\r\n\r\n[리액트 컴포넌트 스타일링 – CSS Module / Sass / styled-components](https://velopert.com/3447)","excerpt":"환경 Create-react-app (CRA) SCSS 로 적용 적용법 react 설정 eject & sass…","fields":{"slug":"/js-react-apply-sass/"},"frontmatter":{"date":"Nov 08, 2017","title":"React 프로젝트에 SASS 적용하기","tags":["react","javascript","sass"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n### Cookie\r\n\r\n클라이언트(브라우저)에 데이터를 저장한다.  \r\n`setCookie(Key_String, Value_String)`  \r\n`$_COOKIE`\r\n\r\n```php\r\n<?php\r\n  setCookie('user', 'baik');\r\n  echo $_COOKIE['user']; // baik\r\n?>\r\n```\r\n\r\n#### 위 코드의 문제점\r\n\r\n위 코드가 HTML 코드 안에 포함되어있다면 \r\n\r\n`Warning: Cannot modify header information ...`\r\n\r\n위와 같은 Warning을 만나게 되는데 HTML 코드 바깥으로 setCookie() 를 옮기면 해결할 수 있다 자세한 내용은 [링크](https://stackoverflow.com/questions/2658083/setcookie-cannot-modify-header-information-headers-already-sent) 참고.\r\n\r\n이 경고는 session에서도 동일하게 발생한다.\r\n\r\n### Session\r\n\r\nSessionID(SID)를 식별자로 서버에 데이터를 저장\r\n\r\nSID로는 쿠키나 도메인 파라미터를 사용\r\n\r\n`session_start();`로 시작, 스크립트의 최상단에 위치해야함\r\n\r\n`$_SESSION`\r\n\r\n데이터는 서버 내에 파일이나 DB에 저장\r\n\r\n주로 사용자 인증시에 사용함\r\n\r\n```php\r\n<?php\r\nsession_save_path('./session');\r\nsession_start();\r\n$_SESSION['name'] = 'baik';\r\necho $_SESSION['name'];\r\n?>\r\n```\r\n\r\n#### 간단한 로그인 예제\r\n\r\n- login.html\r\n\r\n```html\r\n<html>\r\n  <head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" >\r\n  </head>\r\n  <body>\r\n    <form action=\"login_process.php\" method=\"POST\">\r\n      <p><label>아이디</label><input type=\"text\" name=\"id\" /></p>\r\n      <p><label>비밀번호</label><input type=\"text\" name=\"pwd\" /></p>\r\n\r\n      <input type=\"submit\" />\r\n    </form>\r\n  </body>\r\n</html>\r\n```\r\n\r\n- login_process.php\r\n\r\n```php\r\n<?php\r\nsession_start();\r\n$id = 'id';\r\n$pwd = 'pw';\r\nif(!empty($_POST['id']) && !empty($_POST['pwd'])){\r\n    if($_POST['id'] == $id && $_POST['pwd'] == $pwd){\r\n        $_SESSION['is_login'] = true;\r\n        $_SESSION['nickname'] = 'nick';\r\n        header('Location: ./session.php'); //redirection\r\n        exit;\r\n    }\r\n}\r\necho '로그인 하지 못했습니다.';\r\n?>\r\n```\r\n\r\n- session.php\r\n\r\n```php\r\n<?php\r\nsession_start();\r\nif(!isset($_SESSION['is_login'])){\r\n    header('Location: ./login.html');\r\n}\r\n?>\r\n    <html>\r\n\r\n    <head>\r\n        <meta charset=\"UTF-8\">\r\n    </head>\r\n\r\n    <body>\r\n        <?php echo $_SESSION['nickname'];?>님 환영합니다\r\n        <br />\r\n        <a href=\"./logout.php\">로그아웃</a>\r\n    </body>\r\n\r\n    </html>\r\n```\r\n\r\n- logout.php\r\n\r\n```php\r\n<?php\r\nini_set(\"display_errors\", \"1\");\r\nsession_start();\r\nsession_destroy();\r\nheader('Location: ./login.html');\r\n?>\r\n```\r\n\r\n## Reference\r\n\r\n- [생활코딩 PHP 기본 강의](https://opentutorials.org/module/6)\r\n","excerpt":"Cookie 클라이언트(브라우저)에 데이터를 저장한다.   위 코드의 문제점 위 코드가 HTML 코드 안에 포함되어있다면   위와 같은 Warning을 만나게 되는데 HTML 코드 바깥으로 setCookie…","fields":{"slug":"/php-cookie-session/"},"frontmatter":{"date":"Nov 06, 2017","title":"PHP Cookie, Session","tags":["php"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n타 언어를 사용하다가(파이썬 제외...) 자바스크립트를 처음 접한 사람에게는 세미콜론을 쓰지 않고도 오류가 나지 않는 것을 보고 꽤나 놀랐을 것이다.\r\n\r\n\r\n\r\n\"자바스크립트에서는 세미콜론을 쓰지 않아도 오류가 나지 않는데 그렇다면 세미콜론을 쓰지 않고 짧게 작성하는게 좋지\" 라는 사람도 있다.\r\n\r\n어느쪽이 바람직 한 것일까...?\r\n\r\n\r\n\r\n우선 자바스크립트에서 세미콜론(;)을 쓰지 않아도 오류가 나지 않는 이유는  \r\n**ASI (Automatic Semicolon Insertion)**라는 것 때문이다.\r\n\r\n이것을 통해 엔진이 자동으로 ; 을 삽입해 주는 것이다.\r\n\r\n\r\n\r\n중요한 점은 개행, 즉 **새 줄(Line Break)에만 적용**된다는 점이다.\r\n\r\n\r\n\r\n아래 경우를 보자\r\n\r\n```javascript\r\nvar i = 0;\r\ndo {\r\n    console.log(i);\r\n} while(i===10)\r\ni;\r\n```\r\n\r\ndo-while의 경우 while끝에 ;을 붙여야 문법적으로 맞는데 깜박하더라도 ASI가 ;을 삽입해준다.\r\n\r\n```javascript\r\nfunction foo(){\r\n    if(true) return\r\n    console.log(\"foo\");\r\n}\r\n```\r\n\r\n위의 경우도 return 뒤에 ;을 붙여줄 것이다.  \r\n이 경우에는 console.log가 실행되게 할지 말지 의도한게 어떤 것인지에 따라  \r\n유용하게 된 경우 또는 실수에서 이어진 문제점으로 해석 될 수도 있다.\r\n\r\n\r\n\r\n세미콜론(;)을 쓰지 않더라도 유용한 ASI가 존재함에 따라 대부분은 문제가 없을 것이다.  \r\n그러나 초보 개발자의 실수라던가 또는 의도하지 않은 ;의 삽입으로 곤혹을 겪을 가능성이 어찌되었건 존재한다.\r\n\r\n\r\n\r\n```\r\n\"ASI(Automatic Semicolon Insertion) is an error correction procedure.  \r\nIf you start to code as if it were a universal significant-newline rule,  \r\nyou will get into trouble.\" —Brendan Eich\r\n```\r\n\r\n위는 자바스크립트의 창시자인 브렌던 아이크가 한 말이다.  \r\n여기서 ASI를 에러 정정 프로시저라고 말하며 이것을 보편적인 것처럼 코딩한다면 문제에 당도할 것이라고 말하고 있다.\r\n\r\n\r\n\r\n자바스크립트에서 세미콜론을 쓰는가 마는가는,  \r\n공백은 탭인가 스패이스인가와 같은 논쟁거리가 아니라고 생각한다.  \r\nASI는 에러 정정을 목적으로 만들어졌고, 아무리 적은 가능성이라도 오류가 날 가능성이 있다면,  \r\n글쓴이 본인은 ; 을 쓰는 것이 맞다고 생각한다.","excerpt":"…","fields":{"slug":"/js-semicolon-asi/"},"frontmatter":{"date":"Oct 17, 2017","title":"자바스크립트에서 세미콜론(;)을 안써도 될까?","tags":["javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nJavascript는 Java와 달리 int, double 같은 숫자 타입이 나눠져있지 않다.  \r\nnumber 하나로 정수(Integer)와 부동 소수점 수를 모두 표현한다.\r\n\r\n\r\n\r\n### 숫자 리터럴\r\n\r\n```javascript\r\nvar n = 12 //12\r\nn = 12. //12\r\nn = 12.0 //12\r\nn = 12.300 //12.3\r\nn = 0.12 //0.12\r\nn = .12 //0.12\r\n```\r\n\r\n.12, 12. 과 같은 방식은 틀린 것은 아니더라도 좋은 코드라고 하긴 어려울 것이다.\r\n\r\n\r\n\r\n### Number Methods\r\n\r\n#### - Number.isInteger()\r\n\r\n정수인지 확인할 수 있는 메서드.\r\n\r\n```javascript\r\nvar n = 12;\r\nNumber.isInteger(n); // true\r\nn = .12;\r\nNumber.isInteger(n); // false\r\n```\r\n#### - Number.isSafeInteger()   **/\\*ES6\\*/**\r\n\r\n안전한 정수값인 `-(253 - 1)` 부터 `253 - 1` 사이의 정수 값인지 확인하는 메서드, ES6에서 출현하였다.\r\n\r\n```javascript\r\nNumber.isSafeInteger(100);                    // true\r\nNumber.isSafeInteger(Math.pow(2, 53));      // false\r\nNumber.isSafeInteger(Math.pow(2, 53) - 1);  // true\r\n```\r\n\r\n#### - Number.toFixed()\r\n\r\n인자로 넘긴 수 만큼의 소수점 이하를 반올림하여 문자열 형태로 반환하는 메서드.\r\n\r\n```javascript\r\nvar n = 12.39;\r\nn.toFixed(0); //\"12\"\r\nn.toFixed(1); //\"12.4\"\r\nn.toFixed(2); //\"12.39\"\r\nn.toFixed(3); //\"12.390\"\r\n```\r\n\r\n#### - Number.toPrecision()\r\n\r\n수의 길이를 제한하여 문자열로 반환한다.\r\n\r\n```javascript\r\nvar n = 12.39;\r\nn.toPrecision() //\"12.39\"\r\nn.toPrecision(1) //\"1e+1\"\r\nn.toPrecision(2) //\"12\"\r\nn.toPrecision(3) //\"12.4\"\r\nn.toPrecision(4) //\"12.39\"\r\n```\r\n\r\n#### - Number.toExponential()\r\n\r\n수를 지수표현식 문자열으로 반환한다.\r\n\r\n```javascript\r\nvar n = 10000000000;\r\nn; // 10000000000\r\nn.toExponential(); //\"1e+10\"\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n### 0.5 === 0.2 + 0.3 // false ??\r\n\r\nJava나 타 언어를 배워봤다면 한번은 봤을만한 질문이다. \r\n\r\n0.5와 같은 부동 소수점 수는 결국 프로그래밍 언어에서는 0.5000000001과 같이 0.5와 가까운 수이기 때문이라는 것인데...\r\n\r\nJavascript에서는 어떨까?\r\n\r\n아래는 크롬 브라우저(2017.10 최신버전)의 콘솔창 결과이다.\r\n\r\n```javascript\r\n0.0000005 === 0.0000002 + 0.0000003;\r\ntrue\r\n0.000005 === 0.000002 + 0.000003;\r\nfalse\r\n0.00005 === 0.00002 + 0.00003;\r\ntrue\r\n0.0005 === 0.0002 + 0.0003;\r\ntrue\r\n0.005 === 0.002 + 0.003;\r\ntrue\r\n0.05 === 0.02 + 0.03;\r\ntrue\r\n0.5 === 0.2 + 0.3;\r\ntrue\r\n\r\n0.1 + 0.2 === 0.3\r\nfalse\r\n\r\n1.2 - 1 \r\n0.19999999999999996\r\n1.5 - 0.5\r\n1\r\n```\r\n\r\n모두 true 이길 바라지만 결과는 그렇지 않다. 더 어려운 것은 모두 false도 아니라는 것이다.\r\n\r\n어떤 것은 true이고 어떤 것은 false인 이러한 이유는 아직까지 정확하게 찾지 못했지만 부동 소수점 수의 계산에 있어 조심해야한다는 것을 알 수 있다.\r\n\r\n\r\n\r\n##### 해결 방법\r\n\r\n```javascript\r\n(1.2 - 1).toFixed(1) * 1 // 0.2\r\n(1.1000001 - 1).toFixed(7) * 1 // 0.1000001\r\n```\r\n\r\nNumber의 메서드를 사용하여 위와 같은 방법으로 해결하는 방법도 있다.\r\n\r\n","excerpt":"Javascript는 Java와 달리 int, double 같은 숫자 타입이 나눠져있지 않다. number 하나로 정수(Integer)와 부동 소수점 수를 모두 표현한다. 숫자 리터럴 .12, 1…","fields":{"slug":"/js-number-type/"},"frontmatter":{"date":"Oct 16, 2017","title":"자바스크립트의 숫자 타입(Number Type)","tags":["javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n## Set\r\n\r\n중복없이 유일한 값을 저장하기 위한 타입, 이미 존재하는지 체크할때 유용하다\r\n\r\n```javascript\r\nlet mySet = new Set();\r\nconsole.log(toString.call(mySet)); // [object Set]\r\n\r\nfunction print(set){\r\n  set.forEach(function(value){\r\n    console.log(value); \r\n  });\r\n}\r\n\r\nmySet.add('a');\r\nmySet.add('b');\r\nmySet.add('a'); //저장 안됨\r\n\r\nprint(mySet); // \"a\" \"b\"\r\n\r\nconsole.log(mySet.has('b')); // true\r\n\r\nmySet.delete('a');\r\n\r\nprint(mySet); // \"b\"\r\n```\r\n\r\n\r\n\r\n## WeakSet\r\n\r\n참조를 가지고 있는 객체만 저장이 가능하다.\r\n\r\n참조를 가지고 있던 객체가 참조를 잃게 되면 (null 이 되거나…) 가비지컬렉션의 대상이 된다.\r\n\r\n객체를 중복없이 저장하고 활용하려할때 유용하게 쓰일 수 있다.\r\n\r\n```javascript\r\nlet ws = new WeakSet();\r\nconsole.log(toString.call(ws)); // [object WeakSet]\r\n\r\nlet arr = [1,2,3,4,5];\r\nlet obj = { arr };\r\nlet number = 100;\r\nfunction foo(){}\r\n\r\n//ws.add(100);\r\nws.add(arr);\r\nws.add([1,2,3,4,5]);\r\nws.add(obj);\r\n//ws.add(100);\r\n//ws.add(number);\r\n//ws.add('string')\r\nws.add(foo);\r\nws.add(function a(){});\r\n// 위 주석처리는 모두 에러 발생한 것들\r\n// TypeError: Invalid value used in weak set\r\n\r\n\r\narr = null;\r\nconsole.log(ws.has(arr)); //false\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### map / WeakMap\r\n\r\nmap과 set의 차이는 다루는 타입과, 구조가 다르다.\r\n\r\nmap => object , key/value\r\nset => array\r\n\r\n이러한 차이점 이외에는 사용법은 거의 동일하다, \r\nWeak와 같은 경우에도 참조가 사라지면 가비지컬렉션의 대상이 되는 것도 동일하다.\r\n\r\nmap을 활용하여 따로 부가적인 정보를 저장하는 key/value를 활용할 수 있는 것 정도의 차이점이 있다.\r\n\r\n### \r\n\r\n#### WeakMap 활용\r\n\r\n프라이빗한 변수 만들기.\r\n\r\n```javascript\r\nconst wm = new WeakMap();\r\n\r\nfunction MyInfo(name, age){\r\n  wm.set(this, {name, age});\r\n}\r\n\r\nMyInfo.prototype.getInfo = function(){\r\n  const {name, age} = wm.get(this);\r\n  return 'name:'+name+\"/age:\"+age;\r\n}\r\n\r\nlet myInfo = new MyInfo('baik', 27);\r\n\r\nconsole.log(myInfo.getInfo());\r\n//\"name:baik/age:27\"\r\n\r\nconsole.log(wm.has(myInfo)); //true\r\nmyInfo = null;\r\nconsole.log(wm.has(myInfo)); //false\r\n\r\n//myInfo를 통해서는 name, age 값을 뽑아낼 수 없다, (private)\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n## Reference\r\n\r\n- [모던 자바스크립트(javascript) 개발을 위한 ES6 강좌](https://www.inflearn.com/course/es6-%ea%b0%95%ec%a2%8c-%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8/)\r\n","excerpt":"Set 중복없이 유일한 값을 저장하기 위한 타입, 이미 존재하는지 체크할때 유용하다 WeakSet 참조를 가지고 있는 객체만 저장이 가능하다. 참조를 가지고 있던 객체가 참조를 잃게 되면 (null…","fields":{"slug":"/js-es6-set-map/"},"frontmatter":{"date":"Oct 14, 2017","title":"자바스크립트 ES6 Set, WeakSet / Map, WeakMap","tags":["javascript","ES6"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n## Javascript Variable Types\r\n\r\n\r\n자바스크립트의 변수는 모든 데이터 타입을 수용할 수 있도록 되어있다.\r\n\r\n`typeof` 라는 특정 변수의 데이터 타입을 확인하여 문자열로 반환하는 연산자가 있다.\r\n\r\n\r\n\r\n- **값은 타입을 가진다 / 변수에는 따로 타입이란 없다**\r\n  변수는 언제라도 어떤 형태의 값이라도 가질 수 있다.\r\n  `var a = '123'`\r\n  변수 a는 string 타입이다 (X)\r\n  변수 a의 값으 string 타입이다 (O) //정확한 표현\r\n\r\n  ​\r\n\r\n### Standard defines seven data types\r\n\r\n1. Six data types that are primitives\r\n  1. Boolean\r\n  2. Null\r\n  3. Undefinend\r\n  4. Number\r\n  5. String\r\n  6. Symbol\r\n2. and Object\r\n\r\n\r\n\r\n\r\n… symbol 은 ES6부터 출현한 타입\r\n\r\n… object를 제외한 나머지 타입을 원시 타입(primitives)이라 한다\r\n\r\n\r\n\r\n### typeof results\r\n\r\n\r\n| Type             | 'typeof' Result |\r\n| ---------------- | --------------- |\r\n| number           | number          |\r\n| string           | string          |\r\n| boolean          | boolean         |\r\n| undefined        | undefined       |\r\n| null             | **object**      |\r\n| symbol           | symbol          |\r\n| function object  | function        |\r\n| any other object | object          |\r\n\r\n\r\n\r\n- **typeof null === 'object' //… true ??**\r\n\r\n자바스크립트에서는 null 이 기본형으로 구분되어있다.\r\n하지만 typeof null의 결과로는 null이 반환되지 않고 object가 반환되는 이유는 자바스크립트 개발 당시 다른 언어들과 같이 null이 0값을 가지고 있는 객체로 취급하여 object를 반환하도록 개발되었기 때문이다.\r\nnull값이 기본형이므로 반환값을 null로 바꾸자는 의견도 많으나 이미 object 반환 방식으로 구현된 웹들이 많아 쉽게 바꾸지 못하고 있다.\r\n\r\nnull을 확인하기 위한 방법으로는 (var a = null)\r\n`!a && typeof a === 'object'`\r\n\r\n- **typeof function a(){} // function**\r\n\r\ntypeof가 반환하는 값 중 7가지 타입이 아닌 것이 하나 있는데 그것이 function이다.  function은 object의 하위 타입으로 함수가 객체라서 유용한 점으로는 property를 들 수 있다, a.length로 property의 갯수를 알 수 있다.\r\n\r\n- **배열…?**\r\n\r\ntypeof [1,2,3] // 'object' 이다.\r\n배열도 객체이기 때문이다, 숫자 인덱스를 가지고 length 프로퍼티가 자동으로 관리되는 등 추가 특성을 가진 객체의 하위 타입이라 할 수 있다.\r\ntoString.call([1,2,3]) 을 사용하면 [object Array]의 반환값을 얻어 구체적으로 타입을 알 수 있어 배열인지 알 수 있게 된다.\r\n\r\n\r\n\r\n### undefined\r\n\r\n```javascript\r\nvar a;\r\nconsole.log(a); //undefined\r\nvar b = 1;\r\nconsole.log(b); //1\r\nvar c;\r\nconsole.log(c); //undefined\r\nb = c;\r\nconsole.log(b); //undefined\r\nconsole.log(d); //ReferenceError: d is not defined\r\n```\r\n\r\n위의 코드를 보면\r\n\r\nundefined (값이 없는), undefined(선언되지 않은) 은 자바스크립트에서는 전혀 다르다는 것을 알 수 있게 된다.\r\n\r\n\r\n\r\n```javascript\r\nvar a;\r\nvar b = 1;\r\nconsole.log(typeof a); //undefined\r\nconsole.log(typeof b); //undefined\r\nconsole.log(typeof c); //undefined\r\n```\r\n\r\n위의 코드를 보면 typeof는 값이 없는, 선언되지 않은 것 모두가 undefined 으로 표시된다.\r\n\r\ntypeof로는 둘을 구분 할 수 없지만 이렇게 에러가 발생하지 않는 특성(안전가드라고 한다)을 이용하여 유용하게 사용하는 방법도 있다.","excerpt":"Javascript Variable Types…","fields":{"slug":"/js-variable-types/"},"frontmatter":{"date":"Sep 11, 2017","title":"자바스크립트의 타입들","tags":["javascript"],"update":null}}},{"node":{"rawMarkdownBody":"자바스크립트의 배열은 어떤 타입이던 담을 수 있고, 배열 크기도 미리 정하지 않는다.\r\n\r\n```javascript\r\nvar arr = [\r\n  null,\r\n  undefined,\r\n  true,\r\n  1,\r\n  \"array\",\r\n  {}\r\n];\r\n\r\nconsole.log(arr); \r\n// [null, undefined, true, 1, \"array\", [object Object]{...}]\r\n\r\nconsole.log(typeof arr, toString.call(arr));\r\n//'object', '[object Array]'\r\n```\r\n\r\n\r\n\r\n### 배열에서 빈 슬롯의 주의점\r\n\r\n배열에서 주의 해야할 점은 중간에 빈 구멍이 있는 배열을 조심해야 한다.\r\n\r\n```javascript\r\nvar arr = [];\r\narr[0] = 1;\r\narr[2] = 2;\r\narr[3] = undefined;\r\n```\r\n\r\n위와 같은 코드가 있을때 배열의 1번은 비어있을 것이다. 어떤 배열이 되어있을지 보면\r\n\r\n```javascript\r\nconsole.log(arr); //[1, undefined, 2, undefined]\r\nconsole.log(arr.length); // 4\r\n```\r\n\r\n위와 같이 되어있다. 비어있는 배열이 undefined가 되어있다.\r\n1번 undefined와 따로 선언한 undefined의 3번은 서로 같은 것인 것일까?\r\n\r\n```javascript\r\nconsole.log(arr[1] === arr[3])\r\nconsole.log(typeof arr[1] === typeof arr[3]);\r\nconsole.log(toString.call(arr[1]) === toString.call(arr[3]));\r\nconsole.log(arr[1] === undefined);\r\nconsole.log(arr[3] === undefined);\r\n```\r\n\r\n이렇게 비교를 해 보아도 모두가 **true** 로 일치한다고 나온다 하지만\r\n빈 슬롯이 undefined과 된 것과 선언으로 인해 undefined 인 것은 **엄연히 다르다.**\r\n\r\n그 이유는 아래에서 알 수 있다.\r\n\r\n```javascript\r\nconsole.log(arr);\r\n[1, undefined, 2, undefined]\r\n\r\nfor(index in arr){\r\n  console.log(index);\r\n}\r\n// 0, 2, 3\r\n\r\nvar newArr = [];\r\narr.forEach(function(value, index){\r\n  console.log(\"index:\"+index+\"/value:\"+value);\r\n  newArr.push(value);\r\n})\r\n// \"index:0/value:1\"\r\n// \"index:2/value:2\"\r\n// \"index:3/value:undefined\"\r\n\r\nconsole.log(newArr);\r\n// [1, 2, undefined]\r\n```\r\n\r\nfor in, forEach 등을 통해 실험을 해 본 결과이다.\r\nfor in 에서는 index 1이 존재하지 않는 것으로 보이고,\r\nforEach를 통해서도 새로운 배열을 복사하는 것을 하려 했으나 1번 배열이 빠진채로 수행 된 것을 볼 수 있다.\r\n\r\n이러한 예제를 통해 빈 슬롯이 있는 배열을 다루게 된다면 조심해야한다는 것을 알 수 있다.\r\n\r\n\r\n\r\n### 배열의 key/property 형태의 활용\r\n\r\n배열 인덱스는 숫자이다. 그런데 배열도 객체이기 때문에 key/property 문자열을 추가 할 수 있다.\r\n\r\n```javascript\r\nvar arr = [];\r\n\r\narr[0] = 1;\r\narr[\"two\"] = 2;\r\n```\r\n\r\n조심해야할 점은 이렇게 선언할 경우 배열의 길이는 늘어나지 않는 것을 조심해야한다. 또한 배열을 출력할 경우 나타나지 않는다.\r\n\r\n```javascript\r\nconsole.log(arr); // [1]\r\nconsole.log(arr[\"two\"]); // 2\r\n\r\nconsole.log(arr.length); // 1\r\n\r\nfor(index in arr){\r\n  console.log(index);\r\n} // '0'\r\n```\r\n\r\n더욱 조심해야 할 점은 키로 넣은 문자열이 표준 10진수 숫자로 이루어져 있다면 아래와 같은 결과를 얻게 된다.\r\n\r\n```javascript\r\narr[\"5\"] = \"five\";\r\nconsole.log(arr);\r\n//[1, undefined, undefined, undefined, undefined, \"five\"]\r\nconsole.log(arr.length); // 6\r\n\r\nfor(index in arr){\r\n  console.log(index);\r\n} // '0', '5', 'two'\r\n```\r\n\r\n키/프로퍼티 형태로 활용하는 것을 지양하고 이렇게 써야한다는 상황이라면 문자열 프로퍼티는 꼭 숫자가 아닌 글자만 사용하도록 하자.\r\n\r\n\r\n\r\n### 유사배열\r\n\r\n유사배열을 진짜 배열로 바꾸는 방법\r\n\r\n일반적으로 indexOf, concat, forEach 등의 배열 함수들을 사용한다, \r\n또한 slice를 활용한 방법도 있다\r\n\r\n```javascript\r\nfunction test(){\r\n  var arr = Array.prototype.slice.call( arguments );\r\n  return arr;\r\n}\r\n\r\nvar a = test('a', 1);\r\nconsole.log(toString.call(a), a); \r\n//\"[object Array]\" [\"a\", 1]\r\n```\r\n\r\nES6에 와서는 유사 배열을 진짜 배열로 바꾸는 기능이 추가되었다. \r\n`Array.from()`\r\n\r\n```javascript\r\nfunction test(){\r\n  var arr = Array.from( arguments );\r\n  return arr;\r\n}\r\n\r\nvar a = test('a', 1);\r\nconsole.log(toString.call(a), a); \r\n//\"[object Array]\" [\"a\", 1]\r\n```","excerpt":"자바스크립트의 배열은 어떤 타입이던 담을 수 있고, 배열 크기도 미리 정하지 않는다. 배열에서 빈 슬롯의 주의점 배열에서 주의 해야할 점은 중간에 빈 구멍이 있는 배열을 조심해야 한다. 위와 같은 코드가 있을때 배열의…","fields":{"slug":"/js-array/"},"frontmatter":{"date":"Sep 11, 2017","title":"자바스크립트의 배열(Array)","tags":["javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nProxy : https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy\r\n\r\n\r\n\r\n```javascript\r\nconst myInfo = {\r\n  name: 'baik'\r\n};\r\n\r\nconst proxy = new Proxy(myInfo, {});\r\n// Proxy(object, handler);\r\n\r\nconsole.log(toString.call(proxy)); // object\r\n\r\n\r\nconsole.log(proxy.name); // baik\r\nproxy.name = 'junho';\r\nconsole.log(proxy.name); // junho\r\nconsole.log(myInfo.name); // junho\r\n\r\n\r\nconsole.log(proxy === myInfo); // false\r\nconsole.log(proxy.name === myInfo.name); // true\r\n```\r\n\r\n\r\n\r\n```javascript\r\nconst myInfo = {\r\n  name: 'baik',\r\n  change: 0\r\n};\r\n\r\nconst proxy1 = new Proxy(myInfo, {});\r\n\r\nconst proxy2 = new Proxy(myInfo, {\r\n  get: function(target, property, receiver){\r\n    console.log(\"get\");\r\n    return target[property];\r\n  },\r\n  set: function(target, property, value){\r\n    console.log(\"set\");\r\n    target['change']++;\r\n    target[property] = value;\r\n  }\r\n  // target => myInfo\r\n  // receiver => proxy2\r\n});\r\n\r\n\r\nconsole.log(proxy1.name); // \"baik\"\r\nconsole.log(proxy2.name); // \"get\" \"baik\"\r\nconsole.log(proxy2.change); // \"get\" 0\r\nproxy2.name = 'junho'; // \"set\"\r\nconsole.log(proxy2.name); // \"get\" \"junho\"\r\nconsole.log(proxy2.change); // \"get\" 1\r\nconsole.log(myInfo.name); // \"junho\"\r\n\r\n//porxy의 getter setter를 통해서 값을 가로채서 값을 변화시킨다거나,\r\n//변경사항 로그를 남기는 등의 용도록 활용할 수 있다.\r\n```\r\n\r\n\r\n\r\n권장되는 패턴\r\n\r\n```javascript\r\nconst proxy = new Proxy(myInfo, {\r\n  get: function(target, property, receiver){\r\n    //...\r\n    return Reflect.get(target, property);\r\n    // Reflect 활용\r\n  },\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n## reference\r\n\r\n- [모던 자바스크립트(javascript) 개발을 위한 ES6 강좌](https://www.inflearn.com/course/es6-%ea%b0%95%ec%a2%8c-%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8/)","excerpt":"Proxy : https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy 권장되는 패턴 reference 모던 자바스크립트(javascript…","fields":{"slug":"/js-es6-proxy/"},"frontmatter":{"date":"Sep 09, 2017","title":"자바스크립트 ES6 프록시(Proxy)","tags":["javascript","ES6"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nES6에서 출현한 module 기능은 브라우저 호환성이 아직은 완전하지 않다.  \r\ndevOps로 webpack, babel 등을 활용해 사용해 서비스 코드를 만드는 것이 좋다.\r\n\r\n\r\n\r\n### 기본 사용법\r\n\r\napp.js\r\n\r\n```javascript\r\nimport foo from './foo';\r\n\r\n// ...\r\n\r\nprint('Hello World'); // Hello World\r\n```\r\n\r\nfoo.js\r\n\r\n```javascript\r\nexport function print(value){\r\n    console.log(value);\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 심화, 서비스 코드 구현\r\n\r\napp.js\r\n\r\n```javascript\r\nimport sayHi, { print, getTime, myInfo } from './foo';\r\n//default로 지정한 것은 {}바깥, 그렇지 않은 것들은 {}안에 위치한다.\r\n\r\n// ...\r\n\r\nprint('Hello World'); // Hello World\r\ngetTime(); // \r\n\r\nconst me = new myInfo();\r\nprint(`My Name is ${getFullName()}`);\r\n// My Name is Junho Baik\r\n```\r\n\r\nfoo.js\r\n\r\n```javascript\r\nexport function print(value){\r\n    console.log(value);\r\n}\r\n\r\nexport const getTime = () => {\r\n    return Date.now();\r\n}\r\n\r\nexport class myInfo {\r\n    constructor(props){\r\n        this.name = [\"Junho\", \"Baik\"];\r\n    }\r\n  \r\n    getFullName(){\r\n        return this.name[0] + \" \" + this.name[1];\r\n    }\r\n}\r\n\r\nconst sayHi = () => {\r\n    console.log(\"Hi!\");\r\n}\r\nexport default sayHi;\r\n// export defalut const sayHi... 이와 같이는 쓸 수 없다.\r\n```\r\n\r\n\r\n\r\n\r\n```javascript\r\nexport const _ = {\r\n    print(value){\r\n        if(window.console) console.log(value);\r\n    }\r\n  \t\r\n  \t// ...\r\n}\r\n\r\n// 위와 같은 방식으로 사용하여\r\n_.print(\"ABC\"); // 이와같이 사용하는 방법 또한 있다.\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n## reference\r\n\r\n- [모던 자바스크립트(javascript) 개발을 위한 ES6 강좌](https://www.inflearn.com/course/es6-%ea%b0%95%ec%a2%8c-%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8/)","excerpt":"ES6에서 출현한 module 기능은 브라우저 호환성이 아직은 완전하지 않다. devOps로 webpack, babel 등을 활용해 사용해 서비스 코드를 만드는 것이 좋다. 기본 사용법 app.js foo.js 심화, 서비스 코드 구현 app.js…","fields":{"slug":"/js-es6-module/"},"frontmatter":{"date":"Sep 01, 2017","title":"자바스크립트 ES6 module(export&import)","tags":["javascript","ES6"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nsetPrototypeOf 로 프로토타입 객체를 추가 할 수 있다.  \r\n`Object.setPrototypeOf(obj, prototype)`  \r\nobject에 prototype을 추가한다.\r\n\r\n\r\n\r\n```javascript\r\nconst infoObj = {\r\n  sayHi : function(){\r\n    console.log(\"Hi \" + this.name)\r\n  },\r\n  setName : function(name){\r\n      this.name = name;\r\n  }\r\n};\r\n\r\nconst myInfo = {\r\n  name : \"Baik\",\r\n  msg : \"Hi\"\r\n};\r\n\r\nObject.setPrototypeOf(myInfo, infoObj);\r\n\r\nconsole.log(myInfo.sayHi());\r\n//Hi Baik\r\n\r\nmyInfo.setName(\"Baek\");\r\n\r\nconsole.log(myInfo.sayHi());\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### setPrototypeOf 로 개체간 prototype Chain 만들기\r\n\r\n\r\n\r\n```javascript\r\nconst infoObj = {\r\n  sayHi : function(){\r\n    console.log(\"Hi \" + this.name)\r\n  },\r\n  setName : function(name){\r\n      this.name = name;\r\n  }\r\n};\r\n\r\nconst infoChildObj = {\r\n  getAge : function(){\r\n    return this.age;\r\n  }\r\n}\r\n\r\nconst myInfo = Object.setPrototypeOf({\r\n  age : 22\r\n}, infoChildObj);\r\n// Chain = infoChildObj - myInfo\r\n\r\nconsole.log(myInfo);\r\n// age, getAge\r\n\r\nObject.setPrototypeOf(infoChildObj, infoObj);\r\n// Chain = infoObj - infoChildObj - myInfo\r\n\r\nconsole.log(myInfo);\r\n// age, getAge, sayHi, setName\r\n\r\ninfoObj.sayAge = function(){\r\n  console.log(\"Age is \" + this.age)\r\n}\r\n// infoObj에 sayAge를 추가함으로 myInfo에 까지 영향을 미치게된다.\r\n\r\nconsole.log(myInfo);\r\n//age, getAge, sayAge, sayHi, setName\r\n\r\n\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n## reference\r\n\r\n- [모던 자바스크립트(javascript) 개발을 위한 ES6 강좌](https://www.inflearn.com/course/es6-%ea%b0%95%ec%a2%8c-%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8/)","excerpt":"setPrototypeOf 로 프로토타입 객체를 추가 할 수 있다.  object에 prototype을 추가한다. setPrototypeOf 로 개체간 prototype Chain 만들기 reference 모던 자바스크립트(javascript…","fields":{"slug":"/js-es6-setprototypeof/"},"frontmatter":{"date":"Sep 01, 2017","title":"자바스크립트 ES6 Object setPrototypeOf","tags":["javascript","ES6"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n자바스크립트에도 이번 ES6에서 Class라는 키워드가 생겼다.\r\n\r\n\r\n\r\n아래는 기존 자바스크립트의 코드이다.\r\n\r\n```javascript\r\nfunction myInfo(name) {\r\n    this.name = name;\r\n}\r\n\r\nmyInfo.prototype.showName = function(){\r\n    console.log(\"My name is \"+ this.name);\r\n}\r\n\r\nconst baik = new myInfo(\"Junho\");\r\nbaik.showName(); // \"My name is Junho\"\r\n```\r\n\r\n\r\n\r\n아래는 Class를 활용한 코드이다.\r\n\r\n```javascript\r\nclass myInfo {\r\n  constructor(name){\r\n    this.name = name;\r\n  }\r\n  \r\n  showName() {\r\n    console.log(\"My name is \"+ this.name);\r\n  }\r\n}\r\n\r\nconst baik = new myInfo(\"Junho\");\r\nbaik.showName(); //\"My name is Junho\"\r\n```\r\n\r\n위와 같이 클래스로 똑같은 코드를 구현할 수 있다. 하지만 그렇다고 클래스라는 것이 완전히 새로 생긴 것이 아니고 위와 같이 했더라도 내부적으로는 함수, 프로토타입을 통해 작동하는 것이다.\r\n\r\n```javascript\r\nconsole.log(toString.call(myInfo)); //[object Function]\r\n```\r\n\r\n이번에 ES6에서 편의와 가독성을 위해 class라는 키워드가 생긴 것이라고 볼 수 있다.\r\n\r\n\r\n---\r\n\r\n## reference\r\n\r\n- [모던 자바스크립트(javascript) 개발을 위한 ES6 강좌](https://www.inflearn.com/course/es6-%ea%b0%95%ec%a2%8c-%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8/)","excerpt":"자바스크립트에도 이번 ES6에서 Class라는 키워드가 생겼다. 아래는 기존 자바스크립트의 코드이다. 아래는 Class…","fields":{"slug":"/js-es6-class/"},"frontmatter":{"date":"Aug 10, 2017","title":"자바스크립트 ES6 클래스(Class)","tags":["javascript","ES6"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n아래 코드는 Object create를 사용한 코드이다.\r\n\r\n```javascript\r\nconst infoObj = {\r\n  showName : function(){\r\n    console.log(\"My name is \" + this.name);\r\n  }\r\n}\r\n\r\n//아래와 같은 방법으로 프로토타입을 사용한 것 보다 간결하게 나타낼 수 있다.\r\nconst myInfo = Object.create(infoObj);\r\n\r\nmyInfo.name = \"Junho\";\r\nmyInfo.age = 27;\r\n\r\nconsole.log(myInfo);\r\n/*\r\n{name: \"Junho\", age: 27}\r\n  age:27\r\n  name:\"Junho\"\r\n  __proto__: \r\n    showName: ƒ showName()\r\n    __proto__:Object\r\n*/\r\nconsole.log(myInfo.showName()); //\"My name is Junho\"\r\n```\r\n\r\n\r\n\r\n아래 코드는 위의 코드에 Object assign을 사용한 코드이다.\r\n\r\n`myInfo.name = \"Junho\";` 와 같이 계속해서 추가해야하는 수고를 덜어줄 수 있다.\r\n\r\n```javascript\r\nconst infoObj = {\r\n  showName : function(){\r\n    console.log(\"My name is \" + this.name);\r\n  }\r\n}\r\n\r\nconst myInfo = Object.assign(Object.create(infoObj), {\r\n  name : \"Junho\",\r\n  age : 27\r\n});\r\n\r\n\r\nconsole.log(myInfo);\r\nconsole.log(myInfo.showName());\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## Object assign 으로 Immutable 객체 만들기\r\n\r\n```javascript\r\nconst previousObj = {\r\n  name : \"Junho\",\r\n  age : 27\r\n};\r\n\r\nconst myInfo = Object.assign({}, previousObj, {\r\n  name : \"Baik\",\r\n  msg : \"Hi\"\r\n});\r\n\r\nconst myInfo2 = Object.assign({}, previousObj, {});\r\n\r\n\r\nconsole.log(previousObj); //{name: \"Junho\", age: 27}\r\n\r\nconsole.log(myInfo); //{name: \"Junho\", age: 27}\r\nconsole.log(previousObj === myInfo); //false\r\n\r\nconsole.log(myInfo2); //{name: \"Junho\", age: 27}\r\nconsole.log(previousObj === myInfo2); \r\n//false\r\n//내용은 같으나 사실상 다른 객체이다, immutable object\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n## reference\r\n\r\n- [모던 자바스크립트(javascript) 개발을 위한 ES6 강좌](https://www.inflearn.com/course/es6-%ea%b0%95%ec%a2%8c-%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8/)","excerpt":"아래 코드는 Object create를 사용한 코드이다. 아래 코드는 위의 코드에 Object assign을 사용한 코드이다.  와 같이 계속해서 추가해야하는 수고를 덜어줄 수 있다. Object assign 으로 Immutable…","fields":{"slug":"/js-es6-object-assign/"},"frontmatter":{"date":"Aug 10, 2017","title":"자바스크립트 ES6 Object.assign","tags":["javascript","ES6"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nES6 에 출현한 새로운 형태의 함수 표현 방법\r\n\r\n```javascript\r\nconst fn = function(){};\r\nconst arrowFn = () => {};\r\n\r\n(v) => (v+1) //{}없이 사용, v+1이 리턴값\r\n(v) => v+1 //()생략 가능\r\n```\r\n\r\n\r\n\r\n### Arrow Function, this context\r\n\r\n```javascript\r\nconst obj = {\r\n  runTimeout() {\r\n    setTimeout(function(){\r\n      console.log(toString.call(this)); //[object Window]\r\n    }, 1000);\r\n  },\r\n  \r\n  sayHi(){\r\n    console.log(\"hi\");\r\n    console.log(toString.call(this));\r\n  }\r\n}\r\n\r\nobj.runTimeout(); //[object Window]\r\nobj.sayHi(); // hi [object Object]\r\n```\r\n\r\n위의 코드는 아무런 문제 없이 작동하는 코드이다, runTimeout은 settimeout때문에 이벤트큐에 등록 된뒤 실행되는 것이라 this가 해당 오브젝트가 아닌 윈도우이다. 우선 위에서 this가 가리키는 것이 무엇인지 잘 봐두고, 문제가 될 수 있는 상황을 아래서 살펴보자\r\n\r\n```javascript\r\nconst obj = {\r\n  runTimeout() {\r\n    setTimeout(function(){\r\n      console.log(toString.call(this));\r\n      this.sayHi(); //<========\r\n      //typeError: this.sayHi is not a function\r\n    }, 1000);\r\n  },\r\n  \r\n  sayHi(){\r\n    console.log(\"hi\");\r\n    console.log(toString.call(this));\r\n  }\r\n}\r\n\r\nobj.runTimeout();\r\n```\r\n\r\nrunTimeout 에서 sayHi를 실행하려면 this가 가리키는 것이 서로 다르기 때문에 오류가 난다.\r\n\r\n```javascript\r\nconst obj = {\r\n  runTimeout() {\r\n    setTimeout(function(){\r\n      console.log(toString.call(this)); //[obejct Object]\r\n      this.sayHi();\r\n    }.bind(this), 1000); //<========\r\n  },\r\n  \r\n  sayHi(){\r\n    console.log(\"hi\");\r\n    console.log(toString.call(this)); //[obejct Object]\r\n  }\r\n}\r\n\r\nobj.runTimeout(); // [obejct Object] hi [obejct Object]\r\n```\r\n\r\n위와 같이 .bind(this) 를 사용하여 해결하는 방법이 있다.\r\n\r\n```javascript\r\nconst obj = {\r\n  runTimeout() {\r\n    setTimeout(()=>{ //<========\r\n      console.log(toString.call(this));\r\n      this.sayHi();\r\n    }, 1000);\r\n  },\r\n  \r\n  sayHi(){\r\n    console.log(\"hi\");\r\n    console.log(toString.call(this));\r\n  }\r\n}\r\n\r\nobj.runTimeout();\r\n```\r\n\r\n또 다른 방법으로 Arrow function을 이용하여 해결할 수 있다.\r\n\r\nArrow function은 항상 this context를 실행되는 해당 context를 유지하는 특성이 있다.\r\n\r\n\r\n\r\n---\r\n\r\n## reference\r\n\r\n- [모던 자바스크립트(javascript) 개발을 위한 ES6 강좌](https://www.inflearn.com/course/es6-%ea%b0%95%ec%a2%8c-%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8/)","excerpt":"ES6 에 출현한 새로운 형태의 함수 표현 방법 Arrow Function, this context 위의 코드는 아무런 문제 없이 작동하는 코드이다, runTimeout은 settimeout때문에 이벤트큐에 등록 된뒤 실행되는 것이라 this…","fields":{"slug":"/js-es6-arrow-function/"},"frontmatter":{"date":"Jul 21, 2017","title":"자바스크립트 ES6 Arrow Function","tags":["javascript","ES6"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nJavascript에서는 배열로 보이지만 정작 배열이 아닌 형태의 것들이 존재한다.\r\n\r\n예로 메소드로 전달되는 인자들을 활용하는 arguments 객체같은 경우에도 배열같아보이지만 실제 배열은 아니다.\r\n따라서, map과 같은 배열을 다루는 메소드를 활용할 수 없는데 이러한 가짜 배열을 진짜배열로 바꿔주는 것을 from 이 해주게 된다.\r\n\r\n\r\n\r\n```javascript\r\nfunction toArray(array){\r\n  const len = array.length;\r\n  const temp = [];\r\n  \r\n  for(let i=0; i<len; i++){\r\n    temp.push(array[i]);\r\n  }\r\n  \r\n  return temp;\r\n}\r\n\r\nfunction toArray2(array){\r\n  return array.map(function(value){\r\n    return value;\r\n  })\r\n}\r\n\r\n\r\nfunction foo() {\r\n  \r\n  console.log(toString.call(arguments)); \r\n  // [object Arguments]\r\n  \r\n  console.log(toArray(arguments));\r\n  // [1, 2, 3, 4, 5]\r\n  \r\n  //console.log(toArray2(arguments));\r\n  // map 사용시 배열이 아니기 떄문에 오류 발생\r\n  \r\n  /*************************************/\r\n  \r\n  let newArray = Array.from(arguments);\r\n  \r\n  console.log(toString.call(newArray));\r\n  // [object Array]\r\n  \r\n  console.log(toArray(newArray));\r\n  // [1, 2, 3, 4, 5]\r\n  \r\n  console.log(toArray2(newArray));\r\n  // [1, 2, 3, 4, 5]\r\n}\r\n\r\nfoo(1,2,3,4,5);\r\n```\r\n\r\n\r\n\r\n위 코드에서 toArray2 메소드는 map을 활용하여 배열을 반환한다.\r\n\r\n하지만 arguments를 인자로 전달했을때는 에러가 발생하는 것을 볼 수 있다.","excerpt":"Javascript에서는 배열로 보이지만 정작 배열이 아닌 형태의 것들이 존재한다. 예로 메소드로 전달되는 인자들을 활용하는 arguments 객체같은 경우에도 배열같아보이지만 실제 배열은 아니다.\n따라서, map…","fields":{"slug":"/js-es6-from/"},"frontmatter":{"date":"Jun 29, 2017","title":"자바스크립트 ES6 from","tags":["javascript","ES6"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n\r\n\r\n쉽게 말해 배열을 펼쳐주는 역할이다. ''[ ]''를 떼어낸다고 생각하면 쉽다.  \r\n배열을 바꾸지 않고 새로운 값을 복사, 배열을 합치거나 배열을 펼쳐진 상태로 파라메터로 전달 등의 활용이 가능하다.\r\n\r\n\r\n\r\n```javascript\r\nlet a = [1,\"\",undefined,NaN,null];\r\nlet b = [...a];\r\n\r\nconsole.log(a); //[1, \"\", undefined, NaN, null]\r\nconsole.log(b); //[1, \"\", undefined, NaN, null]\r\n\r\nconsole.log(a === b); //false\r\n// 새로운 배열로 메모리에 들어간 복사를 한 형태, \r\n// concat을 이용한 것과 같은 결과이다.\r\n// 배열을 바꾸지 않고 새로운 값을 복사할 수 있는 방법.\r\n```\r\n\r\n\r\n\r\n```javascript\r\nlet c = [...a, 'add'];\r\nconsole.log(c); //[1, \"\", undefined, NaN, null, \"add\"]\r\n// 기존에 복잡한 과정을 거쳐했던 것을 간단하게 \r\n// 이러한 방식으로 배열 앞뒤에 새로운 것을 추가할 수 있다.\r\n```\r\n\r\n\r\n\r\n```javascript\r\nfunction sum(a,b,c){\r\n  return a+b+c;\r\n}\r\n\r\nlet s = [1,2,3];\r\n\r\nconsole.log(sum.apply(null,s)); \r\n// 기존 방식\r\n\r\nconsole.log(sum(...s)); \r\n// spread operator를 이용한 새로운 방식\r\n```\r\n\r\n","excerpt":"쉽게 말해 배열을 펼쳐주는 역할이다. '' ''를 떼어낸다고 생각하면 쉽다. 배열을 바꾸지 않고 새로운 값을 복사, 배열을 합치거나 배열을 펼쳐진 상태로 파라메터로 전달 등의 활용이 가능하다.","fields":{"slug":"/js-es6-spread-operator/"},"frontmatter":{"date":"Jun 29, 2017","title":"자바스크립트 ES6 Spread operator, 펼침 연산자","tags":["javascript","ES6"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n## Javascript 'For Loop'\r\n\r\n자바스크립트에서 사용하는 for 반복문의 유형에 대해 알아보자.\r\n\r\n- for\r\n   - `for ([initialization]; [condition]; [final-expression])`\r\n- for in\r\n   - `for (variable in [object | array])`\r\n- for of (ES6)\r\n   - `for (variable of object)`\r\n\r\n---\r\n\r\n### - for\r\n\r\n`for ([initialization]; [condition]; [final-expression])`\r\n\r\n### - for in\r\n\r\n`for (variable in [object | array])`\r\n\r\n- variable\r\n 1. object 일때 variable = object의 다음 속성 이름\r\n 2. array 일때 variable = array의 다음 요소 인덱스\r\n\r\n### - for of (ES6)\r\n\r\n`for (variable of object)`\r\n\r\n- variable\r\n 1. object의 임의 속성 **값**일 수 있는 변수입니다.\r\n\r\n\r\n```javascript\r\nconst arr = [1,\"\",undefined,NaN,null];\r\n\r\n/**************************************/\r\n\r\nfor(let index = 0; index < arr.length; index++){\r\n  console.log(arr[index]);\r\n}\r\n// 1\r\n// \"\"\r\n// undefined\r\n// NaN\r\n// null\r\n\r\n\r\n/**************************************/\r\n\r\n\r\nfor(let index in arr){\r\n  console.log(\"index:\" + index + \" / arr[index]:\" + arr[index]);\r\n}\r\n// index:0 / arr[index]:1\r\n// index:1 / arr[index]:\"\"\r\n// index:2 / arr[index]:undefined\r\n// index:3 / arr[index]:NaN\r\n// index:4 / arr[index]:null\r\n\r\n\r\n/**************************************/\r\n\r\n\r\nfor(let value of arr){\r\n  console.log(value);\r\n}\r\n// 1\r\n// \"\"\r\n// undefined\r\n// NaN\r\n// null\r\n```\r\n\r\n\r\n\r\n### for of / for in 의 차이점\r\n\r\n배열일 경우 배열 전체를 순회하는 반복문인 것은 같지만 차이점이 있다.\r\n\r\n여기서 ES6에서 새로 나온 for of 의 장점을 발견 할 수 있다.\r\n\r\n\r\n아래 코드를 살펴보면 Array의 prototype에 foo라는 새로운 메소드를 정의해놓았다.\r\n그런데 arr를 for in문을 통해서 콘솔 출력한 결과 foo라는 메소드까지 같이 출력되는 것을 볼 수 있다.\r\n하지만 for of는 그렇지 않다, 온전히 자신의 것만 출력할 수 있다.\r\n\r\n```javascript\r\nconst arr = [1,\"\",undefined,NaN,null];\r\nArray.prototype.foo = function(){};\r\n\r\nfor(let index in arr){\r\n  console.log(\"index:\" + index + \" / arr[index]:\" + arr[index]);\r\n}\r\n// index:0 / arr[index]:1\r\n// index:1 / arr[index]:\"\"\r\n// index:2 / arr[index]:undefined\r\n// index:3 / arr[index]:NaN\r\n// index:4 / arr[index]:null\r\n// index:foo / arr[index]:function () {}\r\n\r\nfor(let value of arr){\r\n  console.log(value);\r\n}\r\n// 1\r\n// \"\"\r\n// undefined\r\n// NaN\r\n// null\r\n```\r\n\r\n","excerpt":"Javascript 'For Loop' 자바스크립트에서 사용하는 for 반복문의 유형에 대해 알아보자. for  for in  for of (ES6)  - for  - for in  variable object 일때 variable = object…","fields":{"slug":"/js-for-loop/"},"frontmatter":{"date":"Jun 29, 2017","title":"자바스크립트 for문들의 유형과 차이점","tags":["javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n- [String.prototype.startsWith()][https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith]\r\n  - 문자열이 특정 문자로 시작하는지 확인, 결과를 true, false로 반환.\r\n- [String.prototype.endsWith()][https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith]\r\n  - 문자열이 특정 문자로 끝나는지 확인, 결과를 true, false로 반환.\r\n- [String.prototype.includes()][https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/includes]\r\n  - 문자열에 특정 문자열이 포함되는지 확인, 결과를 true, false로 반환.\r\n\r\n```javascript\r\nlet str = 'javascript es6 string methods';\r\n\r\nconsole.log(str.startsWith('javascript')); //true\r\nconsole.log(str.endsWith('methods')); //true\r\nconsole.log(str.includes('es6')); //true\r\n```\r\n\r\n\r\n\r\n- [String.prototype.repeat()][https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/repeat]\r\n  - 문자열을 인자만큼 반복하는 문자열을 반환\r\n\r\n```javascript\r\nlet str = 'es6';\r\n\r\nconsole.log(str.repeat(3)); //es6es6es6\r\n```\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n## Reference\r\n\r\n- [모던 자바스크립트(javascript) 개발을 위한 ES6 강좌](https://www.inflearn.com/course/es6-%ea%b0%95%ec%a2%8c-%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8/)","excerpt":"String.prototype.startsWith() 문자열이 특정 문자로 시작하는지 확인, 결과를 true, false로 반환. String.prototype.endsWith() 문자열이 특정 문자로 끝나는지 확인, 결과를 true, false…","fields":{"slug":"/js-es6-string-methods/"},"frontmatter":{"date":"Jun 29, 2017","title":"자바스크립트 ES6 String Methods","tags":["javascript","ES6"],"update":null}}},{"node":{"rawMarkdownBody":"\r\nES6 (ES2015) 에서는 새로운 선언 방법이 생겼는데,  \r\n그것이 const와 let이다.  \r\n기존에 다른 프로그래밍 언어를 사용하고 왔다면 처음 var 를 접할때 당황스러운 점을 느껴본 적이 있을 것이다. var의 관대함 때문이다. 그런 것을 비교하며 살펴보겠다.\r\n\r\n```javascript\r\n//case 1\r\nconsole.log(a);\r\nvar a;\r\n\r\n//case 2\r\nconsole.log(a);\r\nlet a;\r\n\r\n//case 3\r\nconsole.log(a);\r\nconst a;\r\n```\r\n\r\n해당 변수를 선언하기 전에 호출하는 모습이다.\r\n\r\n- case 1 : `undefined`\r\n- case 2 & 3 : `error`\r\n\r\n\r\n\r\n```javascript\r\n//case 1\r\nvar a = 'a';\r\nvar a = 'A';\r\n\r\n//case 2\r\nlet b = 'b';\r\nlet b = 'B';\r\n\r\n//case 3\r\nconst c = 'c';\r\nconst c = 'C';\r\n```\r\n\r\n위의 세 경우를 보자 같은 이름의 변수를 다시금 선언하고 있는 모습이다.\r\n\r\n- case 1 : `a=1`\r\n- case 2 & 3 : `error`\r\n\r\n\r\n\r\n**위의 두가지 경우를 통해서 let, const는 기존의 var의 관대함 없이 엄격해진 것을 볼 수 있다**\r\n\r\n\r\n\r\n### scope\r\n\r\n다음으로 스코프, 즉 유효 범위에 따른 차이점이다.\r\n\r\n```javascript\r\n//case 1\r\nvar a = 'a';\r\nfunction print(){\r\n  var a = 'A';\r\n  console.log(a);\r\n}\r\nprint(); // 'A'\r\nconsole.log(a); // 'A'\r\n\r\n//case 2\r\nlet a = 'a';\r\nfunction print(){\r\n  let a = 'A';\r\n  console.log(a);\r\n}\r\nprint(); // 'A'\r\nconsole.log(a); // 'a'\r\n```\r\n\r\n- case 1\r\n  - 함수 밖에서 a 선언, 그리고 함수 안에서 재선언되었다.\r\n  - 함수 안 a 출력은 함수 안에서 선언한 'A'가 출력\r\n  - 함수 밖 a 출력은 함수 안에서 재선언한 'A'가 출력\r\n  - 즉, 동일한 유효범위 안에 있다.\r\n- case 2\r\n  - 함수 밖에서 a 선언, 그리고 함수 안에서 선언.\r\n  - 함수 안 a 출력은 함수 안에서 선언한 'A'가 출력\r\n  - 함수 밖 a 출력은 함수 밖에서 선언한 'a'가 출력\r\n  - 즉, 서로 다른 유효범위를 가지고 있다.\r\n  - let, const는 블록 유효범위(Block scope)를 가지고 있어,\r\n    해당 블록 범위 안에서만 유효하다.\r\n\r\n\r\n\r\n\r\n### let, const 의 차이점\r\n\r\nvar 와 let, const의 차이점을 알아보았고, 그렇다면 let, const의 차이점은 무엇일까?\r\n\r\n- const \r\n  - 상수\r\n  - 초기값 필요 / 값 재할당 불가\r\n  - Array, Object, function의 경우 멤버값 조작 가능\r\n- let\r\n  - 초기값 불필요 / 값 재할당 가능\r\n\r\n\r\n\r\n\r\n### let, const 의 사용\r\n\r\n그렇다면 언제 let을 사용하고 const를 사용해야 할까?\r\n\r\n- const\r\n  - 값이 수정되지 않는 상수값 선언시 사용\r\n  - array, object, function 활용시 사용\r\n- let\r\n  - 값을 재할당할 필요가 있는 변수에 사용\r\n\r\n\r\n\r\n\r\n---\r\n\r\n### etc.\r\n\r\n#### immutable array 만들기 (불변의 어레이 만들기)\r\n\r\n```javascript\r\nconst list = [1,2,3];\r\n\r\nconst list2 = list;\r\nlist2.push(4);\r\n\r\n// 원하는 결과\r\n// list = [1,2,3]\r\n// list2 = [1,2,3,4]\r\n// 'list === list2' 가 false\r\n\r\nconsole.log('1, '+list);\r\nconsole.log('2, '+list2);\r\nconsole.log(list === list2);\r\n\r\n// 실제 결과\r\n// list = [1,2,3,4]\r\n// list2 = [1,2,3,4]\r\n// 'list === list2' 가 true\r\n\r\n// 원하는 결과를 얻기 위한 방법\r\nconst newlist = [1,2,3]\r\nconst newlist2 = [].concat(newlist);\r\nnewlist2.push(4);\r\n\r\nconsole.log('1, '+newlist);\r\nconsole.log('2, '+newlist2);\r\nconsole.log(newlist === newlist2);\r\n\r\n// newlist = [1,2,3]\r\n// newlist2 = [1,2,3,4]\r\n// 'newlist === newlist2' false\r\n```\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n## References\r\n- http://blog.nekoromancer.kr/2016/01/26/es6-var-let-%EA%B7%B8%EB%A6%AC%EA%B3%A0-const/","excerpt":"ES6 (ES2015) 에서는 새로운 선언 방법이 생겼는데, 그것이 const와 let이다. 기존에 다른 프로그래밍 언어를 사용하고 왔다면 처음 var 를 접할때 당황스러운 점을 느껴본 적이 있을 것이다. var…","fields":{"slug":"/js-es6-const-let/"},"frontmatter":{"date":"Jun 28, 2017","title":"자바스크립트 ES6 const, let","tags":["javascript","ES6"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n![출처 : https://velopert.com/1130](https://velopert.com/wp-content/uploads/2016/03/Screenshot-from-2016-12-10-00-21-26-1.png)\r\n\r\n\r\n## - Mount\r\n\r\n컴포넌트가 실행 될 때, 'Mount 된다' 라고 표현.\r\n\r\n컴포넌트가 시작되면 제일 초기의 작업은\r\n\r\n1. context, defaultProps, state 저장\r\n2. componentWillMount 메소드 호출\r\n3. render, 컴포넌트를 DOM에 그린다.\r\n4. componentDidMount 호출\r\n\r\n---\r\n\r\n## - 기본적인 컴포넌트 생성 과정\r\n\r\n### constructor\r\n\r\n```javascript\r\nconstructor(props){\r\n\tsuper(props);\r\n}\r\n```\r\n\r\n컴포넌트가 처음 만들어 질 때 **가장 먼저** 실행되는 메소드\r\n\r\n\r\n### componentWillMount\r\n\r\n```javascript\r\ncomponentWillMount(){\r\n}\r\n```\r\n\r\n컴포넌트가 DOM 위에 만들어지기 전에 실행된다,\r\n\r\n- componentWillMount 중 주의할 점\r\n  - 현재 Mount 진행 중이므로(DidMount 전이다), props나 state를 변경해서는 안된다.\r\n  - 또한 render 단계에 진입하지 않았으므로 DOM에 접근 할 수 없다.\r\n\r\n\r\n### componentDidMount\r\n\r\n```javascript\r\ncomponentDidMount(){\r\n}\r\n```\r\n\r\n컴포넌트가 만들어지고 난 후 render를 거치고 실행되는 메소드.\r\n\r\n여기서 javascript framework 연동, setTimeout, setInterval 및 AJAX 처리를 한다.\r\n\r\n- componentDidMount 에서 주의할 점\r\n  - render가 되었으므로 DOM에 접근 할 수 있지만,\r\n    state를 바꾸면 안된다. setState메소드를 사용하면 render 메소드가 다시 실행되기 때문이다.\r\n    방금 render를 마친 단계인데, 다시금 render가 실행되면 사용자에게 표시될때 깜박임 등을 유발 할 수 있게 된다.\r\n\r\n---\r\n\r\n\r\n\r\n## - Props Update 에 따른 cycle\r\n\r\nprops가 업데이트 될 때의 사이클,\r\n\r\n업데이트 되기 전, 업데이트를 감지 우선 **componentWillRecieveProps** 메소드 호출.\r\n\r\n다음으로 **shouldComponentUpdate, componentWillUpdate**가 차례로 호출.\r\n\r\n업데이트(render)가 완료되면 componentDidUpdate가 실행된다.\r\n\r\n여기서 componentDidUpdate는 이미 업데이트 된 상태이다, 따라서 바뀌지 이전의 props에 대한 정보를 가지고 있다.\r\n\r\n메소드들의 첫번째 인자로 props에 대한 정보를 가지고 있다.\r\n\r\n\r\n\r\n1. componentWillRecieveProps\r\n2. shouldComponentUpdate\r\n3. componentWillUpdate\r\n4. render\r\n5. componentDidUpdate\r\n\r\n\r\n\r\n###  componentWillRecieveProps\r\n\r\n```javascript\r\ncomponentWillRecieveProps(nextProps){\r\n  \r\n}\r\n```\r\n\r\n컴포넌트가 props를 새로 받았을 때 실행.\r\n\r\nprop에 따라 state 를 업데이트 해야 할 때 사용하면 유용하다.\r\n\r\n- componentWillRecieveProps 단계에서 주의 할 점\r\n  - setState를 할 때 추가적으로 렌더링 하지 않는다\r\n\r\n### shouldComponentUpdate\r\n\r\n```javascript\r\nshouldComponentUpdate(nextProps, nextState){\r\n  var foo = nextProps !== this.props;\r\n  return foo;\r\n}\r\n```\r\n\r\nprop 또는 state가 변경되었을때, 다시 render를 할지 결정하는 메소드.\r\n\r\nreturn 값 boolean으로 결정된다.\r\n\r\n\r\n\r\n###  componentWillUpdate\r\n\r\n```javascript\r\ncomponentWillUpdate(nextProps, nextState){\r\n    \r\n}\r\n```\r\n\r\n컴포넌트가 업데이트 되기 전에 실행.\r\n\r\n- 주의사항\r\n  - setState 사용 시 무한 루프 발생\r\n\r\n\r\n\r\n### componentDidUpdate\r\n\r\n```javascript\r\ncomponentDidUpdate(prevProps, prevState){\r\n    \r\n}\r\n```\r\n\r\nrender를 마친 후 실행된다.\r\n\r\n변경되고 난 후 이므로 변경 전의 prop, state를 가지고 있다.\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n## - State Update 에 따른 cycle\r\n\r\nsetState를 통해서 state가 업데이트 될 때의 과정.\r\n\r\nprops update와 과정은 동일하나 componentWillRecieveProps 메소드는 호출되지 않는다.\r\n\r\n메소드들의 두번째 인자로 state에 대한 정보를 가지고 있다.\r\n\r\n\r\n\r\n1. shouldComponentUpdate\r\n2. componentWillUpdate\r\n3. render\r\n4. componentDidUpdate\r\n\r\n\r\n---\r\n\r\n\r\n\r\n## - Unmount\r\n\r\nUnmount, 컴포넌트가 제거되는 것.\r\n\r\n\r\n\r\n1. componentWillUnmount\r\n\r\n### componentWillUnmount\r\n\r\n```javascript\r\ncomponentWillUnmount(){\r\n  \r\n}\r\n```\r\n\r\n컴포넌트가 DOM 에서 사라진 후 실행되는 메소드,\r\n\r\n연결해두었던 이벤트 리스너를 제거하는 등의 수행을 하게 된다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n## References\r\n\r\n- https://velopert.com/1130\r\n- https://www.zerocho.com/category/React/post/579b5ec26958781500ed9955\r\n","excerpt":"출처 : https://velopert.com/1130 - Mount 컴포넌트가 실행 될 때, 'Mount 된다' 라고 표현. 컴포넌트가 시작되면 제일 초기의 작업은 context, defaultProps, state…","fields":{"slug":"/js-react-lifecycle/"},"frontmatter":{"date":"Jun 20, 2017","title":"리액트 생명주기 (React LifeCycle)","tags":["javascript","react"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n스코프 = 현재 접근 할 수 있는 변수들의 범위  \r\n\r\n예제 1\r\n```html\r\n<button id=\"btn0\">버튼 1</button>\r\n<button id=\"btn1\">버튼 2</button>\r\n<button id=\"btn2\">버튼 3</button>\r\n\r\n<script>\r\n  var i, len = 3;\r\n  for (i = 0; i < len; i++) {\r\n    document.getElementById('btn'+i).addEventListener(\"click\", function () {\r\n      console.log(\"Click btn\", i);\r\n    });\r\n  }\r\n</script>\r\n```\r\n버튼 3개를 각각 클릭했을때 결과값은 모두 \"Click btn3\"가 나온다.  \r\n이벤트 핸들러의 콜백 함수가 작성되어 있는데 그 콜백 함수는 콜백함수 밖에 있는 변수들에 접근 할 수 있는 스코프를 가지게 된다.  \r\nfor 반복문을 통해서 각각 div 순서대로 클릭 이벤트 핸들러가 부여될 때 변수 i가 0부터 3까지 증가한 뒤 이후에 for 반복문이 끝나도 계속해서 유지된다.  \r\n따라서 나중에 출력문이 호출될때 변수 i의 값은 이미 for반복문이 끝난 값인 3으로 출력되는 것이다.  \r\n\r\nfor문을 돌때는 별도의 스코프가 생성되지 않고 i는 글로벌 스코프에 존재한다.  \r\n그러다가 **이벤트리스너의 콜백함수를 설정할때 익명 함수가 선언되면서 이때 스코프가 생성**되어 스코프 체인을 만들게 된다.\r\n\r\n이러한 현상은 **자바스크립트에서 스코프가 함수로 인해 생성되고 함수가 호출될 때도 계속 지속되어 변수들을 참조하는 특성**때문에 일어난다.  \r\n\r\n-----------\r\n\r\n스코프의 생성  \r\n\r\nfor문의 스코프 생성 여부를 알아보기 위한 예제  \r\n0부터 9까지 더하여 총합이 16이 넘는 숫자를 구하는 코드  \r\n```html\r\n<script>\r\n  for(var i = 0; i < 10; i++){\r\n    var total = (total || 0) + 1;\r\n    var last = i;\r\n    if(total > 16){\r\n      break;\r\n    }\r\n  }\r\n  console.log(\"typeof total !== 'undifined'\",typeof total !== \"undifined\");\r\n  console.log(\"typeof last !== 'undifined'\",typeof last !== \"undifined\");\r\n  console.log(\"typeof i !== 'undifined'\",typeof i !== \"undifined\");\r\n  console.log(\"total ===\"+total+\", last ===\"+last);\r\n</script>\r\n```\r\nConsole\r\n```\r\ntypeof total !== 'undifined' true\r\ntypeof last !== 'undifined' true\r\ntypeof i !== 'undifined' true\r\ntotal ===10, last ===9\r\n```\r\nfor문 안에서 생성된 변수 total,last,i가 정의되지 않은 것이 아니며, 값에 접근 할 수 있는 것을 알 수 있다.  \r\n\r\n다른 프로그래밍 언어에서는 for문 안에서 선언한 변수를 for문 밖에서 접근하게 되면 에러가 발생하지만  자바스크립트에서는 모든 값에 접근 할 수 있다.  \r\n이처럼 자바스크립트는 다른 언어와는 달리 일반적인 블록 스코프를 따르지 않는다.  \r\n**자바스크립트의 스코프는 특정 구문이 실행될 때 새로 생성하여 스코프 체인을 생성하게 된다.**   \r\n이렇게 스코프를 생성하는 구문들은 다음과 같다.  \r\n\r\n- function\r\n- with\r\n- catch  \r\n\r\n자바스크립트에서 이들의 사용법은 각각 다르지만, 중요한건 이런 구문들이 사용될 때문 스코프가 생성되고, **다른 프로그래밍 언어처럼 {}를 이용해 블록을 생성한다고 해서 스코프가 생성되는 것이 아니라는 점**이다.\r\n\r\n----------\r\n\r\nfunction 구문의 스코프 생성  \r\n\r\n```js\r\nfunction foo(){\r\n  var b = \"Can you access me?\";\r\n}\r\nconsole.log(typeof b === \"undefined\");\r\n```\r\nconsole\r\n```\r\ntrue\r\n```\r\nfunction foo안의 b값에 접근하지 못하는 것을 알 수 있다.    \r\n**function 구문을 통해서 스코프가 생성된 것을 알 수 있다.**  \r\n\r\n----------\r\n\r\ncatch 구문의 스코프 생성  \r\n\r\ncatch 구문도 스코프를 생성하기는 하지만 function과는 다른 동작을 보인다.  \r\n괄호 안에 인자로 받는 변수들만 새로운 내부 스코프에 포함되어 그 다음으로 오는 블록 안에서만 접근 할 수 있다.  \r\n반면 블록 안에서 새로 정의한 변수들은 for-loop와 비슷하게 블록 외부에서도 접근 할 수 있다.  \r\n```js\r\ntry {\r\n  throw new exception(\"fake exception\");\r\n} catch (error) {\r\n  var test = \"can you see me?\";\r\n  console.log(error instanceof ReferenceError === true);\r\n}\r\nconsole.log(test === \"can you see me?\");\r\nconsole.log(typeof error === undefined);\r\n```\r\nconsole\r\n```\r\ntrue\r\ntrue\r\nfalse\r\n```\r\n첫번째 출력문에서는 error라는 인자로 받은 변수가 해당 블록 안에 있는 것을 알 수 있다.  \r\n두번째 출력문에서는 catch 구문에서 **새로 정의한 test 변수에 접근이 가능**하다는 것을 알 수 있다.  \r\n세번째 출력문에서는 catch 구문에서 **인자로 받은 변수에는 접근이 불가능** 하다는 것을 알 수 있다.  \r\n\r\n----------\r\n\r\n엄밀하게 따져보면 스코프가 생성되는 방식이 기존 언어와 다르지 않다.  \r\n하지만 스코프가 지속되는 것은 다른 언어와는 다른 자바스크립트만의 강점 중 하나이다.  \r\n이러한 스코프의 지속성이 필요한 이유는 새로운 스코프가 생성되고  \r\n**스코프 체인을 참조하는 함수를 변수에도 넣을 수 있고**,  \r\n**다른 함수의 인자로 넘겨줄 수도 있으며**,  \r\n**함수의 반환값으로 이용할 수도 있기 때문이다**.  \r\n즉, 지금 함수가 선언된 곳이 아닌 전혀 다른 곳에서 함수가 호출 될 수 있어서, 해당 함수가 현재 참조하는 스코프를 지속할 필요가 있는 것이다.\r\n\r\n----------\r\n\r\n함수를 이용한 문제 해결  \r\n\r\n이러한 지속성을 이해하기 위해 앞의 클릭 이벤트 핸들러 문제를 또 다른 방식으로 해결해보자.  \r\n\r\n```html\r\n<button id=\"btn0\">버튼 1</button>\r\n<button id=\"btn1\">버튼 2</button>\r\n<button id=\"btn2\">버튼 3</button>\r\n<script>\r\n  var i, len = 3;\r\n\r\n  function setDiv(index) {\r\n    document.getElementById('btn' + index).addEventListener(\"click\", function () {\r\n      console.log(\"Click btn\", index);\r\n    });\r\n  }\r\n\r\n  for (i = 0; i < len; i++) {\r\n    setDiv(i);\r\n  }\r\n</script>\r\n```\r\n\r\nconsole\r\n\r\n```\r\nClick btn 0\r\nClick btn 1\r\nClick btn 2\r\n```\r\n\r\n이렇게 **함수로 분리하는 것은 비동기 처리를 많이 하는 자바스크립트의 특성에서는 중요하게 생각해야 하는 개발 방식**이다.  \r\n\r\n----------\r\n\r\n클로저를 이용한 문제 해결\r\n\r\n자바스크립트의 특징 중 하나인 클로저를 활용하여 이를 해결 할 수도 있다.\r\n\r\n```html\r\n  <button id=\"btn0\">버튼 1</button>\r\n  <button id=\"btn1\">버튼 2</button>\r\n  <button id=\"btn2\">버튼 3</button>\r\n  <script>\r\n    var i, len = 3;\r\n    /* 처음의 해결 전 코드\r\n    for (i = 0; i < len; i++) {\r\n      document.getElementById('btn'+i).addEventListener(\"click\", function () {\r\n        console.log(\"Click btn\", i);\r\n      });\r\n    }\r\n    */\r\n    for (i = 0; i < len; i++) {\r\n      document.getElementById('btn'+i).addEventListener(\"click\", (function(index) { //1\r\n        return function (){ //2\r\n          console.log(\"Click btn\", index);\r\n        };\r\n      }(i)));//3\r\n    }\r\n  </script>\r\n```\r\n\r\nconsole\r\n\r\n```\r\nClick btn 0\r\nClick btn 1\r\nClick btn 2\r\n```\r\n\r\n이벤트 리스너 실행 전 즉시 호출 함수 실행, 즉시 호출 함수 안의 함수가 반환된 값이 이벤트 리스너 함수의 두번째 인자로 들어간다.  \r\n1, 3은 즉시 호출 함수를 나타냄, 그리고 바로 다음 2는 index변수를 상위 스코프 체인에 추가한 뒤 addEventListener() 함수의 2번째 인자로 들어간다.  \r\n이벤트 리스너가 실행되기 전 먼저 즉시 호출 함수가 값을 반환받아 그 값이 이벤트 리스너의 2번째 인자로 작동하는 것.  \r\n\r\nglobal scope // i=2, len=3 <- function(index) // index = 0 <- btn0.click // empty scope  \r\nglobal scope // i=2, len=3 <- function(index) // index = 1 <- btn1.click // empty scope  \r\nglobal scope // i=2, len=3 <- function(index) // index = 2 <- btn2.click // empty scope  \r\n","excerpt":"스코프 = 현재 접근 할 수 있는 변수들의 범위   예제 1 버튼 3개를 각각 클릭했을때 결과값은 모두 \"Click btn…","fields":{"slug":"/js-scope/"},"frontmatter":{"date":"Jun 19, 2017","title":"자바스크립트의 스코프(Scope)","tags":["javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n\r\nSPA(Single page application) 에서는 새로운 페이지 전체를 렌더링하지 않고, 부분적인 UI를 새로 렌더링한다.\r\n따라서 브라우저는 이 정보에 대한 이력을 남기지 않는다.\r\n결국 ''뒤로가기/앞으로가기''를 사용할 수 없다는 이야기이며,\r\n이는 사용자에게 당연시 되는 기능이므로 안된다면 많은 불편을 야기할 수 있다.\r\n그를 해결하기 위한 방법으로 React-router 라이브러리를 사용하게 된다.\r\n\r\n\r\n\r\n## install\r\n\r\n`npm install --save-dev react-router-dom`\r\n\r\n기존 v3 에서는 react-router 만 설치해서 사용하면 됐었다.\r\nv4에서는 브라우저와 react에서 사용되는 라우터가 분리되어 사용하도록 되어있다.\r\nReact-router-dom을 설치하면 react-router도 같이 설치된다.\r\n\r\n\r\n\r\n## Use\r\n\r\n### Basic \r\n\r\n상단의 헤더, 그 아래 컨텐츠가 나타나는 기본 구조.\r\n\r\n- src/App.js\r\n\r\n```javascript\r\n//..\r\nimport {BrowserRouter as Router, Route} from 'react-router-dom';\r\n\r\nimport Main from './routes/Main';\r\nimport User from './routes/User';\r\nimport Header from './components/Header';\r\nimport Posts from './routes/Posts';\r\n\r\nclass App extends Component {\r\n  render() {\r\n    return (\r\n      <Router>\r\n        <div>\r\n          <Header/>\r\n          <Route exact path=\"/\" component={Main}/>\r\n          <Route path=\"/user\" component={User}/>\r\n          <Route path=\"/posts\" component={Posts}\r\n          {/* exact 키워드가 없으면 /user 경로에서 /도 있는 것으로 인식, \r\n          Main과 User가 동시 출력 된다.*/}\r\n        </div>\r\n      </Router>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n- src/components/Header.js\r\n\r\n```javascript\r\n//..\r\n  return (\r\n    <div>\r\n    \t<Link to=\"/\">Home</Link>\r\n      \t<Link to=\"/User\">User</Link>\r\n    </div>\r\n  );\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n### URL Parameter\r\n\r\n- src/App.js\r\n\r\n```javascript\r\n//..\r\n<Route path=\"/user/:username\" component={User}/>\r\n//..\r\n```\r\n\r\n\r\n\r\n- src/routes/User.js\r\n\r\n```javascript\r\n//..\r\nconst User = ({match}) => {\r\n  return (\r\n  \t<div> UserName is {match.params.username} </div>\r\n  );\r\n}\r\n```\r\n\r\n`…/user/baik` URL로 접속하면 UserName is baik 라는 것을 확인 할 수 있다.\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n### Route in Component\r\n\r\n- src/routes/Posts.js\r\n\r\n```javascript\r\n//..\r\n\r\nimport { Route, Link } from 'react-router-dom';\r\n\r\nconst Post = ({match}) => {\r\n  return (\r\n\t<div>\r\n    \t<h2>{match.params.title}</h2>\r\n    </div>\r\n  );\r\n}\r\n\r\nconst Posts = () => {\r\n  return (\r\n  \t<div>\r\n    \t<h1>Post</h1>\r\n      \t<Link to=\"/posts/react\">React</Link>\r\n      \t<Link to=\"/posts/redux\">Redux</Link>\r\n      \t<Route\r\n          \tpath=\"/posts/:title\"\r\n          \tcomponent={Post}\r\n          />\r\n    </div>\r\n  );\r\n}\r\n\r\nexports default Posts;\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n### NavLink\r\n\r\n- src/components/Header.css\r\n\r\n```css\r\n.item.active {\r\n  \r\n}\r\n```\r\n\r\n- src/components/Header.js\r\n\r\n```javascript\r\n// <Link to ...></Link> => <NavLink to...></NavLink>\r\n\r\n<NavLink exact to=\"/\" className=\"item\" activeClassName=\"active\">Home</NavLink>\r\n\r\n{/* exact를 줘야 효과가 지난후에도 남아있지 않고 정확히 일치할때만 효과 적용 가능*/}\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n### Redirect\r\n\r\n```javascript\r\nimport { Redirect } from 'react-router-dom';\r\n\r\nconst isLogin = false\r\n\r\n//..\r\nreturn (\r\n  <div>\t\r\n\t{!isLogin && <Redirect to=\"/login\"/>}\r\n    MyPage\r\n  </div>\r\n);\r\n```\r\n\r\n\r\n\r\n```javascript\r\nconst Main = ({history}) => {\r\n  return (\r\n  \t<div>\r\n    \t<button onClick={()=>{history.push('/posts')}}>포스트로 이동</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n### Query Parameter\r\n\r\n```javascript\r\n//..\r\nconst Main = ({location}) => {\r\n  return (\r\n      <div>\r\n          {new URLSearchParams(location.search).get('keyword')} 검색\r\n      </div>\r\n  );\r\n}\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n### Make NotFound Page\r\n\r\n- src/App.js\r\n\r\n```javascript\r\n//..\r\nimport {BrowserRouter as Router, Route, Switch} from 'react-router-dom';\r\n\r\n//..\r\nimport notFound from './routes/notFound';\r\n\r\nclass App extends Component {\r\n  render() {\r\n    return (\r\n      <Router>\r\n        <div>\r\n          <Header/>\r\n          \t<div>\r\n              <Switch>\r\n                <Route exact path=\"/\" component={Main}/>\r\n                <Route path=\"/user\" component={User}/>\r\n                <Route path=\"/posts\" component={Posts}/>\r\n                <Route component={notFound}/>\r\n              </Switch>\r\n            </div>\r\n        </div>\r\n      </Router>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\nSwitch를 추가한다.\r\n\r\n기존 Switch가 없고, exact 조차 없을때는 Route 전체를 하나하나 비교해서 출력하나\r\n\r\nSwitch가 있으면 일치하는 것이 있으면 비교를 그만둔다, 끝까지 일치하는 것이 없으면 notFound 컴포넌트를 보여주게 된다.\r\n\r\n\r\n\r\n---\r\n\r\n## Reference\r\n\r\n- CodeSquad\r\n- https://velopert.com/3275\r\n","excerpt":"SPA(Single page application) 에서는 새로운 페이지 전체를 렌더링하지 않고, 부분적인 UI…","fields":{"slug":"/js-react-router-v4/"},"frontmatter":{"date":"Jun 06, 2017","title":"리액트 라우터 V4 사용하기 (React-Router v4)","tags":["react"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n```js\r\nvar user1 = {\r\n  name: 'user1',\r\n  say: function(){ console.log(this.name, \"-\", this) }\r\n}\r\nuser1.say(); //user1 - Object {name: \"user1\", say: function}\r\n/* user1의 this는 해당 user1 object를 가리킨다 */\r\n\r\nvar user = user1.say;\r\nuser(); //undefined - Window {...}\r\n/* user의 this는 window를 가리킨다, window.user()로 window에서 호출했기 때문 */\r\n\r\nvar user2 = {\r\n  name: 'user2',\r\n  say: user1.say\r\n}\r\nuser2.say(); //user2 - Object {name: \"user2\", say: function}\r\n/* user2의 say가 user1의 say의 내용이지만 this는 호출된 해당 user2 object이다 */\r\n\r\nuser2.say.call(user1); //user1 - Object {name: \"user1\", say: function}\r\n/* call과 apply 함수는 this를 자동적으로 만들어진 this가 아닌 지정한 this를 가리키도록 지정하는 것 */\r\n```\r\n\r\n\r\n\r\n**call(), apply()**\r\n\r\n두 함수는 function 객체의 기본 내장 함수이다.\r\n일반적으로 함수가 호출될 때는 내부적으로 call() 함수로 변형되어서 처리된다.\r\ncall과 apply 함수는 this를 자동적으로 만들어진 this가 아닌 지정한 this를 가리키도록 지정하는 것으로 첫번째 인자로 this를 지정하고 두번째 인자로는 함수의 인자를 지정한다.\r\ncall은 함수의 인자를 ','로 여러개를 넘기고 apply는 배열 한개로 넘긴다.\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n#### this의 이해\r\n\r\n일반적인 객체지향 언어와 달리 자바스크립트에서의 this는 조금 다르게 동작하는 경우가 많다.\r\n\r\n일반적인 상황에서 this가 어떻게 결정되는지 알려면 먼저 함수를 호출하는 방법에 대해 살펴봐야한다.\r\n\r\n\r\n\r\n자바스크립트에서 함수가 호출되는 방법은 다음 네가지가 주요하다.\r\n\r\n1. 일반 함수로의 호출\r\n   - ```js\r\n     function hello(name){\r\n       alert('hello', name);\r\n     }\r\n     hello('jhon');\r\n     ```\r\n\r\n2. 멤버함수로의 호출\r\n\r\n   - ```js\r\n     var hello = {\r\n       say : function(){\r\n         alert('hello');\r\n       }\r\n     }\r\n     hello.say();\r\n     ```\r\n\r\n3. call() 함수를 통한 호출\r\n\r\n   - ```js\r\n     function hello(name){\r\n       alert('hello', name);\r\n     }\r\n     hello.call(undefined, \"jhon\");\r\n     ```\r\n\r\n4. apply() 함수를 통한 호출\r\n\r\n   -  ```js\r\n      function hello(name){\r\n        alert('hello', name);\r\n      }\r\n      hello.apply(undefined, [\"jhon\"]);\r\n      ```\r\n\r\n\r\n\r\n\r\n```js\r\nfunction whatsThis(){\r\n  return this.toString();\r\n}\r\nvar user = {\r\n  what: whatsThis,\r\n  toString: function(){\r\n    return \"[objcet user]\"\r\n  }\r\n}\r\n\r\nwhatsThis(); \r\n//일반함수 \"[object Window]\"\r\n//글로벌 객체 window가 this로 설정되어있다.\r\n//일반적으로 함수가 호출될때는 내부적으로 call()함수로 변형되어 처리된다.\r\n//이때 call의 첫번째 인자는 undefined로 넘겨주어 this의 기본값으로 window가 되게 된다.\r\n\r\nuser.what(); \r\n//멤버함수 \"[objcet user]\"\r\n//이것또한 내부적으로 call함수로 변형되어 처리된다.\r\n//이때 call함수의 첫번째 인자로는 멤버함수를 보유한 객체(user)가 된다.\r\n//따라서 this는 user가 된다. \r\n//같은 함수라도 멤버함수가 호출되는 방법에 따라 this또한 변경되는 것이다.\r\n\r\nwhatsThis.call(); \r\n//call이용, 인자 없음 \"[object Window]\"\r\n\r\nwhatsThis.apply(user); \r\n//apply이용, 첫번째 인자 user\"[objcet user]\"\r\n\r\nuser.what.call(undefined) \r\n//멤버함수, call이용, 첫번째 인자 undefined \"[object Window]\"\r\n\r\nuser.what.call(user); \r\n//멤버함수, call이용, 첫번째 인자 user \"[objcet user]\"\r\n```\r\n\r\n\r\n\r\n**this는 함수나 스코프를 기반으로 결정되는 것이 나닌, 호출 방법에 따라 변경된다.**\r\n\r\n**콜백함수를 인자로 넘기는 등의 비동기적 방식의 호출이 많은 자바스크립트에서는 중요하게 생각해야한다.**","excerpt":"call(), apply() 두 함수는 function 객체의 기본 내장 함수이다.\n일반적으로 함수가 호출될 때는 내부적으로 call() 함수로 변형되어서 처리된다.\ncall과 apply 함수는 this를 자동적으로 만들어진 this…","fields":{"slug":"/js-this/"},"frontmatter":{"date":"May 14, 2017","title":"자바스크립트 this","tags":["javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n- 함수, 함수가 선언될 때의 environment로 구성  \r\n- 함수가 정의 될 때의 environment가 함께 closure로 결합되면서, 다양한 활용이 가능  \r\n\r\n```js\r\nfunction makeCounterFunction(initVal){\r\n    var count = initVal;\r\n    function Increase(){\r\n        count++;\r\n        console.log(count);\r\n    }\r\n    return Increase;\r\n}\r\n\r\nvar counter1 = makeCounterFunction(0);\r\nvar counter2 = makeCounterFunction(10);\r\n```\r\n- counter1의 closure\r\n    - 함수 : function Increase(){}\r\n    - 환경 : var count = 0;\r\n- counter2의 closure\r\n    - 함수 : function Increase(){}\r\n    - 환경 : var count = 10;\r\n여기서 counter1, counter2 함수가지고는 count 변수의 값을 직접 제어할 수 없다, count 변수는 makecounterfunction 안에 있고 여기선 increse함수밖에 없기때문이다. 이 원리를 이용해 private한 변수를 활용할 수 있다 아래서 확인해보자.\r\n\r\n---\r\n\r\n간단하게 클로저의 두가지 개념을 이해하도록 하자.  \r\n\r\n1) 외부 함수가 소멸된 뒤에도 내부 함수는 외부 함수의 지역 변수에 접근 할 수 있다.  \r\n2) 클로저를 이용하여 private한 변수를 만들 수 있다.  \r\n\r\n1번의 예\r\n```js\r\nfunction sum() {\r\n    var num = 0;\r\n    console.log(num);\r\n    function addsum() {\r\n        console.log(num);\r\n        num++;\r\n        return num;\r\n    }\r\n    return addsum;\r\n}\r\nvar a = sum(); \r\n// function addsum(){...}\r\n// 여기서 sum 함수는 수명이 끝남.\r\n\r\na();\r\n// 여기서 addsum()을 하게 되는 꼴인데,\r\n// num을 증가시키는 부분에서 num은 클로저에 담긴 num이다.\r\n// Closure(sum) num: 0\r\n\r\na();\r\n// Closure(sum) num: 1\r\n\r\na();\r\n// Closure(sum) num: 2\r\n```\r\n\r\n2번의 예\r\n```js\r\nfunction people(name) {\r\n    return {\r\n        get_name: function () {\r\n            console.log(name);\r\n            return name;\r\n        },\r\n        set_name: function (_name) {\r\n            console.log(name);\r\n            name = _name;\r\n        }\r\n    }\r\n}\r\nvar junho = people(\"junhobaik\"); \r\n//여기서 외부 함수의 인자로 값을 넘긴다.\r\n//함수에서는 전달 받은 값을 직접 조작할 수 없게 되고\r\n//get,set_name을 통해서만 접근 할 수 있게 된다.\r\n//이렇게 사용하는 방법으로 private한 변수를 만들 수 있다.\r\n\r\njunho.get_name(); \r\n//이때 실행되는 get_name의 console.log에서 name값은 closure(people) name:'junhobaik' 이다.\r\n```\r\n\r\n---\r\n\r\n### 추가 내용\r\n\r\n```html\r\n<button id=\"btn0\">버튼 1</button>\r\n<button id=\"btn1\">버튼 2</button>\r\n<button id=\"btn2\">버튼 3</button>\r\n<script> \r\n    for (var i = 0; i < 3; i++) {\r\n        document.getElementById('btn' + i).addEventListener(\"click\", function () {\r\n            console.log(\"Click btn\", i+1);\r\n        });\r\n    }\r\n</script>\r\n```\r\n기대하는 결과는 Click btn1,2,3 하지만 실제 결과는 Click btn3,3,3  \r\n그 이유는 아래와 같다.  \r\n1. for문을 돌며 버튼 1,2,3에 이벤트가 등록되며 콜백함수또한 등록된다. (여기서 위에서 살펴본 설명으로 이벤트는 외부함수, 콜백함수는 내부함수라고 할 수 있다)\r\n2. 이벤트가 등록되면서 이벤트 함수는 스택에서 떠난다 (소멸되었다)\r\n3. 따라서 콜백함수는 클로저 i값에 접근하게 되는데 클로저 i값은 콜백함수 모두가 공유하게 되는 값이다.\r\n4. for문을 통해 증가가 완료된 값이 클로저에 남아있고, 그 클로저 값이 계속해서 노출되는 것이다.\r\n\r\n해결 방법  \r\n1. let을 이용한 block scope 생성을 통한 해결\r\n2. 이벤트 함수(외부함수)를 또 함수로 묶어 새로운 scope를 만들어낸다.","excerpt":"함수, 함수가 선언될 때의 environment로 구성   함수가 정의 될 때의 environment가 함께 closure로 결합되면서, 다양한 활용이 가능   counter1의 closure 함수 : function Increase…","fields":{"slug":"/js-clouser/"},"frontmatter":{"date":"Apr 19, 2017","title":"자바스크립트 클로저(Closure)","tags":["javascript"],"update":null}}},{"node":{"rawMarkdownBody":"\r\n자바스크립트에서 모든 객체는 자신의 부모 객체와 연결 되어있다.  \r\n이것을 이용하여 객체지향에서 자식이 부모 객체의 요소를 가져다 쓸 수 있는 상속 개념을 사용할 수 있다.\r\n\r\n모든 객체는 자신을 생성한 생성자 함수의 prototype 프로퍼티가 가리키는 프로토타입 객체를 자신의 부모 객체로 설정하는 [[Prototype]] 프로퍼티로 연결한다. `[[Prototype]] Link`\r\n\r\n생성된 객체의 실제 부모 역활을 하는 건 생성자 자신이 아닌 생성자의 prototype 프로퍼티가 가리키는 프로토타입 객체이다.\r\n\r\n## Prototype?\r\n\r\n```js\r\nfunction Person(name){\r\n    this.name = name;\r\n}\r\nvar foo = new Person('foo');\r\n```\r\nPerson() 생성자는 prototype 프로퍼티로 자신과 링크된 프로토타입 객체(Person.prototype)를 가리킨다.  \r\n\r\nPerson() 생성자로 생성된 객체 foo는,  \r\nPerson() 함수의 프로토타입 객체를 [[Prototype]]Link로 연결한다.  \r\n\r\n\r\n### 프로토타입 체이닝\r\n특정 객체의 프로퍼티나 메서드에 접근하려 할 때, 해당 객체에 접근하려고 하는 프로퍼티나 메서드가 없다면 [[Prototype]]Link를 따라 자신의 부모 방향으로 프로토타입 객체의 프로퍼티를 차례대로 검사하는 것을 말한다.  \r\n즉, 프로토타입 체이닝을 통해 자신이 아닌 부모의 프로토타입 객체 프로퍼티에도 접근이 가능.  \r\n\r\n객체 리터럴로 생성한 객체는 Object()라는 내장 생성자 함수로 생성된 것으로,  \r\nObject가 갖고 있는 prototype 프로퍼티가 가리키는 프로토타입 객체인 Object.prototype 객체를 자신의 프로토타입 객체로 연결한다.\r\n\r\n\r\n```js\r\n//...위의 예제 코드...\r\nconsole.log(foo.hasOwnProperty('name'));\r\n```\r\n위의 예제 아래 이런 코드를 넣는다면 프로토타입 체이닝에 따라서 hasOwnProperty 메서드를 찾게 된다.  \r\n`foo > Person.prototype > Object.prototype.hasOwnProperty`\r\n\r\n\r\n프로토타입 또한 자바스크립트 객체이다. 함수가 생성될 때 자신의 prototype 프로퍼티에 연결되는 프로토타입 객체는 기본적으로 constructor 프로퍼티만을 가진 객체이다.  \r\n따라서 일반 객체처럼 동적으로 프로퍼티를 추가/삭제하는 것이 가능하다. 또한 변경된 프로퍼티는 프로토타입 체이닝에 항시 반영된다.\r\n\r\n```js\r\nfunction Person(name) {\r\n    this.name = name;\r\n}\r\n\r\nvar foo = new Person('foo');\r\n\r\nvar func = function() {console.log('hello');}\r\n\r\nPerson.prototype.sayHello = func;\r\nfoo.sayHello(); // Hello\r\n```\r\n---\r\n\r\nPrototype을 이용한 간단한 Todo list 예제\r\n\r\n```js\r\nvar toDoObj = { //이것을 변경하면 변경사항이 항시 반영되어 나타난다.\r\n  show: function () {\r\n    var listLength = this.toDoList.length;\r\n    for (var i = 0; i < listLength; i++) {\r\n      console.log('- ', this.toDoList[i]);\r\n    }\r\n  }\r\n  , add: function (task) {\r\n    this.toDoList.push(task);\r\n  }\r\n  , del: function (index) {\r\n    this.toDoList.splice(index, 1);\r\n  }\r\n}\r\n\r\nfunction toDo() {\r\n  this.toDoList = [];\r\n}\r\n\r\ntoDo.prototype = toDoObj; \r\n//todo 함수 객체의 프로토타입에 toDoObj를 추가해 \r\n//show,add,del을 프로퍼티를 사용할 수 있게 된다.\r\n//class toDo extends toDoObj {...}\r\n\r\nvar allTask = new toDo();\r\n//Object.setPrototypeOf(allTask,toDoObj);\r\n//toDo.prototype을 통해 todo() 생성자를 이용해 allTask라는 객체를 만들기 전에\r\n//todo.prototype = toDoObj를 하여 프로토타입을 추가하는 방법 대신에\r\n//object.setPrototypeOf를 사용하여 \r\n//allTask 객체에 toDoObj를 추가하는 방법 또한 있다.\r\n\r\nconsole.log(\"task 1~5 추가\");\r\nallTask.add(\"task 1\");\r\nallTask.add(\"task 2\");\r\nallTask.add(\"task 3\");\r\nallTask.add(\"task 4\");\r\nallTask.add(\"task 5\");\r\nallTask.show();\r\nconsole.log(\"\\n2,3 제거\");\r\nallTask.del(1);\r\nallTask.del(2);\r\nallTask.show();\r\n```\r\n\r\n\r\n---\r\n## References\r\n- [https://github.com/jsonko/dailyJavaScript/blob/171161c67ddcfb8dad369bb826e73cb5f4f93588/PrototypeChaining.md](https://github.com/jsonko/dailyJavaScript/blob/171161c67ddcfb8dad369bb826e73cb5f4f93588/PrototypeChaining.md)\r\n- [https://github.com/KyusungDev/JSStudy/blob/5167fba10310d2b177aa26be43fb0d3b2b831f8b/docs/books/inside_javascript/02.md](https://github.com/KyusungDev/JSStudy/blob/5167fba10310d2b177aa26be43fb0d3b2b831f8b/docs/books/inside_javascript/02.md)\r\n- [https://github.com/Lutece/sundayJavascript/blob/85d633268926261307ec18a3d4dad8c644e0c60f/inside_javascript/ch03/chapter03-04.md](https://github.com/Lutece/sundayJavascript/blob/85d633268926261307ec18a3d4dad8c644e0c60f/inside_javascript/ch03/chapter03-04.md)","excerpt":"자바스크립트에서 모든 객체는 자신의 부모 객체와 연결 되어있다. 이것을 이용하여 객체지향에서 자식이 부모 객체의 요소를 가져다 쓸 수 있는 상속 개념을 사용할 수 있다. 모든 객체는 자신을 생성한 생성자 함수의 prototype…","fields":{"slug":"/js-prototype/"},"frontmatter":{"date":"Apr 18, 2017","title":"자바스크립트 프로토타입(Prototype)","tags":["javascript"],"update":null}}}]}},"pageContext":{}}}